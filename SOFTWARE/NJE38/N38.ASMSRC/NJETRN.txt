*
*-- NJE38 - TSO TRANSMIT
*
*   Command line format:
*
*   TRANSMIT node.userid
*            DATASET( )
*            OUTDATASET( )
*            VOLSER( )
*            UNIT( )
*            PDS | SEQUENTIAL
*            QUIET
*
*   where:
*
*    node.userid    - specifies the destination of the transmission
*
*    DATASET( )     - specifies the dsname of the dataset to be
*                     transmitted.  May optionally specify a member.
*
*    OUTDATASET( )  - optional. Specifies the encoded file is to be
*                     written to this dataset instead of being
*                     transmitted.  'node.userid' may be omitted if
*                     OUTDATASET is specified, but if it is present
*                     then the specified node and userid will be part
*                     of the encoded data instead of meaningless
*                     defaults. If OUTDATASET is specified, the
*                     named dataset will be used if it exists, other-
*                     wise it will be created.
*                     The contents of OUTDATASET can be input to a
*                     RECEIVE command by the use of RECEIVE INDATASET.
*
*    VOLSER( )      - optional. Specifies a volume where OUTDATASET
*                     should be created.  If not specified, a PUBLIC
*                     volume will be selected.
*
*    UNIT( )        - optional. Specifies a unit name where OUTDATASET
*                     should be created.  If not specified, SYSDA is
*                     the default unit name.
*
*    PDS            - If specified, indicates that the member name
*                     specified with DATASET is to be transmitted
*                     with IEBCOPY unload, thereby preserving the
*                     user directory data in the source PDS.
*
*    SEQUENTIAL     - DEFAULT. Indicates that any member name specified
*                     with DATASET is to be transmitted as a sequential
*                     file; no directory information is part of the
*                     transmission. SEQL must be specified or defaulted
*                     if the destination host is a VM system.
*
*    QUIET          - If specified, indicates that all informational
*                     messages from TRANSMIT are suppressed.  Error
*                     messages will always be displayed.
*
*
*    Examples (a user is logged on to TSO with userid FRED:
*
*    1. Send member COBSRC from FRED.MY.PDS to user HERC01 at
*       node MVSA.  The directory information associated with COBSRC
*       is to be part of the transmission:
*
*       TRANSMIT mvsa.herc01 da(my.pds(cobsrc)) pds
*
*    2. Encode dataset HERC02.COBOL.LISTING into FRED.NETLIB:
*
*       TRANSMIT da('herc02.cobol.listing') out(netlib)
*
*    3. Send macro GETQ from FRED.MACLIB to CMSUSER at VMSYS1.
*
*       TRANSMIT vmsys1.cmsuser da(maclib(getq))
*
*
* Change log:
*
* 15 Feb 21 - Not picking up jobname when run as an STC.           v221
* 10 Dec 20 - Support for registered users and message queuing     v220
* 01 Oct 20 - Put ENQ existence check in common module             v210
* 09 Aug 20 - Improve TSO attention key handling                   v201
* 24 Jul 20 - Fix S013-18 if DATASET member not found              v200
* 15 Jul 20 - Don't display final record count.                    v200
* 12 Jul 20 - Add support for the UNIT parameter.                  v200
* 21 Jun 20 - Initial creation
*
*
         GBLC  &VERS
         REGEQU
NJETRN   CSECT                                                          NJE00020
         NJEVER
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJETRN,R12                                               NJE00070
         LR    R8,R1                   Copy input parm addr
*
         GETMAIN RU,                   Get local stg area              X
               LV=4096,                                                X
               BNDRY=PAGE
         LR    R10,R1
         LR    R1,R0                   Copy length
         LR    R2,R0                   Copy length
         LR    R0,R10                  -> new stg area
         SR    R15,R15                 set pad
         MVCL  R0,R14                  Clear the page
*
         USING NJEWK,R10
         ST    R13,NJESA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R1,NJESA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
         MVC   NJEEYE,=CL4'NJET'       Work area eyecatcher
         ST    R2,NJEWKLEN             Save size of area in area
         L     R11,=A(NJECOM)          -> common csect
         USING NJECOM,R11
         ST    R8,CPARMS               Save ptr to input parms
         MVC   LCLNODE,=CL8'ORIGNODE'  Set default local node
         MVC   DESTNODE,=CL8'DESTNODE'  Set default
         MVC   DESTUSER,=CL8'DESTUSER'  Set default
         MVC   PBREM,=F'80'            Initialize
         LA    R1,REC                  -> output record area
         ST    R1,PBRPS                Initialize
*
INIT000  EQU   *
         MVC   MACLIST(ESTAEL),ESTAE   Move ESTAE parm list
         L     R6,=A(NJEDMP)           Point to local ESTAE rtn
         ESTAE (R6),                   Issue ESTAE                     X
               CT,                                                     X
               TERM=YES,                                               X
               PARAM=(R10),            PARAM is work area address      X
               MF=(E,MACLIST)
*
*-- Establish TSO userid issuing this command
*
         TESTAUTH FCTN=1               Are we authorized on entry?
         LTR   R15,R15                 Check result
         BNZ   INIT010                 Branch if not authorized
         OI    FLAGS1,F1APF            Indicate authorized on entry
*
INIT010  EQU   *
         L     R2,PSATOLD-PSA(0)       -> my TCB
         L     R2,TCBTIO-TCB(R2)       -> my TIOT
         LA    R3,TIOCNJOB-IEFTIOT(R2) -> TIOT jobname
*
         L     R2,PSAAOLD-PSA(0)       -> my ASCB
         L     R6,ASCBTSB-ASCB(,R2)    -> TSB (or 0)
         L     R2,ASCBASXB-ASCB(,R2)   -> my ASXB
         ICM   R2,15,ASXBSENV-ASXB(R2) -> my ACEE
         BZ    INIT015                 Exit if no ACEE
*
         USING ACEE,R2
         CLI   ACEEUSRL,X'00'          No userid available?
         BE    INIT015                 Exit if unavail
         CLI   ACEEUSR,X'00'           Userid not formed correctly?
         BE    INIT015                 Exit if unavail
         LA    R3,ACEEUSR              -> Userid
         OI    FLAGS1,F1ACEE           Valid ACEE found
         CLC   ACEEUSR,=CL8'STC'       Is this a started task?     v221
         BNE   INIT015                 No, use ACEEUSR id          v221
         LR    R3,R4                   Make the TIOT jobname the idv221
         DROP  R2                      ACEE
*
INIT015  EQU   *
         MVC   USERID,0(R3)            Set the userid
         TM    FLAGS1,F1APF            Authorized at entry?
         BO    INIT040                 yes.
         CLC   USERID,=CL8'HERC01'     Special access id?
         BE    INIT020                 Yes
         CLC   USERID,=CL8'HERC02'     Special access id?
         BNE   INIT030                 No
*
INIT020  EQU   *
         OI    FLAGS1,F1AUSR           Indicate special authorized user
         SR    0,0                     Use authorization SVC
         LA    1,1                      For TK4- HERC01/HERC02 only
         SVC   244                     Get authorized
         B     INIT040
*
INIT030  EQU   *
         TM    FLAGS1,F1APF            Authorized at entry?
         BZ    ERR006                  No, issue error
*
INIT040  EQU   *
         LA    R6,0(,R6)               Clear high order byte
         LTR   R6,R6                   Was there a TSB address
         BNZ   INIT050                 There was. Running in TSO userid
         OI    FLAGS1,F1BATCH          Indicate batch TSO
         TM    FLAGS1,F1ACEE           Valid ACEE found?
         BO    INIT050                 Yes, go with ACEE userid
         BAL   R2,CHK000               See if NJE38 is active      v210
         BNZ   ERR013                  NJE38 is not active         v210
         MVC   USERID,DEFUSER          Use default userid
*
INIT050  EQU   *
         L     R2,4(,R8)               -> UPT from input parms
         USING UPT,R2
         MVC   PREFIX,BLANKS           Init receiving field
         SR    R1,R1                   Clear for IC
         ICM   R1,1,UPTPREFL           Get prefix length
         BZ    INIT060                 No prefix value in use
         BCT   R1,*+10                 Adjust for execute
         MVC   PREFIX(0),UPTPREFX      executed instr
         EX    R1,*-6                  Copy the prefix value
         DROP  R2                      UPT
*
INIT060  EQU   *
         MVC   STAXLIST(STAXL),STAX    Move STAX parm list
         LA    R5,LIST                 -> input buffer from attn
         LA    R6,STAXXIT              Point to local exit
         STAX  (R6),                   Set exit for attention          X
               OBUF=(ATTNMSG,L'ATTNMSG),                               x
               IBUF=((5),80),                                          x
               USADDR=(10),            Parameter is our work area      x
               MF=(E,MACLIST)
*
*-- Parse command line
*
         SR    R0,R0                   Code 0: parse command line
         L     R15,=A(NJEPAR)          -> parse routine
         BALR  R14,R15
*
         TM    FLAGS1,F1ATTN           Was ATTN pressed?           v201
         BO    EXIT08                  Y, immediate exit           v201
*
         B     INIT070(R15)            Branch into table on RC
INIT070  B     INIT080                 Continue
         B     ERR004                  No parameters entered
         B     ERR005                  Invalid node.user entered
         B     ERR001                  Display IJKPARS RC
*
INIT080  EQU   *
         LA    R2,MSG000               Issue hello msg
         BAL   R14,PUTLINE
         LA    R2,MSGBLNK              Issue blank line
         BAL   R14,PUTLINE
*
*-- Check if we have the required parameters:
*
*-- 1. DATASET is required.  No exceptions.
*-- 2. Either one of:
*--    a.  OUTDATASET, or,
*--    b.  node.userid
*-- 3. If node.user specified, we need NJE38 to be active.
*
         TM    FLAGS3,F3INDS           Was DATASET specified?
         BZ    ERR002                  N, it is required
         TM    FLAGS3,F3OUTDS          Was OUTDATASET specified?
         BO    INIT090                 Y, we don't need NJE38
         TM    FLAGS3,F3DEST           Do we have a node.user?
         BZ    ERR011                  No, bail out.
*
         BAL   R2,CHK000               Determine NJE38 status      v210
         BNZ   ERR013                  NJE38 is not active         v210
*
*-- Set up user selected input dataset
*
*-- 1. Dynamically allocate it (also return DSORG and VOLSER).
*-- 2. OBTAIN the DSCB for the dataset to get DCB attributes.
*-- 3. Use DEVTYPE and TRKCALC along with the DSCB last used TTR to
*--    determine how many blocks were used in the dataset.
*-- 4. If it was a PDS, count the number of directory blocks.
*
INIT090  EQU   *
         MVC   TDSNAME,INPUTDS         Set DSNAME of user dataset
         MVC   TMEMBER,INMEM           Set member name (or null)
*
         LA    R0,DYNINDS         24   allocate input dataset
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15                 Any errors?
         BNZ   EXIT08                  Exit if allocation error
         TM    TDSORG,X'42'            Is it DSORG=PO/PS ?
         BZ    ERR003                  No, can't support it
*
         MVC   DDSYSUT1,TDDNAME        Save off the DDNAME returned
         TM    FLAGS3,F3PDS            Was PDS forced?
         BO    INIT100                 Y, use IEBCOPY instead of PS mbr
         TM    FLAGS3,F3INMEM          Was a member name specified?
         BZ    INIT100                 No, DSORG is what it is
         MVC   TDSORG,=X'4000'         Member makes it DSORG=PS
*
INIT100  EQU   *
         XC    CAMWORK,CAMWORK         Init CAMLST work area
         MVC   CAMLST,DMYLST           Move dummy CAMLST to area
         LA    R1,CAMLST               -> CAMLST
         LA    R4,TDSNAME              -> DATASET NAME
         ST    R4,4(,R1)               Put in CAMLST
         LA    R4,TVOLSER              -> VOLSER
         ST    R4,8(,R1)               Put in CAMLST
         LA    R4,CAMWORK              -> AT WORK AREA
         ST    R4,12(,R1)              Put in CAMLST
*
         OBTAIN (1)                    Get the format 1 DSCB
         LA    R4,CAMWORK-44           -> DSCB we obtained (less DSN)
         USING DSCBF1,R4
         LTR   R15,R15                 SUCCESSFUL?
         BNZ   ABEND101                No
*
INIT110  EQU   *
         LA    R7,INMF02A              -> first INMR02 data items
         USING INMFIELD,R7
         MVC   DSORG,TDSORG            Set DSORG
         SR    R0,R0                   Clear for IC
         ICM   R0,3,DS1BLKL
         ST    R0,BLKSIZE              Set BLKSIZE
         ICM   R0,3,DS1LRECL
         ST    R0,LRECL                Set LRECL
         MVC   RECFM,DS1RECFM          Set RECFM
         MVC   DSNAME,INPUTDS          Set DSNAME
         MVC   UTLNAME,=CL8'INMCOPY'   Assume utility is sequential cpy
         TM    DSORG,X'40'             Is DSORG=PS?
         BO    INIT120                 Yes
         MVC   UTLNAME,=CL8'IEBCOPY'   Utility is for partitioned
*
*
INIT120  EQU   *
         DEVTYPE TDDNAME,DEVINFO,DEVTAB  Get device info
         LTR   R15,R15                 Success?
         BNZ   ABEND102                No
*
INIT130  EQU   *
         MVC   MACLIST(TRKCALCL),TRKCALC  Move macro model
         TRKCALC FUNCTN=TRKCAP,      Calc track capacity for this blkszX
               REGSAVE=YES,          Save all regs                     X
               TYPE=DEVUCBTY+3,      Point to device type byte         X
               R=1,                  Record 1 = calc for entire track  X
               K=0,                  No Keys                           X
               DD=DS1BLKL,           Use the BLKSIZE from DSCB         X
               MF=(E,MACLIST)        R0 = # blks per track on exit
*
*
         SR    R1,R1                   Clear
         L     R3,BLKSIZE              Get current block size
         MR    R2,R0                   Compute bytes per track
         SR    R1,R1                   Clear
         ICM   R1,3,DS1LSTAR           Get TT of last used TTR
         LA    R1,1(,R1)               One extra for partial last track
         MR    R2,R1                   Compute approx bytes in file
         ST    R3,FILESIZE             Set approx file size in bytes
         DROP  R4                      DSCBF1
*
*-- If input dataset is a PDS, count the number of directory blocks.
*-- Then, use IEBCOPY to unload the PDS into a sequential file.
*
         TM    DSORG,X'40'             Is DSORG=PS?
         BO    OUT000                  Y, done with input dataset
*
         OI    FLAGS1,F1INPDS          INDS is a PDS dataset
         MVC   INDS(DMYINDSL),DMYINDS  Set up DCB
         LA    R6,INDS                 -> DCB
         USING IHADCB,R6
         MVC   DCBDDNAM,DDSYSUT1       Set DCB DDNAME
         MVC   DCBBLKSI,=Y(256)        Set up to read dir blocks
         MVC   DCBLRECL,=Y(256)        Set up to read dir blocks
         MVI   DCBRECFM,DCBRECF        RECFM=F
         LA    R1,INIT150              -> temporary EOF addr
         ST    R1,DCBEODAD             Set it
         DROP  R6
*
         MVC   MACLIST(OPENL),OPEN     Move OPEN list
         OPEN  (INDS,INPUT),           Open the input dataset          X
               MF=(E,MACLIST)
         OI    FLAGS2,F2INOPN          Indicate DCB is open
         SR    R2,R2                   Init directory blocks counter
*
INIT140  EQU   *
         GET   INDS                    Get a dir block
         LA    R2,1(,R2)               Count it
         B     INIT140
*
INIT150  EQU   *
         ST    R2,DIRBLKS              Set DIRBLKS value
         TM    FLAGS2,F2INOPN          Is INDS DCB open?
         BZ    UNLD000                 No
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (INDS),                 Close it                        X
               MF=(E,MACLIST)
         NI    FLAGS2,255-F2INOPN      Indicate DCB is closed
*
*-- If DATASET is a PDS, prepare to call IEBCOPY to unload it.
*
*-- 1. Create sequential dataset for IEBCOPY to unload into.
*-- 2. Allocate other required IEBCOPY datasets.
*-- 3. If user specified a member name in DATASET, build IEBCOPY
*--    control statements.
*-- 4. Invoke IEBCOPY to unload the entire PDS or single member.
*
UNLD000  EQU   *
         LA    R6,INMF02A              -> 1st INMR02 record
         LA    R7,INMF02B              -> 2nd INMR02 record
         USING INMFIELD,R7
*
*-- Filling dynamic allocation text units for unload PS dataset
*
         LA    R1,3120                 Use 3120 for IEBCOPY SYSUT2
         STH   R1,TBLKSIZE             Set dynalloc block size
         STCM  R1,7,TBLKLEN            Set dynalloc space blk len
*
         L     R3,FILESIZE-INMFIELD(R6) Get INDS size
         ST    R3,FILESIZE             Use as temporary DS size
         SR    R2,R2                   Clear for divide
         DR    R2,R1                   Compute # blocks needed
         LA    R3,1(,R3)               Always round up
         LR    R1,R3                   Return primary blocks in R1
         SRL   R3,2                    Compute 1/4th of needed amt
         LA    R2,1(,R3)               Round up = secondary blks needed
*
         STCM  R1,7,TPRIME             Set primary space in blocks
         STCM  R2,7,TSECND             Set secondary space in blocks
*
         MVC   TDSORG,=X'4000'         Always PS
*
*
*-- Call NJEDYN to allocate the unload output dataset as "SYSUT2"
*
         LA    R0,DYNUNLD         10   allocate unload dataset
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
*
         B     UNLD020(R15)            Branch on RC
UNLD020  B     UNLD040             00  Normal, proceed
         B     EXIT08              04  Dataset exists, shouldnt happen
         B     EXIT08              08  All other errors
*
*-- Prepare to launch IEBCOPY
*
UNLD040  EQU   *
         MVC   DDSYSUT2,TDDNAME        Set replacement SYSUT2 DD
*
*-- Call NJEDYN to allocate the SYSIN dataset needed by IEBCOPY
*
         LA    R0,DYNSYSIN        08   allocate SYSIN for IEBCOPY
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSIN,TDDNAME         Save generated DDNAME
*
*-- Call NJEDYN to allocate the SYSPRINT dataset needed by IEBCOPY
*
         LA    R0,DYNSYSPR        12   allocate SYSPRINT for IEBCOPY
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSPR,TDDNAME         Save generated DDNAME
*
*-- Call NJEDYN to allocate the SYSUT4 dataset needed by IEBCOPY
*
         LA    R0,DYNSYSU4        14   allocate SYSUT4 temporary
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
         MVC   DDSYSUT4,TDDNAME        Set replacement SYSUT4 DD
*
         TM    FLAGS3,F3INMEM          Was a member name specified?
         BZ    UNLD080                 No, skip ctl card build
         BAL   R14,CTL000              Build IEBCOPY control statements
*
*-- Invoke IEBCOPY
*
UNLD080  EQU   *
         MVC   CPYPLIST,COPYPARM       Move IEBCOPY parms to 24-bit stg
         MVC   DDLISTL,=AL2(DDLISTSZ)  Set IEBCOPY DD list length
         LA    R2,CPYPLIST
         LA    R3,DDLISTL
         MVC   MACLIST(LINKL),LINK     Move macro model
         LINK  EP=IEBCOPY,                                             x
               PARAM=((R2),(R3)),                                      x
               VL=1,                                                   x
               MF=(E,MACLIST)
         LTR   R5,R15                  Copy RC to R5
         BNZ   ERR018                  Exit on error
*
*-- Find out what we can about the IEBCOPY unloaded dataset
*
*-- 1. OBTAIN the DSCB for the dataset to get DCB attributes.
*-- 2. Use DEVTYPE and TRKCALC along with the DSCB last used TTR to
*--    determine how many blocks were used in the dataset.
*
UNLD100  EQU   *
         XC    CAMWORK,CAMWORK         Init CAMLST work area
         MVC   CAMLST,DMYLST           Move dummy CAMLST to area
         LA    R1,CAMLST               -> CAMLST
         LA    R4,TDSNAME              -> DATASET NAME
         ST    R4,4(,R1)               Put in CAMLST
         LA    R4,TVOLSER              -> VOLSER
         ST    R4,8(,R1)               Put in CAMLST
         LA    R4,CAMWORK              -> AT WORK AREA
         ST    R4,12(,R1)              Put in CAMLST
*
         OBTAIN (1)                    Get the format 1 DSCB
         LA    R4,CAMWORK-44           -> DSCB we obtained (less DSN)
         USING DSCBF1,R4
         LTR   R15,R15                 SUCCESSFUL?
         BNZ   ABEND103                No
*
UNLD110  EQU   *
         LA    R7,INMF02B              -> 2nd INMR02 data items
         USING INMFIELD,R7
         MVC   DSORG,TDSORG            Set DSORG
         SR    R0,R0                   Clear for IC
         ICM   R0,3,DS1BLKL
         ST    R0,BLKSIZE              Set BLKSIZE
         ICM   R0,3,DS1LRECL
         ST    R0,LRECL                Set LRECL
         MVC   RECFM(1),DS1RECFM       Set RECFM
         MVI   RECFM+1,X'02'           Indicate shortened variable fmt
         XC    DSNAME,DSNAME           No DSNAME in INMR02B
         MVC   UTLNAME,=CL8'INMCOPY'   Utility is sequential cpy
*
*
UNLD120  EQU   *
         DEVTYPE TDDNAME,DEVINFO,DEVTAB  Get device info
         LTR   R15,R15                 Success?
         BNZ   ABEND104                No
*
UNLD130  EQU   *
         MVC   MACLIST(TRKCALCL),TRKCALC  Move macro model
         TRKCALC FUNCTN=TRKCAP,      Calc track capacity for this blkszX
               REGSAVE=YES,          Save all regs                     X
               TYPE=DEVUCBTY+3,      Point to device type byte         X
               R=1,                  Record 1 = calc for entire track  X
               K=0,                  No Keys                           X
               DD=DS1BLKL,           Use the BLKSIZE from DSCB         X
               MF=(E,MACLIST)        R0 = # blks per track on exit
*
*
         SR    R1,R1                   Clear
         L     R3,BLKSIZE              Get current block size
         MR    R2,R0                   Compute bytes per track
         SR    R1,R1                   Clear
         ICM   R1,3,DS1LSTAR           Get TT of last used TTR
         LA    R1,1(,R1)               One extra for partial last track
         MR    R2,R1                   Compute approx bytes in file
         ST    R3,FILESIZE             Set approx file size in bytes
         DROP  R4                      DSCBF1
*
*-- Prep OUTDATASET if specified
*
*--  Determine if it exists,
*--   If yes, DSORG must be PS unless OUTDS member coded.
*--   If no, create it, 3120/80/FB,
*--      and create as PDS if user specified a OUTDS member, else SEQL,
*--      using estimated file size from input dataset.
*
OUT000   EQU   *
         TM    FLAGS3,F3OUTDS          Did user specify OUTDATASET?
         BZ    OPN000                  No, transmit to NETSPOOL
*
OUT200   EQU   *
         MVC   CAMLST,LOCATLST         Move modem CAMLST
         XC    BUFF,BUFF               Clear sufficient camlst workarea
         XC    REC,REC                 Clear more
         LA    R1,CAMLST               -> CAMLST
         LA    R2,OUTPUTDS             -> DATASET name
         ST    R2,4(,R1)               Place in CAMLST
         LA    R2,CAMWORK              -> CAMLST work area
         ST    R2,12(,R1)              Place in CAMLST
*
         LOCATE (1)                    Does dataset exist?
         LTR   R15,R15                 Any errors?
         BNZ   OUT240                  Yes, dataset doesn't exist
         OI    FLAGS2,F2EXIST          Indicate OUTDATASET exists
*
*-- Find out about this existing OUTDATASET
*
OUT210   EQU   *
         LA    R4,CAMWORK              -> CAMLST work area
         USING VOLLIST,R4              Address the volume list
         MVC   TVOLSER,VOLSER          Save off the volume
         DROP  R4                      VOLLIST
*
         XC    CAMWORK,CAMWORK         Init CAMLST work area
         MVC   CAMLST,DMYLST           Move dummy CAMLST to area
         LA    R1,CAMLST               -> CAMLST
         LA    R4,OUTPUTDS             -> DATASET NAME
         ST    R4,4(,R1)               Put in CAMLST
         LA    R4,TVOLSER              -> VOLSER
         ST    R4,8(,R1)               Put in CAMLST
         LA    R4,CAMWORK              -> AT WORK AREA
         ST    R4,12(,R1)              Put in CAMLST
*
         OBTAIN (1)                    Get the format 1 DSCB
         LA    R4,CAMWORK-44           -> DSCB we obtained (less DSN)
         USING DSCBF1,R4
         LTR   R15,R15                 SUCCESSFUL?
         BNZ   ABEND105                No
*
OUT220   EQU   *
         TM    DS1DSORG,X'40'          Is it a Seql dataset?
         BO    OUT230                  Yes
         TM    DS1DSORG,X'02'          Is it a PDS dataset?
         BZ    ERR007                  No, error; must be PS or PO
         TM    FLAGS3,F3OUTMEM         Did user also code member name?
         BZ    ERR008                  N, mem req'd if PO
         B     OUT250                  Y, proceed with allocation
*
*-- Whether OUTDATASET existed or not, ignore any member name
*-- coded on OUTDATASET if the dataset is PS.
*
OUT230   EQU   *
         NI    FLAGS3,255-F3OUTMEM     Ignore any user member name
         B     OUT250                  And go allocate it
*
*-- OUTDATASET didn't exist, prepare to create it
*
OUT240   EQU   *
         LA    R2,3120                 3120 = NETDATA output blksize
         STH   R2,TBLKSIZE             Set per NETDATA std
         STCM  R2,7,TBLKLEN            Set per NETDATA std
         MVC   TLRECL,=H'80'           Set per NETDATA std
         MVI   TRECFM,X'90'            Set FB per NETDATA std
         MVC   TDSORG,=X'4000'         Set PS per NETDATA std
         SR    R0,R0                   Clear for divide
         L     R1,FILESIZE             Get # bytes in input file
         DR    R0,R2                   Compute # of 3120 blks needed
*
         LR    R2,R1                   Copy # blks needed
         SRA   R1,3         div by 8   Compute 12% for NETDATA overhead
         AR    R1,R2                   Get # blks + 12%
         STCM  R1,7,TPRIME             Set # primary space blocks
         SRA   R2,2         div by 4   Compute 25% for secondary
         STCM  R2,7,TSECND             Set # secondary space blocks
*
OUT250   EQU   *
         MVC   TDSNAME,OUTPUTDS        Set DSNAME for allocation
         MVC   TMEMBER,OUTMEM          Set possible member name
         MVC   TVOLSER,OUTVOL          Set possible volser override
*
         LA    R0,DYNOUTDS        32   allocate OUTDATASET
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15                 Any errors?
         BNZ   EXIT08                  Exit if allocation error
*
         MVC   DDOUTDS,TDDNAME         Save DD returned
         MVC   OUTDS(DMYOUTDL),DMYOUTDS Set up DCB
         LA    R6,OUTDS                -> DCB
         USING IHADCB,R6
         MVC   DCBDDNAM,DDOUTDS        Set DCB DDNAME
         DROP  R6                      IHADCB
*
         MVC   MACLIST(OPENL),OPEN     Move OPEN list
         OPEN  (OUTDS,OUTPUT),         Open the OUTDATASET             X
               MF=(E,MACLIST)
         OI    FLAGS2,F2OUTOPN         Indicate DCB is open
         B     TRN000                  Start transmitting to OUTDATASET
*
*-- Open NETSPOOL if not using OUTDATASET
*
OPN000   EQU   *
         BAL   R2,CHK000               Determine NJE38 status      v210
         BNZ   ERR013                  NJE38 is not active         v210
*
         MVC   DDNETSPL,=CL8'NETSPOOL' Set NETSPOOL DDN (for unalloc)
         MVC   TDDNAME,DDNETSPL        NETSPOOL DD
         MVC   TDSNAME,SPLDSN          Set spool DSN
         LA    R0,DYNETSPL        28   allocate NETSPOOL
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
         LTR   R15,R15
         BNZ   EXIT08                  Exit with dynalloc error
*
         LA    R8,NCB1                 -> NCB
         USING NCB,R8
         MVI   NCBFL1,TYPPUN           Only outputting punch type recs
*
         NSIO  TYPE=OPEN,                                              x
               NCB=(R8)
         C     R15,=F'4'               NETSPOOL needs verify?
         BE    ERR025                  Yes
         BL    OPN010                  Everything is good
         BAL   R14,FMT000              Display Open error
         CLC   NCBRTNCD(2),=AL1(8,152) X'0898' Security denied access?
         BE    ERR014                  Yes, special message
         B     EXIT08                  Exit on VSAM error
*
OPN010   EQU   *
         OI    FLAGS2,F2NCBOPN         Indicate NETSPOOL is open
*
*-- Create the NETDATA and transmit the results to the destination
*-- node, or store it in the OUTDATASET.
*
*-- DDNAME setup below at TRN000 may look confusing.  To explain:
*-- The NETDATA is always built from a sequential dataset.  So the
*-- INDS DCB here represents either the original user specified
*-- input DATASET -or - the IEBCOPY unloaded sequential dataset from
*-- the original PDS.
*
*-- If the original was sequential, it is already allocated at the
*-- DDSYSUT1 ddname.
*-- If the original was a PDS, then the IEBCOPY unload dataset is
*-- allocated at the DDSYSUT2 ddname.
*
*
TRN000   EQU   *
         MVC   INDS(DMYINDSL),DMYINDS  Set up DCB
         LA    R6,INDS                 -> DCB
         USING IHADCB,R6
         MVC   DCBDDNAM,DDSYSUT2  PDS: Set DCB DDNAME (iebcopy UNLD DD)
*
         TM    FLAGS1,F1INPDS          Is input dataset a PDS?
         BO    TRN210                  Yes
         MVC   DCBDDNAM,DDSYSUT1  SEQ: Set DCB DDNAME (input DS DD)
*
TRN210   EQU   *
         MVC   MACLIST(OPENL),OPEN     Move OPEN list
         OPEN  (INDS,INPUT),           Open the input dataset          X
               MF=(E,MACLIST)
         OI    FLAGS2,F2INOPN          Indicate DCB is open
         DROP  R6                      IHADCB
*
TRN220   EQU   *
         L     R15,=A(NJENET)          -> NETDATA build and write
         BALR  R14,R15                 Go write NETDATA
         LTR   R15,R15                 Any errors?
         BNZ   ERR010                  Write i/o error
*
TRN300   EQU   *
         TM    FLAGS2,F2NCBOPN         Was spool open?
         BZ    TRN350                  No
*
         L     R5,16                   -> CVT
         L     R5,CVTSMCA-CVT(,R5)     -> SMCA
         LA    R5,SMCASID-SMCABASE(,R5) -> system id
*
*-- Fill in the tag data to satisfy the DMTXJE RSCS line driver used
*-- by NJE38.
*
TRN310   EQU   *
         LA    R6,TAGDATA              -> tag data area
         USING TAG,R6
*
         STCK  TAGINTOD                Time of spool file creation
*
         MVC   TAGDEV,=X'000C'         Pseudo card rdr CUU
         MVC   TAGINLOC,LCLNODE        Local node name of origin
         MVC   TAGINVM,USERID          Userid of origin
         MVC   TAGRECNM,OUTRECS        # of records written
         MVC   TAGRECLN,=Y(80)         Move record length
         MVI   TAGINDEV,TYPPUN         data type (PRT/PUN)
         MVC   TAGCLASS,=C'A'          Spool class
         MVC   TAGCOPY,=H'1'           # copies
         MVC   TAGNAME,BLANKS          Init receiving field
         MVC   TAGNAME(8),USERID       Insert userid
         MVC   TAGTYPE,=CL12'OUTPUT'
         MVC   TAGDIST,BLANKS          Init receiving field
         MVC   TAGDIST(4),0(R5)        Insert system id
         MVC   TAGTOLOC,DESTNODE       destination node
         MVC   TAGTOVM,DESTUSER        destination userid
         MVC   TAGPRIOR,=H'1'          priority
         DROP  R6                      TAG
*
TRN320   EQU   *
         NSIO  TYPE=CLOSE,             Close NETSPOOL                  x
               NCB=(R8),                                               x
               TAG=(R6)                Pass TAG data
         NI    FLAGS2,255-F2NCBOPN     Indicate NETSPOOL is closed
*
*-- Let NJE38 know that a few file was just placed into the spool so
*-- it can be queued for transmission.
*
         BAL   R2,CHK000               Determine NJE38 status      v210
         BNZ   TRN350                  NJE38 is not active         v210
         CLC   DESTNODE,LCLNODE        Trying to send file locally?
         BE    TRN350                  Y, but skip the POST
*
         LR    R7,R1                   -> NJE38 CSA ptr to R7      v210
         USING NJ38CSA,R7
*
         MODESET MODE=SUP,KEY=ZERO
*
         GETMAIN RU,                   Get CSA for WRE TYPE=WRENEW     x
               LV=WRESIZE,                                         v220x
               SP=241
         XC    0(WRESIZE,R1),0(R1)     Clear stg area              v220
         USING WRE,R1
         MVI   WRESP,241               Save subpool                v220
         MVI   WRETYPE,WRENEW          "New file in spool" WRE
         MVC   WRELINK,DESTNODE        Set destination node
         MVC   WREUSER,DESTUSER        Set destination userid
*
         LM    R2,R3,NJ38SWAP          Get first WRE ptr, sync count
TRN340   EQU   *
         ST    R2,WRENEXT              First WRE becomes next
         LR    R4,R1                   -> WRE to be added as first
         LA    R5,1(,R3)               Incr synchronization count
         CDS   R2,R4,NJ38SWAP          Update CSA WRE anchor, sync
         BC    7,TRN340                Gotta try again
*
         LA    R6,NJ38ECB              -> NJE38 external WRE ECB
         L     R7,NJ38ASCB             -> NJE38 ASCB
         DROP  R7                      NJ38CSA
*
         MVC   MACLIST(POSTL),POST     Move macro model
         POST  (6),                    Wake up NJE38 to new spool file x
               ASCB=(7),                                               x
               ERRET=TRN350,           Exit if can't do the post       x
               ECBKEY=0,                                               x
               MF=(E,MACLIST)
*
         MODESET MODE=PROB,KEY=NZERO
*
TRN350   EQU   *
*
*
*-- Transmission complete.  Issue # records sent and terminate.
*
*
TRN900   EQU   *
         LA    R2,MSGBLNK
         BAL   R14,PUTLINE             Write blank line
*
         MVC   LIST,BLANKS
*
*-- Record count not displayed until discrepancy with NJE counts   v200
*-- can be resolved.                                               v200
*                                                                  v200
*        L     R15,OUTRECS             # of output records written v200
*        CVD   R15,DBLE                unpk count                  v200
*        MVC   LIST+4(11),=X'2020206B2020206B202120'               v200
*        LA    R1,LIST+14              In case no significance     v200
*        EDMK  LIST+3(12),DBLE+3       Edit result                 v200
*        MVC   LIST+4(12),0(R1)        left justify displayed digitv200
*        TRT   LIST+4(12),BLANK        Look for end                v200
*        LA    R1,1(,R1)               Skip the blank              v200
         MVC   LIST+4(L'MSG009T),MSG009T Move 'file successfully'  v200
         LA    R1,LIST+L'MSG009T+4     -> next available byte      v200
*
         TM    FLAGS3,F3OUTDS          Using OUTDATASET?
         BO    TRN910
         MVC   0(10,R1),=C'queued to '
         MVC   10(8,R1),DESTNODE
         TRT   10(9,R1),BLANK          Look for end of node id
         MVI   0(R1),C'.'              Set dot
         MVC   1(8,R1),DESTUSER        Move userid
         LA    R1,9(,R1)               -> next available byte
         B     TRN920
*
TRN910   EQU   *
         MVC   0(12,R1),=C'written to '''
         MVC   12(44,R1),OUTPUTDS      Move OUTDATASET name
         TRT   12(45,R1),BLANK         Look for end of DSN
         MVI   0(R1),C''''             Set dot
         LA    R1,1(,R1)               -> next available byte
*
TRN920   EQU   *
         LA    R2,LIST                 -> msg
         MVC   0(4,R2),MSG009          Move RDW and flags
         SR    R1,R2
         STH   R1,LIST                 Set updated RDW
         BAL   R14,PUTLINE
         B     EXIT00
*
*
*--Error routines
*
ERR001   EQU   *
         MVC   LIST(4+L'MSG001T),MSG001  Move msg to work area
         CVD   R15,DBLE                unpk IKJPARS RC
         UNPK  LIST+57(2),DBLE
         OI    LIST+58,X'F0'           Fix sign
         LA    R2,LIST                 -> msg
         B     ERRPUT
*
ERR002   EQU   *
         LA    R2,MSG002               Input dataset is required
         B     ERRPUT                  Write it
*
ERR003   EQU   *
         LA    R2,MSG003               Input dataset not PS or PO
         B     ERRPUT                  Write it
*
ERR004   EQU   *
         LA    R2,MSG004               No parameters entered on cmd lin
         B     ERRPUT                  Write it
*
ERR005   EQU   *
         LA    R2,MSG005               Invalid node.user specified
         B     ERRPUT                  Write it
*
ERR006   EQU   *
         LA    R2,MSG006               Not APF authorized
         B     ERRPUT
*
ERR007   EQU   *
         LA    R2,MSG008               OUTDATASET not SEQ or PDS
         B     ERRPUT
*
ERR008   EQU   *
         LA    R2,MSG008               OUTDATASET is PDS but no mem
         B     ERRPUT
*
ERR010   EQU   *
         MVC   LIST(4+L'MSG010T),MSG010  Move msg text
         LA    R1,=CL10'OUTDATASET'    Assume writing to OUTDATASET
         TM    FLAGS3,F3OUTDS          Using OUTDATASET?
         BO    *+8                     We are
         LA    R1,=CL10'NETSPOOL'      NO, its NETSPOOL
         MVC   LIST+4+L'MSG010T(9),0(R1)  Move source of error
         LH    R1,LIST                 Get current msg length
         LA    R1,10(,R1)              Add on the source length
         STH   R1,LIST                 Put back
         LA    R2,LIST                 Write i/o error on OUTDS/SPOOL
         B     ERRPUT
*
ERR011   EQU   *
         LA    R2,MSG011               No destination node.user
         B     ERRPUT
*
ERR013   EQU   *
         LA    R2,MSG013               NJE38 is not active
         B     ERRPUT
*
ERR014   EQU   *
         LA    R2,MSG014               Security denied NETSPOOL access
         B     ERRPUT
*
*-- Member not found in DATASET (come here from ESTAE 013-18)      v200
*
ERR015   EQU   *                                                   v200
         LA    R13,NJESA               Ensure using proper SA sincev200
*                                       we came here from ESTAE    v200
*
         MVC   LIST(4+L'MSG015T),MSG015 Member not found msg       v200
         MVC   LIST+11(8),INMEM        Plug missing member name    v200
*                                                                  v200
         LA    R2,LIST                 -> start of msg             v200
         B     ERRPUT                                              v200
*
*-- TRANSMIT ended because IEBCOPY failed
*
ERR018   EQU   *
         LA    R2,MSGBLNK              -> blank line msg
         BAL   R14,PUTLINE
*
         MVC   LIST(4+L'MSG018T),MSG018 IEBCOPY fail msg
         CVD   R5,DBLE                 Convert IEBCOPY RC
         UNPK  LIST+38(2),DBLE
         OI    LIST+39,X'F0'           Fix sign
*
         LA    R2,LIST                 -> start of msg
         B     ERRPUT                  Display failure
*
ERR025   EQU   *
         LA    R2,MSG025               Need to run VERIFY
         B     ERRPUT
*
ERRPUT   EQU   *
         BAL   R14,PUTLINE
         B     EXIT08
*
*****************
* EXIT FROM     *
* TRANSMIT      *
*****************
*
*
*
EXIT00   EQU   *
         SR    R15,R15                 Set RC=0
         B     XIT000                  Clean up and exit
*
EXIT08   EQU   *
         LA    R15,8                   Set RC=8
         B     XIT000                  Clean up and exit
*
XIT000   EQU   *
         LA    R13,NJESA               Ensure using proper SA in case
*                                       we've come here due to ESTAE
         LR    R5,R15                  Save RC across shutdown
         ESTAE 0                       Disable ESTAE
*
         TM    FLAGS2,F2INOPN          Is input dataset open?
         BZ    XIT010                  No
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (INDS),                 Close it                        X
               MF=(E,MACLIST)
*
XIT010   EQU   *
         TM    FLAGS2,F2OUTOPN         Is OUTDATASET open?
         BZ    XIT020                  No
         MVC   MACLIST(CLOSEL),CLOSE   Move close list
         CLOSE (OUTDS),                Close it                        X
               MF=(E,MACLIST)
*
XIT020   EQU   *
         TM    FLAGS2,F2NCBOPN         Is NETSPOOL open?
         BZ    XIT030                  No
         SR    R6,R6                   Ensure no tag data
         LA    R1,NCB1                 -> NCB
         NSIO  TYPE=CLOSE,             Close the spool                 x
               NCB=(R1),TAG=(R6)
*
XIT030   EQU   *
*                                                                       NJE00200
XIT040   EQU   *                                                        NJE00210
         LA    R3,DDLIST               -> list of DD's we allocated
         LA    R4,UNLISTSZ/8           # of DD list entries
*
XIT050   EQU   *
         CLC   =XL8'00',0(R3)          Unassigned DD?
         BE    XIT060                  Skip to next
*
         MVC   UDDNAME,0(R3)
         LA    R0,UNDYN           00   unalloc
         L     R15,=A(NJEDYN)          -> dynamic allocation rtns
         BALR  R14,R15
*
XIT060   EQU   *                                                        NJE00210
         LA    R3,8(,R3)               -> next DD entry
         BCT   R4,XIT050               Continue unallocation scan
*
XIT070   EQU   *                                                        NJE00210
         TM    FLAGS1,F1AUSR           Special authorized user?
         BZ    XIT080                  Y, Don't need Auth SVC
         SR    0,0                     Use authorization SVC
         SR    1,1                      For HERC01/HERC02 only
         SVC   244                     Get un-authorized
*
XIT080   EQU   *                                                        NJE00210
*
QUIT     EQU   *                                                        NJE00210
         LR    R1,R10                  -> NJEWK main work area page
         L     R13,4(,R13)             -> caller's sa                   NJE00210
         ST    R5,16(,R13)             Set exit RC
         FREEMAIN RU,                                                  x
               LV=4096,                                                x
               A=(1)
         LM    R14,R12,12(R13)         Reload system's regs             NJE00220
         BR    R14                     Return                           NJE00240
*
*-- User ABENDs issued
*
ABEND101 EQU   *
         LA    R1,101                  OBTAIN failed for input DATASET
         B     ABEND
*
ABEND102 EQU   *
         LA    R1,102                  DEVTYPE failed for input DATASET
         B     ABEND
*
ABEND103 EQU   *
         LA    R1,103                  OBTAIN failed for IEBCOPY UNLD
         B     ABEND
*
ABEND104 EQU   *
         LA    R1,104                  DEVTYPE failed for IEBCOPY UNLD
         B     ABEND
*
ABEND105 EQU   *
         LA    R1,105                  OBTAIN failed for OUTDATASET
         B     ABEND
*
*ABEND106 EQU   *                      DSNAME build failure, See
*                                       label B2DSN020 in CSECT NJENET
*
ABEND    ABEND (1),DUMP,STEP
         DROP  R12
*
*-- STAX attention exit
*
*-- Doesn't do anything, but allows us to deallocate and get un-
*-- authorized rather than a native TSO abort.
*
STAXXIT  EQU   *
         STM   R14,R12,12(R13)         Save
         LR    R12,R15                 Get base
         USING STAXXIT,R12
         L     R10,8(,R1)              -> NJEWK area
         USING NJEWK,R10
         OI    FLAGS1,F1ATTN           Indicate ATTN pressed       v201
         LM    R14,R12,12(R13)         Load
         DROP  R12
         BR    R14                     Return
*
         LTORG ,
*
DMYINDS  DCB   DDNAME=INDS,                                            X
               MACRF=(GL),                                             X
               DSORG=PS,                                               X
               BFTEK=A,                                                X
               EODAD=EOD000
DMYINDSL EQU   *-DMYINDS
*
DMYOUTDS DCB   DDNAME=OUTDS,                                           X
               MACRF=(PM),                                             X
               DSORG=PS,                                               X
               BLKSIZE=3120,                                           X
               LRECL=80,                                               X
               RECFM=FB
DMYOUTDL EQU   *-DMYOUTDS
*
*
*
OPEN     OPEN  0,MF=L
OPENL    EQU   *-OPEN
CLOSE    CLOSE 0,MF=L
CLOSEL   EQU   *-CLOSE
LINK     LINK  EP=0,SF=L
LINKL    EQU   *-LINK
ESTAE    ESTAE 0,MF=L
ESTAEL   EQU   *-ESTAE
STAX     STAX  0,OBUF=(0,0),IBUF=(0,0),USADDR=0,MF=L
STAXL    EQU   *-STAX
DMYLST   CAMLST SEARCH,0,0,0
DMYLSTL  EQU   *-DMYLST
LOCATLST CAMLST NAME,0,,0
TRKCALC  TRKCALC MF=L
TRKCALCL EQU   *-TRKCALC
POST     POST  0,ASCB=0,ERRET=0,MF=L
POSTL    EQU   *-POST
*
COPYPARM DC    AL2(L'COPYOPT)
COPYOPT  DC    C'WORK=0512K'
COPYPRML EQU   *-COPYPARM                 TOTAL LENGTH OF PARM OPTION
*
ATTNMSG  DC  C'COMMAND TERMINATED DUE TO ATTENTION; PRESS ENTER TWICE'
*                                                                  v201
*********************
*  N J E C O M      *               NJECOM hosts small routines and
*                   *               frequently used constants that
*  Common routines  *               are available to all NJERxx csects
*  and constants    *               via base register 11
*                   *
*********************
*
NJECOM   CSECT
         DC    A(0)                 No branch around constants
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJECOM'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
         USING NJECOM,R11
*
*-- Write a record to the NJE38 spool, or to OUTDATASET
*
*-- Entry: None
*-- Exit:  RC=0 if write ok, RC=8 if write error.
*
PUT000   EQU   *
         ST    R14,SV14PUT             Save return reg
*
         TM    FLAGS3,F3OUTDS          Did user specify OUTDATASET?
         BZ    PUT050                  No, transmit to NETSPOOL
*
         PUT   OUTDS,REC               Write the record
         SR    R15,R15                 Set RC=0
         B     PUT090
*
PUT050   EQU   *
         LA    R1,NCB1
         NSIO  TYPE=PUT,               Write the record to spool       x
               NCB=(R1),                                               x
               AREA=REC,                                               x
               RECLEN=80
         LTR   R15,R15                 Any errors?
         BZ    PUT090                  No
         BAL   R14,FMT000              Display error
         LA    R15,8                   Set RC=8
*
PUT090   EQU   *
         LA    R1,1                    Get 1
         A     R1,OUTRECS              Bump record count
         ST    R1,OUTRECS              Update output counter
         L     R14,SV14PUT             Load return reg
         BR    R14                     Return with RC in R15
*
*-- Build IEBCOPY control statements
*
*-- Used if a member name was specified on DATASET and the PDS option
*-- was specified.
*
*-- Entry: None
*-- Exit:  None; card images written to the SYSIN dataset.
*
CTL000   EQU   *
         ST    R14,SV14SI              Save return reg
*
         L     R15,=A(DMYOUTDS)        -> DCB to use as model
         MVC   SYSINDS(DMYOUTDL),0(R15) Set up DCB model
         LA    R6,SYSINDS              -> DCB
         USING IHADCB,R6
         MVC   DCBDDNAM,DDSYSIN        Set DCB DDNAME
         DROP  R6                      IHADCB
*
         L     R15,=A(OPEN)            -> model list
         MVC   MACLIST(OPENL),0(R15)   Move OPEN list
         OPEN  (SYSINDS,OUTPUT),       Open the SYSIN dataset          X
               MF=(E,MACLIST)
         OI    FLAGS2,F2SYSOPN         Indicate DCB is open
*
*-- Build IEBCOPY control statements to select one member
*
         MVC   REC,BLANKS              Init record image
         MVC   REC+1(10),=C'COPY INDD='
         MVC   REC+11(8),DDSYSUT1      Set SYSUT1 DD name
         TRT   REC+11(9),BLANK         Look for end
         MVC   0(7,R1),=C',OUTDD='
         MVC   7(8,R1),DDSYSUT2        Set SYSUT2 DD name
         PUT   SYSINDS,REC             Write the COPY ctrl stmt
*
         MVC   REC,BLANKS              Init image
         MVC   REC+1(5),=C'S M=('
         MVC   REC+6(8),INMEM          User specified member name
         TRT   REC+6(9),BLANK          Look for end
         MVI   0(R1),C')'              End selection list
         PUT   SYSINDS,REC
*
         TM    FLAGS2,F2SYSOPN         Is SYSINDS open?
         BZ    CTL090                  No
         L     R15,=A(CLOSE)           -> model list
         MVC   MACLIST(CLOSEL),0(R15)  Move close list
         CLOSE (SYSINDS),              Close it                        X
               MF=(E,MACLIST)
*
CTL090   EQU   *
         L     R14,SV14SI              Load return reg
         BR    R14                     Return
*
*
*-- Format VSAM NETSPOOL errors
*
*
FMT000   EQU   *
         STM   R14,R2,PARSA+12         Borrow NJEPAR save area
         LA    R15,0(,R14)  Clear high, Get addr of call to this rtn
         L     R2,NJESA+4              -> system provided FSA
         L     R2,16(,R2)              Get R15's entry point addr
         LA    R2,0(,R2)               Ensure high byte clear
         SR    R15,R2                  Compute offset of call
         MVC   LIST+0(4+L'MSG024T),MSG024 Move msg text
         MVC   LIST+55(8),5(R2)        Move csect name
         TRT   LIST+55(9),BLANK        Look for end of csect name
         MVI   0(R1),C'+'
*
         ST    R15,DBLE                Save call offset to work area
         UNPK  TWRK(5),DBLE+2(3)       Add zones
         TR    TWRK(4),HEXTRAN-240     Display hex
         MVC   1(4,R1),TWRK            Move call offset to msg
*
         LA    R15,NCB1
         UNPK  TWRK(5),NCBRTNCD-NCB(3,R15)  Add zones
         TR    TWRK(4),HEXTRAN-240
         MVC   LIST+35(4),TWRK         Move rtncd/errcd
*
         UNPK  TWRK(3),NCBREQ-NCB(2,R15)  Add zones
         TR    TWRK(2),HEXTRAN-240
         MVC   LIST+45(2),TWRK         Move req code
*
         L     R1,NCBMACAD-NCB(,R15)   Get failing VSAM macro addr
         LA    R1,0(,R1)               Clear high byte
         S     R1,=V(NJESPOOL)         Compute offset into NJESPOOL rtn
         ST    R1,DBLE
         UNPK  TWRK(5),DBLE+2(3)       Add zones
         TR    TWRK(4),HEXTRAN-240     Display hex
         MVC   LIST+50(4),TWRK         Move NJESPOOL offset to msg
*
         LA    R2,LIST
         BAL   R14,PUTLINE
*
FMT090   EQU   *
         LM    R14,R2,PARSA+12         Restore caller regs
         BR    R14                     Return
*
*-- Write a single line to terminal
*
*-- Entry: R2 -> output msg (RDW+msg text)
*-- Exit:  R15 = RC from PUTLINE
*
PUTLINE  EQU   *
         TM    FLAGS3,F3QUIET          QUIET mode enabled?
         BZ    PUT010                  No, proceed
         CLI   3(R2),1                 Suppress this msg in QUIET mode?
         BER   R14                     Yes
*
PUT010   EQU   *
         ST    R14,SV14LN              Save return
         XC    PUTECB,PUTECB           Clear PUTLINE ECB
         L     R15,CPARMS              -> command input CPPL
         USING CPPL,R15
         LA    R1,IOPLAREA             -> IOPL
         USING IOPL,R1
         MVC   IOPLUPT,CPPLUPT         Set UPT ptr
         MVC   IOPLECT,CPPLECT         Set ECT ptr
         DROP  R15                     CPPL
*
         MVC   TWRK(PBL),PB            Move macro model
         PUTLINE PARM=TWRK,            Write a line                    x
               ECB=PUTECB,                                             x
               OUTPUT=((R2),TERM,SINGLE,DATA),                         x
               MF=(E,(1))
         DROP  R1                      IOPL
         L     R14,SV14LN              Load return
         BR    R14
*
*-- Get status of NJE38
*
*-- Entry: R1=0 (no spool dsn needed), or, R1-> 44-char spool DSN area
*-- Exit:  RC=0  NJE38 is active; R1-> NJE38 CSA block
*--        RC<>0 NJE is not active.
*
*
CHK000   EQU   *
         LA    R1,SPLDSN               => where to place spool DSN v210
         L     R15,=V(NJESYS)          -> ENQ finder               v210
         BALR  R14,R15                 Check if NJE38 already act  v210
         LTR   R15,R15                 Set CC (RC=0 NJE38 active)  v210
         BNZR  R2                      Return if NJE38 inactive    v210
         MVC   LCLNODE,NJ38NODE-NJ38CSA(R1)  Save off lcl node namev210
         MVC   DEFUSER,NJ38DUSR-NJ38CSA(R1)  Save off default user v210
         BR    R2                      Return; NJE38 active        v210
*
         LTORG
*
PB       PUTLINE MF=L
PBL      EQU   *-PB
*
NJE38Q   DC    CL8'NJE38'              QNAME
NJERCON  DC    CL8'NJEINIT'            RNAME (first 8 bytes)
*
*
*
BLANKS   DC    CL120' '
NONBLANK DC    64X'FF',X'00',191X'FF'  TR Table to locate nonblank
BLANK    DC    64X'00',X'FF',191X'00'  TR Table to locate blanks
DOTS     DC    75X'00',X'FF',180X'00'  TR Table to locate '.' char
HEXTRAN  DC    CL16'0123456789ABCDEF'  Translate table
*
NONALNUM EQU   *  0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  0
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  1   Allow alpha-
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  2   numeric only
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  3   and '.'
         DC    X'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF'  4
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  5
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  6
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  7
         DC    X'FF000000000000000000FFFFFFFFFFFF'  8
         DC    X'FF000000000000000000FFFFFFFFFFFF'  9
         DC    X'FFFF0000000000000000FFFFFFFFFFFF'  A
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'  B
         DC    X'FF000000000000000000FFFFFFFFFFFF'  C
         DC    X'FF000000000000000000FFFFFFFFFFFF'  D
         DC    X'FFFF0000000000000000FFFFFFFFFFFF'  E
         DC    X'00000000000000000000FFFFFFFFFFFF'  F
*
*-- TRANSMIT messages
*
*-- Note:  a '1' after the length indicates suppress this msg if QUIET
*
MSGBLNK  DC    Y(4+L'MSGBLNKT,1)
MSGBLNKT DC    C' '
*
MSG000   DC    Y(4+L'MSG000T,1)
MSG000T  DC    C'NJE38 TRANSMIT &VERS'
*
MSG001   DC    Y(4+L'MSG001T,0)
MSG001T  DC    C'Error parsing TRANSMIT command parameters. IKJPARS RC=x
               yy (dec)'
*                456789012345678901234567890123456789012345678901234567
*
MSG002   DC    Y(4+L'MSG002T,0)
MSG002T  DC    C'DATASET(dsname) parameter is missing; it is required'
*
MSG003   DC    Y(4+L'MSG003T,0)
MSG003T  DC    C'Input dataset must be sequential or partitioned (DSORGx
               =PS/PO)'
*                                                                       NJE00250
*
MSG004   DC    Y(4+L'MSG004T,0)
MSG004T  DC    C'No transmit parameters were specified'
*
MSG005   DC    Y(4+L'MSG005T,0)
MSG005T  DC    C'Invalid node.user specification'
*
MSG006   DC    Y(4+L'MSG006T,0)
MSG006T  DC    C'The TRANSMIT command is not APF-authorized'
*
MSG007   DC    Y(4+L'MSG007T,0)
MSG007T  DC    C'OUTDATASET must specify a sequential dataset or PDS wix
               th a member name'
*
MSG008   DC    Y(4+L'MSG008T,0)
MSG008T  DC    C'OUTDATASET specifies a PDS; a member name is required'
*
MSG009   DC    Y(4+L'MSG009T,1)
MSG009T  DC    C'File successfully '         queued to/written to  v200
*
MSG010   DC    Y(4+L'MSG010T,0)
MSG010T  DC    C'I/O error writing '
*
*
MSG011   DC    Y(4+L'MSG011T,0)
MSG011T  DC    C'A destination node.userid was not specified'
*
MSG012   DC    Y(4+44+L'MSG012T,0)
MSG012T  DC    C'Allocation error xxxxxxxx, DSN='
*
MSG013   DC    Y(4+L'MSG013T,0)
MSG013T  DC    C'NJE38 is not active'
*
*
MSG014   DC    Y(4+L'MSG014T,0)
MSG014T  DC    C'Access to the NETSPOOL dataset denied due to security x
               settings'
*
MSG015   DC    Y(4+L'MSG015T,0)                                    v200
MSG015T  DC    C'Member xxxxxxxx was not found'                    v200
*
MSG018   DC    Y(4+L'MSG018T,0)
MSG018T  DC    C'Transmit failed due to IEBCOPY RC=xx'
*                456789012345678901234567890123456789012345678901234567
*
MSG024   DC    Y(4+L'MSG024T,0)
MSG024T  DC    C'ERROR:  NETSPOOL RTNCD/ERRCD=X''0000'',REQ=01,O=1234,Mx
               MMMMMMM     '
*
MSG025   DC    Y(4+L'MSG025T,0)
MSG025T  DC    C'Unable to open NETSPOOL. Run IDCAMS VERIFY against thex
                NETSPOOL dataset'
*
MSG027   DC    Y(4+L'MSG027T,0)
MSG027T  DC    C' exists'
*
MSG031   DC    Y(4+L'MSG031T,0)
MSG031T  DC    C' does not exist'
*
*                                                                       NJE00250
*                                                                       NJE00250
*********************
*  N J E D Y N      *               NJEDYN handles the various
*                   *               dynamic allocations required
*  Handle DYNALLOC  *               and their unallocations as well.
*                   *
*********************
*
*        USING INMFIELD,R7          -> R7 at entry
*
NJEDYN   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEDYN'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJEDYN,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,DYNSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R1,DYNSA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
         MVC   LS99RB,CPS99RB          init THE S99RB
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         ST    R1,LS99PTR              Set parameter word
         OI    LS99PTR,X'80'           Set VL
         LA    R6,TXTPTRS              -> start of text unit list
         ST    R6,S99TXTPP             Put in S99RB
         DROP  R1                      S99RB
*
UNDYN    EQU   0                   00  unallocate DDNAME
DYNUNDEF EQU   4                   04  unused, undefined
DYNSYSIN EQU   8                   08  Allocate SYSIN for IEBCOPY
DYNSYSPR EQU   12                  0C  Allocate SYSPRINT for IEBCOPY
DYNUNLD  EQU   16                  10  Allocate unload dataset IEBCOPY
DYNSYSU4 EQU   20                  14  Allocate SYSUT4 IEBCOPY
DYNINDS  EQU   24                  18  Allocate user input dataset
DYNETSPL EQU   28                  1C  Allocate NETSPOOL
DYNOUTDS EQU   32                  20  Allocate OUTDATASET
*
         LR    R5,R0                   Copy action code
         B     DYN000(R5)              Branch into table
*
DYN000   B     DYN010              00  Perform DDNAME Unallocation
         DC    AL4(0)              04  undefined
         B     DYN200              08  Allocate SYSIN for IEBCOPY
         B     DYN300              0C  Allocate SYSPRINT for IEBCOPY
         B     DYN400              10  Allocate unload dataset IEBCOPY
         B     DYN500              14  Allocate SYSUT4 IEBCOPY
         B     DYN600              18  Allocate user input dataset
         B     DYN700              1C  Allocate NETSPOOL
         B     DYN800              20  Allocate OUTDATASET
*
DYN010   EQU   *
         MVC   UTXT,UTXTD              Init text unit
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         MVI   S99VERB,S99VRBUN        Set verb code to unallocation
         DROP  R1                      S99RB
*
         LA    R0,UTXT                 -> UNALLOC DD text unit
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Deallocate the DD
*
*-- SYSIN for IEBCOPY
*
*   Equivalent JCL  (if command line SEQL specified or defaulted):
*   //SYS00000 DD DUMMY
*
*
*   Equivalent JCL  (if command line PDS specified and a member name
*                    was coded in DATASET):
*   //SYS00000 DD DISP=(NEW,DELETE),UNIT=SYSDA,
*   //            SPACE=(CYL,1)
*
*
DYN200   EQU   *
         TM    FLAGS3,F3PDS            PDS copy forced?
         BO    DYN220                  Y, we need to set up for
*                                        IEBCOPY control statements
*
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT16,TXT16D
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT16                -> DUMMY
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
DYN220   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT03,TXT03D            DISP 1
         MVC   TXT04,TXT04D            DISP 2
         MVC   TXT06,TXT06D            PRIME
         MVC   TXT10,TXT10D            UNIT
         MVC   TXT19,TXT19D            CYL
*
         MVI   TXT04+6,X'04'           Adjust to DISP=,DELETE
         MVC   TXT06+6(3),=XL3'01'     1 cylinders
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=NEW
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP=,DELETE
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> Primary space
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT19                -> SPACE CYL
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- SYSPRINT for IEBCOPY
*
*   Equivalent JCL:
*   //SYS00000 DD SYSOUT=*,TERM=TS
*
DYN300   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT16,TXT16D
         MVC   TXT17,TXT17D
         MVC   TXT18,TXT18D
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         TM    FLAGS3,F3QUIET          QUIET mode enabled?
         BO    DYN310                  Yes, use DUMMY
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT17                -> SYSOUT=*
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT18                -> TERM=TS
         ST    R0,0(,R6)               Plug into ptr list
         B     DYN320
*
DYN310   EQU   *
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT16                -> DUMMY
         ST    R0,0(,R6)               Plug into ptr list
*
DYN320   EQU   *
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Temporary dataset that IEBCOPY will unload into
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,DELETE),UNIT=SYSDA,
*   //            SPACE=(4096,(pri,sec)),
*   //            DCB=(BLKSIZE=4096,DSORG=PS)
*
DYN400   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D            DSN
         MVC   TXT03,TXT03D            DISP1
         MVC   TXT04,TXT04D            DISP2
         MVC   TXT05,TXT05D            Blklen
         MVC   TXT06,TXT06D            Prime
         MVC   TXT07,TXT07D            Second
         MVC   TXT09,TXT09D            volume
         MVC   TXT10,TXT10D            unit
         MVC   TXT12,TXT12D            BLKSIZE
         MVC   TXT13,TXT13D            DSORG
*
         LA    R0,TXT01                -> Return DDNAME text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP text unit 1
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP text unit 2
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT05                -> BLKLEN text unit 2
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> PRIMARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT07                -> SECONDARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT12                -> BLKSIZE text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> DSORG text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT09                -> VOLSER text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSN text unit
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
*
         MVI   TXT04+6,X'04'           Set DISP=,DELETE
         MVC   TXT09(2),=Y(DALRTVOL)   Set to return VOLSER
         MVC   TXT02(2),=Y(DALRTDSN)   Set to return DSN
         B     DYN900                  Go allocate
*
*-- SYSUT4 for IEBCOPY
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,DELETE),UNIT=SYSDA,
*   //            SPACE=(CYL,5)
*
DYN500   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT03,TXT03D            DISP 1
         MVC   TXT04,TXT04D            DISP 2
         MVC   TXT06,TXT06D            PRIME
         MVC   TXT10,TXT10D            UNIT
         MVC   TXT19,TXT19D            CYL
*
         MVI   TXT04+6,X'04'           Adjust to DISP=,DELETE
         MVC   TXT06+6(3),=XL3'05'     5 cylinders
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=NEW
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP=,DELETE
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> Primary space
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT19                -> SPACE CYL
         ST    R0,0(,R6)               Plug into ptr list
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Dataset user.input.dataset from command line
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=SHR,DSNAME=user.input.dataset(mem)
*
DYN600   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT09,TXT09D
         MVC   TXT13,TXT13D
         MVC   TXT21,TXT21D
*
         MVI   TXT03+6,X'08'           set DISP=SHR
         MVC   TXT09(2),=Y(DALRTVOL)   Set to return VOLSER
         MVC   TXT13(2),=Y(DALRTORG)   Set to return DSORG
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=SHR
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT09                -> RETURN VOLSER
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> RETURN DSORG
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         TM    FLAGS3,F3PDS            Was PDS specified?
         BO    DYN610                  Yes, we'll use IEBCOPY, no mbr
         TM    FLAGS3,F3INMEM          Was a member specified?
         BZ    DYN610                  No
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT21                -> MEMBER
         ST    R0,0(,R6)               Plug into ptr list
*
DYN610   EQU   *
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Dataset NETSPOOL
*
*   Equivalent JCL:
*   //NETSPOOL DD DISP=SHR,DSNAME=NJE38.NETSPOOL
*
*
DYN700   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
*
         MVC   TXT01(2),=Y(DALDDNAM)   Use fixed DD
         MVI   TXT03+6,X'08'           set DISP=SHR
*
         LA    R0,TXT01                -> DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=SHR
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Dataset created for OUTDATASET
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=(NEW,CATLG),UNIT=unitname,
*   //            SPACE=(3120,(pri,sec)),
*   //            DCB=(BLKSIZE=3120,LRECL=80,RECFM=FB,DSORG=PS),
*   //            DSN=dsname,VOL=SER=volser
*
DYN800   EQU   *
         TM    FLAGS2,F2EXIST          Does OUTDATASET exist?
         BO    DYN850                  Yes, don't create it
*
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT04,TXT04D
         MVC   TXT05,TXT05D
         MVC   TXT06,TXT06D
         MVC   TXT07,TXT07D
         MVC   TXT08,TXT08D
         MVC   TXT09,TXT09D
         MVC   TXT10,TXT10D
         MVC   TXT12,TXT12D
         MVC   TXT13,TXT13D
         MVC   TXT14,TXT14D
         MVC   TXT15,TXT15D
         MVC   TXT21,TXT21D
*
         LA    R0,TXT01                -> Return DDNAME text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP text unit 1
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT04                -> DISP text unit 2
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT12                -> BLKSIZE text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT05                -> BLKLEN text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT14                -> LRECL text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT15                -> RECFM text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT06                -> PRIMARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT07                -> SECONDARY text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT13                -> DSORG text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT10                -> UNIT text unit
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSN text unit
         ST    R0,0(,R6)               Plug into ptr list
         TM    FLAGS3,F3VOLSER         Was there a volser?
         BZ    DYN810                  No
*
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT09                -> VOLSER text unit
         ST    R0,0(,R6)               Plug into ptr list
*
DYN810   EQU   *
         TM    FLAGS3,F3OUTMEM         Was a member specified?
         BZ    DYN820                  No
         MVC   TDSORG,=X'0200'         Force DSORG to PO if member
         MVC   TDIRBLKS,=AL3(5)        Set 5 directory blocks
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT08                -> DIRBLKS
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT21                -> MEMBER
         ST    R0,0(,R6)               Plug into ptr list
*
DYN820   EQU   *
         TM    FLAGS2,F2UNIT           User specified unit?        v200
         BZ    DYN890                  No                          v200
         MVC   TUNIT,OUTUNIT           Use user specified unit namev200
*
DYN890   EQU   *                                                   v200
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Allocate existing OUTDATASET (with optional member)
*
*   Equivalent JCL:
*   //SYS00000 DD DISP=SHR,DSNAME=out.data.set(mem)
*
DYN850   EQU   *
         MVC   TXT01,TXT01D            Init from the models
         MVC   TXT02,TXT02D
         MVC   TXT03,TXT03D
         MVC   TXT21,TXT21D
*
         MVI   TXT03+6,X'08'           set DISP=SHR
*
         LA    R0,TXT01                -> return DDNAME
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT03                -> DISP=SHR
         ST    R0,0(,R6)               Plug into ptr list
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT02                -> DSNAME
         ST    R0,0(,R6)               Plug into ptr list
*
         TM    FLAGS3,F3OUTMEM         Was a member specified?
         BZ    DYN860                  No
         LA    R6,4(,R6)               -> next ptr list slot
         LA    R0,TXT21                -> MEMBER
         ST    R0,0(,R6)               Plug into ptr list
*
DYN860   EQU   *
         OI    0(R6),X'80'             End the parameter list
         B     DYN900                  Go allocate
*
*-- Allocate the dataset
*
DYN900   EQU   *
         LA    R1,LS99RB               -> S99RB
         USING S99RB,R1
         OI    S99FLAG1,S99NOCNV        FORCE NEW ALLOCATION
         DROP  R1
         LA    R1,LS99PTR               POINTER TO S99 PTR
         SVC   99                       ISSUE DYNALLOC
         LTR   R15,R15                  Any errors?
         BZ    XITDYN00                 No
*
         LA    R1,LS99RB
         USING S99RB,R1
         UNPK  TWRK(9),S99ERROR(5)      Add zones to error code
         DROP  R1
         TR    TWRK(8),HEXTRAN-240
*
         CLI   TWRK+1,C'7'              Class 7 error code?
         BNE   ERR012                   No
         LA    R1,DYNINDS               Code for the input dataset?
         CR    R1,R5                    Was alloc for DYNINDS?
         BE    ERR031                   Yes, dataset does not exist
*
ERR012   EQU   *
         MVC   LIST(4+L'MSG012T),MSG012 Dyn alloc failure msg
         MVC   LIST+21(8),TWRK          Error codes to line
         MVC   LIST+35(44),TDSNAME      Move DSNAME
         LA    R2,LIST                  -> msg
         BAL   R14,PUTLINE              Display it
         B     XITDYN08
*
ERR031   EQU   *
         MVC   LIST,BLANKS
         MVC   LIST+4(9),=C'Dataset '''
         MVC   LIST+13(44),TDSNAME Move name
         TRT   LIST+13(45),BLANK   Look for end of name
         MVI   0(R1),C''''         Close apost
         LA    R1,1(,R1)           Skip apost
         MVC   0(L'MSG031T,R1),MSG031T  Move rest of msg
         LA    R1,L'MSG031T(,R1)   point to end
         XC    LIST(4),LIST        Clear RDW area
         LA    R2,LIST             -> start of RDW+msg
         SR    R1,R2               Compute total length
         STH   R1,LIST             Plug RDW
         BAL   R14,PUTLINE         Inform user
         B     XITDYN04            And exit with dataset doesnt exist
*
*
*-- Exit
*
XITDYN00 EQU   *
         SR    R15,R15             Set RC=0;  alloc/dealloc ok
         B     XITDYN
*
XITDYN04 EQU   *
         LA    R15,4               Set RC=4;  Exit for special action
         B     XITDYN
*
XITDYN08 EQU   *
         LA    R15,8               Set RC=8;  allocation error
*
XITDYN   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         ST    R15,16(,R13)        Set RC
         LM    R14,R12,12(R13)     Reload callers regs
         BR    R14                 Return with RC
*
         LTORG
*        DROP  R7                  INMFIELD
*
*
*
*-- Text unit skeletons
*
*-- Note:  EXPDT is included for completeness but is not used.
*
*
*
TXT01D   DC    Y(DALRTDDN),AL2(1),AL2(8)          RETURN DDNAME
TXT02D   DC    Y(DALDSNAM),AL2(1),AL2(44)         DSNAME
TXT03D   DC    Y(DALSTATS),AL2(1),AL2(1),X'04'    DISP=(NEW,)
TXT04D   DC    Y(DALNDISP),AL2(1),AL2(1),X'02'    DISP=(,CATLG)
TXT05D   DC    Y(DALBLKLN),AL2(1),AL2(3)          BLK TEXT KEY, BLKLEN
TXT06D   DC    Y(DALPRIME),AL2(1),AL2(3)          PRIMARY SPACE UNITS
TXT07D   DC    Y(DALSECND),AL2(1),AL2(3)          SECONDARY SPACE UNITS
TXT08D   DC    Y(DALDIR),AL2(1),AL2(3)            DIRECTORY BLOCKS
TXT09D   DC    Y(DALVLSER),AL2(1),AL2(6)          VOLSER
TXT10D   DC    Y(DALUNIT),AL2(1),AL2(8),CL8'SYSDA' UNIT default    v200
TXT11D   DC    Y(DALEXPDT),AL2(1),AL2(5)          EXPDT C'YYDDD'
TXT12D   DC    Y(DALBLKSZ),AL2(1),AL2(2)          BLKSIZE
TXT13D   DC    Y(DALDSORG),AL2(1),AL2(2)          DSORG
TXT14D   DC    Y(DALLRECL),AL2(1),AL2(2)          LRECL
TXT15D   DC    Y(DALRECFM),AL2(1),AL2(1)          RECFM
TXT16D   DC    Y(DALDUMMY),AL2(0)                 DUMMY
TXT17D   DC    Y(DALSYSOU),AL2(0)                 SYSOUT
TXT18D   DC    Y(DALTERM),AL2(0)                  TERM
TXT19D   DC    Y(DALCYL),AL2(0)                   CYLINDER
TXT20D   DC    Y(DALCLOSE),AL2(0)                 FREE=CLOSE
TXT21D   DC    Y(DALMEMBR),AL2(1),AL2(8)          MEMBER
*
UTXTD    DC    Y(DUNDDNAM),AL2(1),AL2(8)          DD for deallocation
*
         DS    0F
CPS99RB  DS    0XL20                   DEFINE INITIAL S99RB
         DC    AL1(20)                 LENGTH OF REQ BLOCK
         DC    AL1(1)                  VERB CODE:  ALLOCATION
         DC    X'20'                   FLAGS:  NO MOUNTS,OFFLINE VOLS
         DC    X'00'                   FLAGS
         DC    AL2(0)                  ERROR REASON CODE
         DC    AL2(0)                  INFO REASON CODE
         DC    A(0)                    ADDR OF TEXT PTRS
         DC    A(0)                    ADDR OF RBX
         DC    AL4(0)                  MORE FLAGS
*                                                                       NJE00250
*
*
*********************
*  N J E N E T      *               NJENET converts the incoming
*                   *               files into NETDATA format and
*  Output NETDATA   *               writes 80-byte records to the spool
*                   *               or OUTDATASET destination.
*********************
*
NJENET   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJENET'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs
         LR    R12,R15                 Base
         USING NJENET,R12
         USING NJEWK,R10
         ST    R13,NETSA+4             SAVE prv S.A. ADDR
         LA    R1,NETSA                -> my save area
         ST    R1,8(,R13)              Plug it into prior SA
         LR    R13,R1
*
*
****************
* BUILD INMR01 *
****************
*
         USING INMFIELD,R7
         LA    R7,INMF01               -> INMR01 fields
         LA    R3,BUFF                 -> build buffer
         MVI   0(R3),0                 Init control record length
         MVI   1(R3),X'E0'             Indicate 1 segment, ctl record
         MVC   2(6,R3),INMR01          Create INMR01
         LA    R3,8(,R3)               -> next available byte
*
         BAL   R14,B1LRECL             Build the LRECL
         BAL   R14,B1FNODE             Build the FNODE
         BAL   R14,B1FUID              Build the FUID
         BAL   R14,B1TNODE             Build the TNODE
         BAL   R14,B1TUID              Build the TUID
         BAL   R14,B1FTIME             Build the time stamp
         BAL   R14,B1NUMF              Build the number of files
*
         LA    R1,BUFF                 -> start of build buffer
         SR    R3,R1                   Compute INMR01 total length
         STC   R3,0(,R1)               Plug into length byte
*
         LR    R0,R3                   Length to R0
         BAL   R14,PUTBYTES            Write the entire segment
*
****************
* BUILD INMR02 *
****************
*
         LA    R7,INMF02A              -> 1st INMR02 fields
         LA    R3,BUFF                 -> build buffer
         MVI   0(R3),0                 Init control record length
         MVI   1(R3),X'E0'             Indicate 1 segment, ctl record
         MVC   2(6,R3),INMR02          Create INMR02
         MVC   8(4,R3),=F'1'           Set file number to 1
         LA    R3,12(,R3)              -> next available byte
*
         BAL   R14,B2UTIL              Build the Utility name
         BAL   R14,B2FSIZE             Build the file size
         BAL   R14,B2DIRBLK            Build the dir blocks
         BAL   R14,B2LRECL             Build the LRECL
         BAL   R14,B2DSORG             Build the DSORG
         BAL   R14,B2BLKSI             Build the BLKSIZE
         BAL   R14,B2RECFM             Build the RECFM
         BAL   R14,B2DSN               Build the DSNAME
*
         LA    R1,BUFF                 -> start of build buffer
         SR    R3,R1                   Compute INMR02 total length
         STC   R3,0(,R1)               Plug into length byte
*
         LR    R0,R3                   Length to R0
         BAL   R14,PUTBYTES            Write the entire segment
*
****************
* BUILD INMR02 *  Second INMR02 is build if input DS was a PDS
****************
*
         TM    FLAGS1,F1INPDS          Was input DS a PDS?
         BZ    INM3                    No, dont need 2nd INMR02
         LA    R7,INMF02B              -> 2nd INMR02 fields
         LA    R3,BUFF                 -> build buffer
         MVI   0(R3),0                 Init control record length
         MVI   1(R3),X'E0'             Indicate 1 segment, ctl record
         MVC   2(6,R3),INMR02          Create INMR02
         MVC   8(4,R3),=F'1'           Set file number to 1
         LA    R3,12(,R3)              -> next available byte
*
         BAL   R14,B2UTIL              Build the Utility name
         BAL   R14,B2FSIZE             Build the file size
         BAL   R14,B2LRECL             Build the LRECL
         BAL   R14,B2DSORG             Build the DSORG
         BAL   R14,B2BLKSI             Build the BLKSIZE
         BAL   R14,B2RECFM             Build the RECFM
*
         LA    R1,BUFF                 -> start of build buffer
         SR    R3,R1                   Compute INMR02 total length
         STC   R3,0(,R1)               Plug into length byte
*
         LR    R0,R3                   Length to R0
         BAL   R14,PUTBYTES            Write the entire segment
*
****************
* BUILD INMR03 *
****************
*
INM3     EQU   *
         LA    R7,INMF02A              -> 1st INMR02 fields
         L     R0,FILESIZE             Get size from prev INMR02 buffer
         LA    R7,INMF03               -> INMR03 fields
         ST    R0,FILESIZE             Plug it into INMR03 buffer
         LA    R3,BUFF                 -> build buffer
         MVI   0(R3),0                 Init control record length
         MVI   1(R3),X'E0'             Indicate 1 segment, ctl record
         MVC   2(6,R3),INMR03          Create INMR02
         LA    R3,8(,R3)               -> next available byte
*
         BAL   R14,B3FSIZE             Build the file size
         BAL   R14,B3LRECL             Build the LRECL
         BAL   R14,B3DSORG             Build the DSORG
         BAL   R14,B3RECFM             Build the RECFM
*
         LA    R1,BUFF                 -> start of build buffer
         SR    R3,R1                   Compute INMR03 total length
         STC   R3,0(,R1)               Plug into length byte
*
         LR    R0,R3                   Length to R0
         BAL   R14,PUTBYTES            Write the entire segment
         DROP  R7                      INMFIELD
*
****************
* PERFORM      *
* "INMCOPY"    *
* FUNCTION     *
****************
*
CPY000   EQU   *
         LA    R4,INDS                 -> INDS DCB
         USING IHADCB,R4
         LA    R9,253                  Segment size (less len,ctl bytes
*
CPY020   EQU   *
         GET   INDS                    Get input record
         LR    R2,R1                   -> record to R2
         LH    R3,DCBLRECL             Get record length
         MVI   CTL,X'80'               Assume starting new segment
*
         TM    DCBRECFM,DCBRECF        RECFM=F (or U) records?
         BO    CPY060                  Handle them same way
         LH    R3,0(,R2)               Get length from RDW
         S     R3,=F'4'                Remove length of RDW
         LA    R2,4(,R1)               Skip over RDW
*
CPY060   EQU   *
         LR    R5,R3                   Working length to R5
         CR    R3,R9                   LRECL <= max segment size?
         BNH   CPY070                  Yes
         LR    R5,R9                   Else limit to max segment
*
CPY070   EQU   *
         SR    R3,R5                   Compute remaining length
         BCTR  R5,0                    Adjust working len for execute
         EX    R5,MVCREC               Move record to build buffer
         LA    R2,1(R5,R2)             -> next avail byte in record
         LA    R0,3(,R5)               Account for ex, len & ctl bytes
         STC   R0,BUFF                 Set the segment length
         LTR   R3,R3                   Is length remaining?
         BNZ   CPY080                  Yes
         OI    CTL,X'40'               Indicate this is last segment
*
CPY080   EQU   *
         MVC   BUFF+1(1),CTL           Set segment control
         BAL   R14,PUTBYTES            Write the netdata
         TM    CTL,X'40'               Did we process the final seg?
         BO    CPY020                  Yes, time for a new record
         MVI   CTL,X'00'               Clear segment ctl
         B     CPY060                  Go get another
*
MVCREC   MVC   BUFF+2(0),0(R2)         executed instr
*
EOD000   EQU   *
         LA    R3,BUFF                 -> build buffer
         MVI   0(R3),8                 Init control record length
         MVI   1(R3),X'E0'             Indicate 1 segment, ctl record
         MVC   2(6,R3),INMR06          Create INMR01
*
         LA    R0,8                    Write the INMR06 record
         BAL   R14,PUTBYTES
*
         XC    BUFF,BUFF
         L     R1,PBREM                Get # bytes remaining in REC
         LA    R0,1(,R1)               +1 more to force record write
         BAL   R14,PUTBYTES            Write a last full record
         DROP  R4                      IHADCB
         B     XITNET00                NETDATA build complete
*
*
*
*-- NETDATA text unit key build routines
*
*
         USING INMFIELD,R7
B1LRECL  EQU   *
         MVC   0(2,R3),INMLRECL        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         MVC   6(4,R3),=A(80)          LRECL always 80 for INMR01
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B1FNODE  EQU   *
         MVC   0(2,R3),INMFNODE        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   6(8,R3),LCLNODE         Use local node name
         LA    R1,6+8(,R3)             If TRT fails
         TRT   6(8,R3),BLANK           Look for end of name
         LA    R2,6(,R3)               -> start of name
         SR    R1,R2                   Compute length of name
         STCM  R1,3,4(R3)              Set length of name
         LA    R3,6(R1,R3)             -> next available byte
         BR    R14                     Return
*
B1FUID   EQU   *
         MVC   0(2,R3),INMFUID         Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   6(8,R3),USERID          Use userid
         LA    R1,6+8(,R3)             If TRT fails
         TRT   6(8,R3),BLANK           Look for end of name
         LA    R2,6(,R3)               -> start of name
         SR    R1,R2                   Compute length of name
         STCM  R1,3,4(R3)              Set length of name
         LA    R3,6(R1,R3)             -> next available byte
         BR    R14                     Return
*
B1TNODE  EQU   *
         MVC   0(2,R3),INMTNODE        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   6(8,R3),DESTNODE        Use destination node name
         LA    R1,6+8(,R3)             If TRT fails
         TRT   6(8,R3),BLANK           Look for end of name
         LA    R2,6(,R3)               -> start of name
         SR    R1,R2                   Compute length of name
         STCM  R1,3,4(R3)              Set length of name
         LA    R3,6(R1,R3)             -> next available byte
         BR    R14                     Return
*
B1TUID   EQU   *
         MVC   0(2,R3),INMTUID         Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   6(8,R3),DESTUSER        Use destination userid
         LA    R1,6+8(,R3)             If TRT fails
         TRT   6(8,R3),BLANK           Look for end of name
         LA    R2,6(,R3)               -> start of name
         SR    R1,R2                   Compute length of name
         STCM  R1,3,4(R3)              Set length of name
         LA    R3,6(R1,R3)             -> next available byte
         BR    R14                     Return
*
B1FTIME  EQU   *
         MVC   0(2,R3),INMFTIME        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(16)          Set length
         TIME  DEC                     Get the date and time
*                                       R1 = 0yyydddF
*                                       R0 = hhmmssth
         LR    R2,R1                   Copy the date info
         SRL   R2,12                   Put year here: 0000yyyx
         ST    R2,DBLE                 Plug into work area
         OI    DBLE+3,X'0F'            Insert sign
         AP    DBLE(4),=P'1900'        Add base century
         UNPK  6(4,R3),DBLE(4)         Unpk the year
         OI    9(R3),X'F0'             Fix sign
         DP    DBLE(4),=P'4'           Check for leap year
         LA    R15,LEAP                Assume leap year
         CP    DBLE+3(1),=P'0'         Did it divide evenly?
         BE    B1FTME10                Yes, it is a leap year
         LA    R15,NONLEAP             Use non leap year table
*
B1FTME10 EQU   *
         N     R1,=X'0000FFFF'         Keep only the day and sign
         ST    R1,DBLE                 Save into work area
         LA    R2,1                    Init month counter
*
B1FTME20 EQU   *
         CP    DBLE(4),0(2,R15)        Check against days table
         BNH   B1FTME30                Found the right month
         LA    R15,2(,R15)             -> next days entry
         LA    R2,1(,R2)               Next month number
         B     B1FTME20                Continue
*
B1FTME30 EQU   *
         C     R2,=F'1'                Was it found in month 1?
         BE    B1FTME40                Yes, use day as is
         BCTR  R15,0                   Back up
         BCTR  R15,0                    to prior month's entry
         SP    DBLE(4),0(2,R15)        Compute the day number
*
B1FTME40 EQU   *
         UNPK  12(2,R3),DBLE(4)        unpk day number
         OI    13(R3),X'F0'            Fix sign
         CVD   R2,DBLE                 Convert month number
         UNPK  10(2,R3),DBLE           unpk month number
         OI    11(R3),X'F0'            Fix sign
*
         ST    R0,DBLE                 Save the time value
         UNPK  TWRK(9),DBLE(5)         Add zones
         MVC   14(8,R3),TWRK           Mov the time HHMMSSTH
*
         LA    R3,22(,R3)              -> next available byte
         BR    R14                     Return
*
B1NUMF   EQU   *
         MVC   0(2,R3),INMNUMF         Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(1)           Set length
         MVI   6(R3),1                 Only 1 file supported
         LA    R3,7(,R3)               -> next available byte
         BR    R14                     Return
*
B2UTIL   EQU   *
         MVC   0(2,R3),INMUTILN        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   6(8,R3),UTLNAME         Use utility name
         LA    R1,6+8(,R3)             If TRT fails
         TRT   6(8,R3),BLANK           Look for end of name
         LA    R2,6(,R3)               -> start of name
         SR    R1,R2                   Compute length of name
         STCM  R1,3,4(R3)              Set length of name
         LA    R3,6(R1,R3)             -> next available byte
         BR    R14                     Return
*
B2FSIZE  EQU   *
         MVC   0(2,R3),INMSIZE         Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         MVC   6(4,R3),FILESIZE        File size in bytes
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B2DIRBLK EQU   *
         ICM   R0,15,DIRBLKS           Get # of dir blocks needed
         BZR   R14                     This key is not needed
         MVC   0(2,R3),INMDIR          Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(3)           Set length
         STCM  R0,7,6(R3)              Set directory blocks
         LA    R3,9(,R3)               -> next available byte
         BR    R14                     Return
*
B2LRECL  EQU   *
         MVC   0(2,R3),INMLRECL        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         MVC   6(4,R3),LRECL           Set LRECL
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B2DSORG  EQU   *
         MVC   0(2,R3),INMDSORG        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(2)           Set length
         MVC   6(2,R3),DSORG           Set DSORG
         LA    R3,8(,R3)               -> next available byte
         BR    R14                     Return
*
B2BLKSI  EQU   *
         ICM   R0,15,BLKSIZE           Get block size
         BZR   R14                     This key is not needed
         MVC   0(2,R3),INMBLKSZ        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         STCM  R0,15,6(R3)             Set blocksize
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B2RECFM  EQU   *
         TM    RECFM,X'40'             Variable (or U) records?
         BZ    *+8                     No
         MVI   RECFM+1,X'02'           Y, indicate varying w/o RDW fmt
*
         MVC   0(2,R3),INMRECFM        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(2)           Set length
         MVC   6(2,R3),RECFM           Set RECFM
         LA    R3,8(,R3)               -> next available byte
         BR    R14                     Return
*
B2DSN    EQU   *
         CLI   DSNAME,X'00'            DSNAME field filled?
         BER   R14                     Exit if no DSNAME avail
         MVC   0(2,R3),INMDSNAM        Set key
         LA    R1,DSNAME+44            In case TRT fails
         TRT   DSNAME,BLANK            Find end of DSNAME
         LA    R2,DSNAME               -> start
         SR    R1,R2                   Compute DSN length
         LR    R0,R1                   Keep length in R0
         LA    R1,1                    Set # qualifiers to start
         LA    R4,4(,R3)               -> where 1st length fld goes
*
B2DSN010 EQU   *
         LA    R5,2(,R4)               -> DSN qualifier goes
         SR    R6,R6                   Init qualifier length
*
B2DSN020 EQU   *
         CLI   0(R2),C'.'              Look for qualification delim
         BNE   B2DSN040                No, just a regular character
         STCM  R6,3,0(R4)              Fill in length field
         LA    R4,2(R6,R4)             -> next length field area
         LA    R1,1(,R1)               Bump qualifier count
         LA    R2,1(,R2)               -> next DSN character (skip '.')
         BCT   R0,B2DSN010             Keep building
ABEND106 ABEND 106,DUMP                Shouldn't happen
*
B2DSN040 EQU   *
         MVC   0(1,R5),0(R2)           Move a DSN char
         LA    R5,1(,R5)               Next available byte in BUFF
         LA    R6,1(,R6)               Count qualifier length
         LA    R2,1(,R2)               -> next DSN character
         BCT   R0,B2DSN020             Keep building
*
         STCM  R1,3,2(R3)              Set the # field (# qualifiers)
         STCM  R6,3,0(R4)              Fill in length field
         LA    R3,2(R6,R4)             -> next length field area
         BR    R14                     Return
*
B3FSIZE  EQU   *
         MVC   0(2,R3),INMSIZE         Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         MVC   6(4,R3),FILESIZE        File size in bytes
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B3DSORG  EQU   *
         MVC   0(2,R3),INMDSORG        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(2)           Set length
         MVC   6(2,R3),=X'4000'        Set DSORG to PS in INMR03
         LA    R3,8(,R3)               -> next available byte
         BR    R14                     Return
*
B3LRECL  EQU   *
         MVC   0(2,R3),INMLRECL        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(4)           Set length
         MVC   6(4,R3),=A(80)          LRECL always 80 for INMR03
         LA    R3,10(,R3)              -> next available byte
         BR    R14                     Return
*
B3RECFM  EQU   *
         MVC   0(2,R3),INMRECFM        Set key
         MVC   2(2,R3),=Y(1)           Set #
         MVC   4(2,R3),=Y(2)           Set length
         MVC   6(2,R3),=X'0001'        Shortened transmission var fmt
         LA    R3,8(,R3)               -> next available byte
         BR    R14                     Return
*
*
*-- Request some more bytes of NETDATA formatted data
*
*-- Entry:  R0 = # of bytes to write   (1-255)
*--         BUFF contains the data
*
*-- Exit:   None
*
*-- Uses R0-R1,R5-R8,R14-R15; the caller's values in these
*--      registers are not preserved across this call.
*
PUTBYTES EQU   *
         ST    R14,SV14PB              Save return addr
         L     R5,PBREM                Get # bytes remaining in rec buf
         LA    R1,BUFF                 Point to putbytes (PB) buffer
         ST    R1,PBPOS                Set starting position
*
         LR    R8,R0                   Requested amount to R8
*
*
PB010    EQU   *
         LTR   R5,R5                   Any bytes left in phys record?
         BP    PB040                   Yes, use them first
*
         BAL   R14,PUT000              Write the record
         LTR   R15,R15                 Any errors?
         BNZ   XITNET08                Exit if yes
*
         LA    R5,80                   Reset record to 80 remaining
         LA    R1,REC                  -> physical record
         ST    R1,PBRPS                Reset start of record position
*
PB040    EQU   *
         LR    R7,R8                   Assume requested amt avail
         LR    R15,R8                  Same
*
         CR    R5,R8                   Have more than we need?
         BH    PB050                   Yes, just move requested
         LR    R7,R5                   Else move only what we have avai
         LR    R15,R5                  Same
*
PB050    EQU   *
         LR    R0,R7                   Save copy of length to move
         L     R14,PBPOS               -> PB buffer position
         L     R6,PBRPS                -> output record curr position
         MVCL  R6,R14                  Move
*
         ST    R14,PBPOS               New PB position
         ST    R6,PBRPS                New phys record curr position
*
         SR    R5,R0                   Reduce bytes left in phy record
         SR    R8,R0                   Reduce requested amt
         BP    PB010                   We need more, go get it
*
         ST    R5,PBREM                Remember whats left in phy rec
*
         L     R14,SV14PB              Load  return addr
         BR    R14                     Return from getbytes
*
*
*
*-- Exits from NJENET
*
XITNET00 EQU   *
         SR    R15,R15
         B     XITNET
*
XITNET08 EQU   *
         LA    R15,8                   I/O writing records
         B     XITNET
*
XITNET   EQU   *
         L     R13,4(,R13)             -> prev s.a.
         ST    R15,16(,R13)            Set RC
         LM    R14,R12,12(R13)         Reload callers regs
         BR    R14                     Return with RC
*
*
         LTORG
*
NONLEAP  DC    PL2'31,59,90,120,151,181,212,243,273,304,334,365'
LEAP     DC    PL2'31,60,91,121,152,182,213,244,274,305,335,366'
*
*-- Find INMR01 record
*                                                                       NET02190
*                                                                       NET02190
*- Control records that we look for and process (others ignored).       NET02190
INMR01   DC    C'INMR01'               Header Control record            NET02200
INMR02   DC    C'INMR02'               File Utility Control record      NET02210
INMR03   DC    C'INMR03'               Data Control record              NET02210
INMR06   DC    C'INMR06'               Trailer Control record           NET02210
*                                                                       NET02220
*- Keys we are supporting                                               NET02230
INMKEYS  DS    0H
INMBLKSZ DC    X'0030'                 Block size
INMDIR   DC    X'000C'                 Number of directory blocks
INMDSNAM DC    X'0002'                 Name of the file
INMDSORG DC    X'003C'                 File organization
INMFNODE DC    X'1011'                 Origin node name or node number
INMFTIME DC    X'1024'                 Origin timestamp
INMFUID  DC    X'1012'                 Origin user ID
INMLRECL DC    X'0042'                 Logical record length
INMRECFM DC    X'0049'                 Record format
INMSIZE  DC    X'102C'                 File size in bytes
INMTNODE DC    X'1001'                 Target node name or node number
INMTUID  DC    X'1002'                 Target user ID
INMUTILN DC    X'1028'                 Name of utility program
INMNUMF  DC    X'102F'                 Number of files transmitted = 1
         DC    X'FFFF'                 End of table
*                                                                       NET02220
*- Keys we are NOT supporting; for reference                            NET02230
INMCREAT EQU   X'1022'                 Creation date
INMDDNAM EQU   X'0001'                 DDNAME for the file
INMEATTR EQU   X'8028'                 Extended attribute status
INMERRCD EQU   X'1027'                 RECEIVE command error code
INMEXPDT EQU   X'0022'                 Expiration date
INMFACK  EQU   X'1026'                 Originator requested notificat'n
INMFFM   EQU   X'102D'                 Filemode number
INMFVERS EQU   X'1023'                 Origin version num of the data
INMLCHG  EQU   X'1021'                 Date last changed
INMLREF  EQU   X'1020'                 Date last referenced
INMLSIZE EQU   X'8018'                 Data set size in megabytes.
INMMEMBR EQU   X'0003'                 Member name list
INMRECCT EQU   X'102A'                 Transmitted record count
INMSECND EQU   X'000B'                 Secondary space quantity
INMTERM  EQU   X'0028'                 Data transmitted as a message
INMTYPE  EQU   X'8012'                 Data set type
INMTTIME EQU   X'1025'                 Destination timestamp
INMUSERP EQU   X'1029'                 User parameter string
*
*-- Target fields from INMRxx control records that we issue:
*
*
*                       INMR0x    R=required to be sent
*                       1 2 3 6   X=may optionally be sent
INMFIELD DSECT          - - - -
UTLNAME  DS    CL8        R           Utility name                      NET02490
FNODE    DS    CL8      R             Origin node                       NET02580
FUSER    DS    CL8      R             Origin userid                     NET02580
TNODE    DS    CL8      R             Dest node                         NET02580
TUSER    DS    CL8      R             Dest userid                       NET02580
FILESIZE DS    XL4        R R         File size in bytes                NET02500
DIRBLKS  DS    XL4        X           #directory blocks                 NET02500
BLKSIZE  DS    XL4        X           BLKSIZE                           NET02510
LRECL    DS    XL4      R R R         LRECL                             NET02520
DSORG    DS    XL2        R R         DSORG                             NET02540
RECFM    DS    XL2        R R         RECFM                             NET02530
DSNAME   DS    CL44       X           DSNAME                            NET02580
FTIME    DS    CL20     R             Origin time stamp                 NET02580
         DS    0F                     Force to halfword size
INMFSZ   EQU   *-INMFIELD             Size of DSECT
*
*                                                                       NJE00250
*********************
*  N J E P A R      *               NJEPAR calls IKJPARS to parse
*                   *               the TSO command line parameters.
*  TSO Command Line *
*  Parse            *
*                   *
*********************
*
*  Entry:  None.
*
*
*  Exit:   R15 = IKJPARS RC
*
NJEPAR   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEPAR'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         STM   R14,R12,12(R13)         Save Regs                        NJE00050
         LR    R12,R15                 Base                             NJE00060
         USING NJEPAR,R12                                               NJE00070
         USING NJEWK,R10
         ST    R13,PARSA+4             SAVE prv S.A. ADDR               NJE00080
         LA    R2,PARSA                -> my save area
         ST    R2,8(,R13)              Plug it into prior SA
         LR    R13,R2
*
*
         LR    R7,R0                   Copy entry action code
         LR    R6,R1                   Copy any passed ptr
*
*-- Identify and parse out the nodeid.userid if present
*
NOD000   EQU   *
         L     R1,CPARMS               -> CPPL entry parms
         L     R2,0(,R1)               -> Command buffer
         LH    R3,0(,R2)               Get length of command buffer
         C     R3,=F'257'              Is buffer length within 256?
         BL    NOD010                  Yes
         LA    R3,256                  Set to max of 256
*
NOD010   EQU   *
         LR    R4,R3                   Copy final length
         ICM   R3,8,BLANKS             Set pad character
         LA    R0,BUFF                 -> internal 256 byte work buffer
         LA    R1,256                  Max length
         MVCL  R0,R2                   Move CBUF to our stg area
*
         STH   R4,BUFF                 Set adjusted buffer length
         MVC   REC,BLANKS              Use as temporary TRT over-
         MVC   LIST,BLANKS              flow areas
*
NOD020   EQU   *
         SR    R1,R1                   Clear
         LA    R3,BUFF+4               -> copy of cmd buffer (past RDW)
         AH    R3,BUFF+2               -> first parameter
         SH    R4,BUFF+2               Reduce remaining length
         S     R4,=F'4'                Back out length of buffer RDW
         BZ    XITPAR04                No parameters were entered
*
         EX    R4,TRTBLK               Look for end of first param
         BZ    PARS000                 Something wrong, give to parse
         LR    R5,R1                   Save end of param addr
         SR    R1,R3                   Compute length we traversed
         LR    R6,R1                   Save copy of length to R6
         C     R1,=F'3'                Length < 3?
         BL    PARS000                 Can't be node.user
         C     R1,=F'17'               Length > 17?
         BH    PARS000                 Can't be node.user
*
         BCTR  R1,0                    Adjust for execute
         EX    R1,TRTNAN               Look for any non-alphanumeric
         BNZ   PARS000                 Found something, not node.user
*
         EX    R6,TRTDLM               Look for '.' delimiter
         BZ    PARS000                 Didn't find it, not node.user
         LA    R4,1(,R1)               Save addr of userid start
         SR    R1,R3                   Compute length from start to dot
         BZ    PARS000                 Not valid node name
         C     R1,=F'8'                More than 8 char in node name?
         BH    XITPAR08                Not valid node name
         MVC   DESTNODE,BLANKS         Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,OCNODE               Save off node name and uppercase
         LA    R1,1(,R1)               Restore length
         SR    R6,R1                   Reduce length by node name size
         BCTR  R6,0                    Reduce length of '.'
         LTR   R6,R6                   is len=0? (. in last character)
         BZ    XITPAR08                Not valid node.user combo
         C     R6,=F'8'                Userid > 8?
         BH    XITPAR08                Not valid user name
         MVC   DESTUSER,BLANKS         Init receiving field
         BCTR  R6,0                    Adjust for execute
         EX    R6,OCUSER               Save off user name and uppercase
*
         SR    R5,R3                   Compute area size of node.user
         BCTR  R5,0                    Adjust for execute
         EX    R5,MVCREM               Remove node.user from cmd buffer
         OI    FLAGS3,F3DEST           Valid node.user specified
         B     PARS000                 Turn the rest over to parser
*
MVCREM   MVC   0(0,R3),BLANKS          executed instr
OCNODE   OC    DESTNODE(0),0(R3)       executed instr
OCUSER   OC    DESTUSER(0),0(R4)       executed instr
TRTBLK   TRT   0(0,R3),BLANK           executed instr
TRTDLM   TRT   0(0,R3),DOTS            executed instr
TRTNAN   TRT   0(0,R3),NONALNUM        executed instr
*
*
PARS000  EQU   *
         L     R1,CPARMS               -> CPPL entry parms
         LM    R2,R5,0(R1)             Get TSO command entry parameters
*                                       R2 -> Command buffer
*                                       R3 -> UPT
*                                       R4 -> PSCB
*                                       R5 -> ECT
*
         LA    R8,PPLSTG               -> PPL
         USING PPL,R8
         ST    R3,PPLUPT               Set UPT addr
         ST    R5,PPLECT               Set ECT addr
         LA    R3,PARSECB              -> parse ECB
         ST    R3,PPLECB               Set it
         LA    R3,ANSWER               -> IKJPARS "answer area"
         ST    R3,PPLANS               Set it
         ST    R10,PPLUWA              Set user work area addr
*
*                                   ** Process command line
         LA    R2,BUFF                 -> local copy of TSO cmd buff
         ST    R2,PPLCBUF              Set TSO command buffer addr
         L     R3,=A(PCLDEFS)          -> command parms definitions
         ST    R3,PPLPCL               Set it
         B     PARS020
*
PARS020  EQU   *
         CALLTSSR EP=IKJPARS,MF=(E,PPLSTG)   Parse command line
         LTR   R0,R15                  Any parse errors?
         BNZ   XITPAR12                Yes
         DROP  R8                      PPL
*
*- Examine command line results
         L     R4,ANSWER               -> IKJPARS built PCEs
         USING PRDSECT,R4
*
PARS030  EQU   *
         LA    R2,QTPCE                -> QUIET PCE
         CLC   0(2,R2),=AL2(1)         Was QUIET specified?
         BNE   PARS035                 No
         OI    FLAGS3,F3QUIET          Indicate QUIET
*
PARS035  EQU   *
         LA    R2,PDSPCE               -> PDS/SEQL PCE
         CLC   0(2,R2),=AL2(2)         Was PDS specified?
         BNE   PARS040                 No
         OI    FLAGS3,F3PDS            Indic PDS copy and not SEQL copy
*
PARS040  EQU   *
         LA    R2,VOLPCE               -> VOLSER PCE
         TM    6(R2),X'80'             Was VOLSER specified?
         BZ    PARS050                 No
         L     R3,0(,R2)               -> VOLSER string
         LH    R1,4(,R2)               Length of volser
         MVC   OUTVOL,BLANKS           Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVVOL                Move the volser
         OI    FLAGS3,F3VOLSER         Indicate volser valid
*
PARS050  EQU   *
         LA    R2,OTDAPCE              -> OUTDATASET PCE
         TM    6(R2),X'80'             Was OUTDATASET specified?
         BZ    PARS080                 No
         MVC   OUTPUTDS,BLANKS         Init receiving field
         LA    R5,OUTPUTDS             -> where to place DSN
*
         TM    6(R2),X'40'             Was dataset name in quotes?
         BO    PARS060                 Y, don't insert prefix
         CLC   PREFIX,BLANKS           Is a prefix available?
         BE    PARS060                 All blank, dont use prefix
*
         MVC   OUTPUTDS(8),PREFIX      Add the prefix
         TRT   OUTPUTDS,BLANK          Look for end of prefix
         MVI   0(R1),C'.'              Set delim after prefix
         LA    R5,1(,R1)               -> place to put rest of dsn
         LA    R2,OTDAPCE              -> OUTDATASET PCE
*
PARS060  EQU   *
         L     R3,0(,R2)               -> OUTDATASET string
         LH    R1,4(,R2)               Length of DSN
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVDS                 Move the DSN
         OI    FLAGS3,F3OUTDS          Indicate OUTDATASET valid
*
PARS070  EQU   *
         TM    14(R2),X'80'            Was OUTDATASET member specified?
         BZ    PARS080                 No
         L     R3,8(,R2)               -> OUTDATASET member name
         LH    R1,12(,R2)              Length of member name
         MVC   OUTMEM,BLANKS           Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVOUTMEM             Move the member name
         OI    FLAGS3,F3OUTMEM         Indicate OUTDATASET member valid
*
PARS080  EQU   *
         LA    R2,FDAPCE                -> DATASET PCE
         TM    6(R2),X'80'             Was DATASET specified?
         BZ    PARS130                 No                          v200
         MVC   INPUTDS,BLANKS          Init receiving field
         LA    R5,INPUTDS              -> where to place DSN
*
         TM    6(R2),X'40'             Was dataset name in quotes?
         BO    PARS090                 Y, don't insert prefix
         CLC   PREFIX,BLANKS           Is a prefix available?
         BE    PARS090                 All blank, dont use prefix
*
         MVC   INPUTDS(8),PREFIX       Add the prefix
         TRT   INPUTDS,BLANK           Look for end of prefix
         MVI   0(R1),C'.'              Set delim after prefix
         LA    R5,1(,R1)               -> place to put rest of dsn
         LA    R2,FDAPCE               -> DATASET PCE
*
PARS090  EQU   *
         L     R3,0(,R2)               -> DATASET string
         LH    R1,4(,R2)               Length of DSN
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVDS                 Move the DSN
         OI    FLAGS3,F3INDS           Indicate DATASET valid
*
PARS100  EQU   *
         TM    14(R2),X'80'            Was DATASET member specified?
         BZ    PARS120                 No
         L     R3,8(,R2)               -> DATASET member name
         LH    R1,12(,R2)              Length of member name
         MVC   INMEM,BLANKS            Init receiving field
         BCTR  R1,0                    Adjust for execute
         EX    R1,MVINMEM              Move the member name
         OI    FLAGS3,F3INMEM          Indicate SEQL MEMBER specified
         B     PARS130                 We're done                  v200
*
PARS120  EQU   *
         NI    FLAGS3,255-F3PDS        Turn off;we'll do what DSORG say
*
PARS130  EQU   *                                                   v200
         LA    R2,UNIPCE               -> UNIT PCE                 v200
         TM    6(R2),X'80'             Was UNIT specified?         v200
         BZ    PARS190                 No                          v200
         L     R3,0(,R2)               -> UNIT string              v200
         LH    R1,4(,R2)               Length of unit name         v200
         MVC   OUTUNIT,BLANKS          Init receiving field        v200
         BCTR  R1,0                    Adjust for execute          v200
         EX    R1,MVUNIT               Move the unit               v200
         OI    FLAGS2,F2UNIT           Indicate unit valid         v200
*
PARS190  EQU   *
         B     XITPAR00                All done
         DROP  R4                      PRDSECT
*
MVVOL    MVC   OUTVOL(0),0(R3)         executed instr
MVDS     MVC   0(0,R5),0(R3)           executed instr
MVINMEM  MVC   INMEM(0),0(R3)          executed instr
MVOUTMEM MVC   OUTMEM(0),0(R3)         executed instr
MVUNIT   MVC   OUTUNIT(0),0(R3)        executed instr              v200
*
*
*-- Exit
*
XITPAR00 EQU   *
         LA    R1,ANSWER               -> IKJPARS "answer place"
         IKJRLSA (1)                   Release parsing storage
*
         SR    R0,R0               Set secondary RC=0
         SR    R15,R15             Set RC=0;
         B     XITPAR
*
XITPAR04 EQU   *
         SR    R0,R0               Set secondary RC=0
         LA    R15,4               Set RC=4; no parameters entered
         B     XITPAR
*
XITPAR08 EQU   *
         SR    R0,R0               Set secondary RC=0
         LA    R15,8               Set RC=8; invalid node.user combo
         B     XITPAR
*
XITPAR12 EQU   *
         LA    R15,12              Set RC=12; R0 already set by IKJPARS
         B     XITPAR
*
XITPAR   EQU   *
         L     R13,4(,R13)         -> prev s.a.
         L     R14,12(,R13)        Load r14
         LM    R1,R12,24(R13)      Reload callers regs
         BR    R14                 Return with RCs in R0/R15
*
         LTORG
*
*-- IKJPARS Description Macros
*
*-- TRANSMIT command parms:
*
*    TRANSMIT  node.userid DATASET(ddd) OUTDATASET(ooo) VOLSER(vvvvv)
*                          PDS | SEQUENTIAL
*                          QUIET
*
*   Where:
*
*     node.user is the node and userid destination for the file.
*     ddd is the dataset(+member) to be transmitted.
*     ooo is the optional output dataset to write the NETDATA encoded
*         transmission into in lieu of actually sending it.
*     vvv is an optional VOLSER of where to allocate the OUTDATASET.
*
*
PCLDEFS  IKJPARM DSECT=PRDSECT
*
*
QTPCE    IKJKEYWD
         IKJNAME  QUIET            PCE value = 1
*
PDSPCE   IKJKEYWD DEFAULT='SEQUENTIAL'
         IKJNAME  SEQUENTIAL       PCE value = 1
         IKJNAME  PDS              PCE value = 2
*
OTDSPCE  IKJKEYWD
         IKJNAME  'OUTDATASET',SUBFLD=OTDSFLD,ALIAS='OUTDSNAME'
*
FDSPCE   IKJKEYWD
         IKJNAME  'DATASET',SUBFLD=FDSFLD,ALIAS='DSNAME'
*
VSRPCE   IKJKEYWD
         IKJNAME  'VOLSER',SUBFLD=VOLSFLD,ALIAS='VOLUME'
*
USRPCE   IKJKEYWD ,                                                v200
         IKJNAME  'UNIT',SUBFLD=UNISFLD,ALIAS=('U')                v200
*
OTDSFLD  IKJSUBF
OTDAPCE  IKJPOSIT DSNAME,                                              x
               PROMPT='THE NAME OF THE DATA SET YOU WANT TO CONTAIN THEx
                ENCODED FILE'
*
FDSFLD   IKJSUBF
FDAPCE   IKJPOSIT DSNAME,                                              x
               PROMPT='THE NAME OF THE DATA SET YOU WANT TO TRANSMIT'
*
VOLSFLD  IKJSUBF
VOLPCE   IKJPOSIT DSTHING,VOLSER,                                      x
               PROMPT='THE VOLUME SERIAL OF THE VOLUME WHERE YOU WANT Tx
               HE OUTDATASET ALLOCATED'
*
UNISFLD  IKJSUBF ,                                                 v200
UNIPCE   IKJIDENT 'UNIT NAME',MAXLNTH=8,FIRST=ALPHANUM,            v200x
               OTHER=ALPHANUM                                      v200
*
         IKJENDP
*
*
*
         IKJPPL
IKJPPLSZ EQU   (*-PPL)/4           # words in PPL
*
         LTORG
*
*                                                                     *
***********************************************************************
**                                                                   **
**                        TASK ESTAE EXIT                            **
**                                                                   **
** This csect handles all abends trapped by ESTAE during the normal  **
** execution of the subtask.          This exit does not attempt     **
** any recovery other than to terminate processing.                  **
** An SVC dump is taken on abends.                                   **
**                                                                   **
** On entry:  R0=ESTAE provide entry code                            **
**            R1=SDWA address                                        **
**            R2=parameter passed on ESTAE macro                     **
**                                                                   **
**                                                                   **
** On exit: If SDWACLUP is 1, then no retry is allowed and this      **
**             exit will allow percolation back to system routines   **
**             to terminate the task.                                **
**                                                                   **
**          If SDWACLUP is 0, then retry is allowed.                 **
**                                                                   **
** Security:  N/A.                                                   **
**                                                                   **
** Register usage:                                                   **
**                                                                   **
**   R1  = SDWA address                                              **
**   R3  = SDWA address                                              **
**   R10 = Dynamic storage area base                                 **
**   R12 = This program base                                         **
**                                                                   **
**                                                                   **
**                                                                   **
***********************************************************************
*
NJEDMP   CSECT
         B     28(,R15)               BRANCH AROUND EYECATCHERS
         DC    AL1(23)                LENGTH OF EYECATCHERS
         DC    CL9'NJEDMP'
         DC    CL9'&SYSDATE'
         DC    CL5'&SYSTIME'
*
         LR    R12,R15                SET UP BASE REG
         USING NJEDMP,R12             ESTABLISH ADDRESSABILITY
         LR    R8,R14                 SAVE RETURN ADDRESS TO SYSTEM
*
         L     R10,0(,R1)             GET VALUE PASSED TO US (WORKA)
         USING NJEWK,R10
         L     R11,=A(NJECOM)          -> common csect
         USING NJECOM,R11
*
         LR    R3,R1                  SAVE R1 ENTRY CONTENTS
         USING SDWA,R3
         LR    R5,R0                  Save R0 entry code
*
         LTR   R3,R3                  Do we have an SDWA?
         BZ    NOSDWA                 Exit if no SDWA
         LA    R13,MVSSAVE            Save area
         ESTAE 0
*
         MODESET MODE=SUP,            Run this ESTAI exit privileged   x
               KEY=ZERO                to access PSW -> storage
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         L     R6,PSATOLD-PSA(0)      -> my TCB
         L     R5,TCBTIO-TCB(,R6)     -> TIOT
         MVC   MACLIST+9(8),0(R5)         Plug in job name
         MVC   MACLIST+4(4),=C'USER'
         MVC   MACLIST+19(8),=C'TRANSMIT' Plug in command name
*
*
LNK020   EQU   *
         MVC   MACLIST+29(5),=C'ABEND'
         L     R5,SDWAABCC              GET ABEND CODE INFO WORD
         N     R5,=X'00FFF000'          KEEP ONLY THE SYSTEM CODE
         BZ    USERCDE                  NONE THERE, MUST BE A USER CODE
         SRL   R5,12                    Put sys code in low order  v201
         C     R5,=X'00000222'          Operator cancel, no dump?  v201
         BE    SDUMP040                 Yes, suppress dump
         CLM   R5,1,=X'3E'              Was it an x3E (DETACH) ?   v201
         BE    SDUMP040                 Yes, suppress dump         v201
         C     R5,=X'00000013'          Open 013 abend?            v201
         BNE   ACCPT                    no, do the dump            v200
         CLC   SDWAGR15,=X'00000018'    Was it 013-18?             v200
         BE    SDUMP060                 Yes, suppress dump         v200
*
ACCPT    EQU   *                                                   v200
         MVI   MACLIST+35,C'S'          INDICATE SYSTEM CODE
         UNPK  FWORK(5),SDWACMPC(3)     GET SYSTEM CMP CODE
         TR    FWORK(3),HEXTRAN-240
         MVC   FWORK+3(5),=CL5' '       CLEAR REST OF ABEND CODE
         B     NOREAS
*
USERCDE  EQU   *
         MVI   MACLIST+35,C'U'         INDICATE USER ABEND CODE
         L     R5,SDWAABCC             GET ABEND CODE
         N     R5,=X'00000FFF'         KEEP USER ABEND CODE
         CVD   R5,FSAVE                CONVERT CODE TO DECIMAL
         UNPK  FWORK(4),FSAVE          UNPK THE CODE
         OI    FWORK+3,X'F0'           FIX SIGN
         MVC   FWORK+4(2),=CL2' '      BLANKS AT END OF ABEND CODE
*
NOREAS   EQU   *
         MVC   MACLIST+36(6),FWORK     MOVE ABEND-REASON TO LINE
         MVC   ABCODE,MACLIST+36       Save a copy of formatted abcode
*
         WTO   ,MF=(E,MACLIST)        Write to console
         LA    R2,MACLIST
         BAL   14,PUTLINE             Echo to TSO terminal
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(3),=C'PSW'
         UNPK  FSAVE(9),SDWAEC1(5)    Add zones to PSW word 1
         TR    FSAVE(8),HEXTRAN-240
         MVC   MACLIST+10(8),FSAVE
         UNPK  FSAVE(9),SDWAEC1+4(5)  Add zones to PSW word 2
         TR    FSAVE(8),HEXTRAN-240
         MVC   MACLIST+19(8),FSAVE
*
         SR    R5,R5                   CLEAR FOR IC
         IC    R5,SDWAILC1             GET THE ILC
         CVD   R5,FWORK                MAKE DECIMAL
         MVC   MACLIST+29(3),=C'ILC'
         UNPK  MACLIST+33(2),FWORK     UNPK
         OI    MACLIST+34,X'F0'        FIX THE SIGN
*
         MVC   MACLIST+37(4),=C'INTC'
         UNPK  FWORK(5),SDWAINC1(3)    MAKE INTC DISPLAYABLE
         TR    FWORK(4),HEXTRAN-240
         MVC   MACLIST+42(4),FWORK     MOVE INTC TO LINE
*
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE             Echo to TSO terminal
*
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(13),=C'DATA NEAR PSW'
         MVC   MACLIST+19(8),=CL8'UNAVAIL'  ASSUME WE CANT GET DATA
         L     R4,SDWAEC1+4            Get PSW IA
         LA    R4,0(,R4)               Clear high bit
         C     R4,=F'8'                1st 8 bytes of storage?
         BH    LOC010                  No, its higher than that
         SR    R4,R4                   Yes, just use 0
         B     LOC020
*
LOC010   EQU   *
         S     R4,=F'8'                BACK UP BEFORE INTERRUPT ADDR
*
LOC020   EQU   *
         LRA   R0,0(,R4)               Do we have access?
         BNZ   UNAVAIL                 No translation, better not
         LRA   R0,14(,R4)              Do we have access?
         BNZ   UNAVAIL                 No translation, better not
*
         ST    R4,FWORK                SAVE FOR CONVERSION
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES TO ADDRESS
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+19(8),FSAVE     MOVE DISPLAYABLE
*
         MVC   FWORK(4),0(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+29(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),4(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+38(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),8(R4)          MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+47(8),FSAVE     MOVE TO LINE
*
         MVC   FWORK(4),12(R4)         MOVE 4 WORDS AT PSW
         UNPK  FSAVE(9),FWORK(5)       ADD ZONES
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   MACLIST+56(8),FSAVE     MOVE TO LINE
*
UNAVAIL  EQU   *
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE              Echo to TSO terminal
*----
         LA    R4,4                    4 ROWS OF REGISTERS
         LA    R5,SDWAGR00             POINT TO ABEND REGS
         LA    R6,REGLIST              POINT TO REGISTER ID LITERALS
*
REG000   EQU   *
         MVC   MACLIST(WTOMSGL),WTOMSG
         MVC   MACLIST+4(8),0(R6)      MOVE REGISTERS ID
         LA    R15,MACLIST+13          WHERE 1ST REG GOES ON LINE
         LA    R14,4                   4 REGS PER LINE
*
REG010   EQU   *
         UNPK  FSAVE(9),0(5,R5)        UNPK A REGISTER
         TR    FSAVE(8),HEXTRAN-240    MAKE DISPLAYABLE HEX
         MVC   0(8,R15),FSAVE          MOVE TO THE LINE
         LA    R15,10(,R15)            NEXT SPOT ON PRINT LINE
         LA    R5,4(,R5)               NEXT REGISTER
         BCT   R14,REG010              KEEP DOING REGS
         WTO   ,MF=(E,MACLIST)
         LA    R2,MACLIST
         BAL   14,PUTLINE              Echo to TSO terminal
         LA    R6,8(,R6)               NEXT REGISTER ID
         BCT   R4,REG000               GO DISPLAY THE NEXT ROW
*
*
SDUMP000 EQU   *
         L     R5,SDWAABCC             Get abend code info word
         N     R5,=X'00FFF000'         Keep only the system code
         SRL   R5,12                   Right justify the code
         C     R5,=X'00000222'         Operator cancel, no dump?
         BE    SDUMP040                Yes, skip dump
         CLM   R5,1,=X'37'             x37 abend code?
         BE    SDUMP040                Skip the dump
*
         MVI   DHDR,C' '
         MVC   DHDR+1(29),DHDR
         MVI   DHDR,29                IBM length of header
         L     R5,PSATOLD-PSA(0)      -> my TCB
         L     R5,TCBTIO-TCB(,R5)     -> TIOT
         MVC   DHDR+1(8),0(R5)        Use jobname in description
         MVC   DHDR+11(8),=C'TRANSMIT' Use command name
         MVC   DHDR+21(7),ABCODE
*
         MVC   MACLIST(SDUMPL),SDUMP    MOVE SDUMP LIST TO WORK
         LA    R1,MACLIST
         SDUMP HDRAD=DHDR,              ISSUE SDUMP TO RECORD STATUS   x
               BUFFER=NO,                                              x
               QUIESCE=NO,                                             x
               SDATA=(RGN,CSA,LPA,SUM),                                x
               MF=(E,(1))
*
*
SDUMP040 EQU   *
         LR    R1,R3                  SDWA BACK TO R1
         L     R15,=A(NJETRN)         Main csect addr
         ST    R15,SDWASRSV+4*R12     Plug it to R12
         L     R15,=A(EXIT08)         -> TRANSMIT exit point
         B     SDUMP090                                            v200
*
SDUMP060 EQU   *                  **  Here for S013-18 abend only  v200
         LR    R1,R3                  SDWA BACK TO R1              v200
         L     R15,=A(NJETRN)         Main csect addr              v200
         ST    R15,SDWASRSV+4*R12     Plug it to R12               v200
         L     R15,=A(ERR015)         -> TRANSMIT ERRMSG           v200
*
SDUMP090 EQU   *
         SETRP RC=4,                  Retry - try to shut down TRANSMITx
               DUMP=NO,               Suppress any further dumps       x
               FRESDWA=YES,           Free the SDWA                    x
               RETREGS=YES,           Restore original regs            x
               RETADDR=(15)           Return to Transmit exit point
*
NOSDWA   EQU   *                  **  NO RETRY AVAILABLE (OR DESIRED)
         SR    R15,R15                REQUEST PERCOLATION
         LR    R14,R8                 RESTORE RETURN ADDRESS
         BR    R14                    RETURN TO SYSTEM
*
         LTORG
*
SDUMP    SDUMP MF=L
SDUMPL   EQU   *-SDUMP
*
REGLIST  DC    CL8'GR 0-3'
         DC    CL8'GR 4-7'
         DC    CL8'GR 8-11'
         DC    CL8'GR 12-15'
*
WTOMSG   WTO   '                                                       x
                                             ',MF=L
WTOMSGL  EQU   *-WTOMSG
*
         LTORG
*
*
****  Main work area common                                             NJE00290
****  to all NJExxx CSECTs.                                             NJE00290
*                                                                       NJE00290
NJEWK    DSECT
NJEEYE   DS    CL4'NJET'           Eyecatcher
NJEWKLEN DS    F                   Getmain size of this area
*
DBLE     DS    D                   Work area                            NJE00310
TWRK     DS    2D                  Work area
LCLNODE  DS    CL8                 Local node id
DEFUSER  DS    CL8                 Default 'no security' userid
USERID   DS    CL8                 TSO Userid
PREFIX   DS    CL8                 TSO PREFIX
DESTNODE DS    CL8                 Destination node
DESTUSER DS    CL8                 Destination userid
SPLDSN   DS    CL44                NETSPOOL dataset name
*
*
MACLIST  DS    CL96                   Macro expansion area
STAXLIST DS    CL20                   STAX parameter list
*                                                                       NET02360
CPARMS   DS    A                      -> input CPPL (entry parms)
PUTECB   DS    F                      ECB for PUTLINE
IOPLAREA DS    4A                     IOPL for PUTLINE
SV14PUT  DS    A                      R14 save area
SV14LN   DS    A                      R14 save area                     NET02370
SV14PB   DS    A                      R14 save area                     NET02370
SV14SI   DS    A                      R14 save area                     NET02370
*
PBREM    DS    F                      # bytes remaining in phys rec
PBPOS    DS    A                      -> current position in BUFF
PBRPS    DS    A                      -> current position in phys rec
OUTRECS  DS    F                      Count of output records written
*
BLOCKLEN DS    F                      Length of block buffer
BLOCK    DS    A                      -> Block of physical records
*
DEVINFO  DS    0XL20                  5 WORDS OF DEVTYPE INFO
DEVUCBTY DS    F                       DEV TYPE: VALUE OF UCBTYP FIELD
DEVMAXBK DS    F                       MAXIMUM BLKSIZE ON DEVICE
DEVCYLS  DS    XL2                     NUMBER OF CYLINDERS ON DEVICE
DEVTRKS  DS    XL2                     NUMBER OF HEADS ON DEVICE
DEVNUSED DS    0XL8                    2 WORDS NOT USED HERE
*
OLD      DS    F                      For PUTGET, # segments
OLDMSGAD DS    A                      -> msg len/text
*
PARSECB  DS    F                      IKJPARS ECB
ANSWER   DS    F                      IKJPARS Answer area
PPLSTG   DS    (IKJPPLSZ)A            Space for PPL
OUTVOL   DS    CL6                    User specified output volser
OUTPUTDS DS    CL44                   User specified OUTDATASET DSN
OUTMEM   DS    CL8                    User specified OUTDATASET member
OUTUNIT  DS    CL8                    User specified UNIT name     v200
INPUTDS  DS    CL44                   Input dataset name
INMEM    DS    CL8                    User specified input member
*
*
FLAGS1   DS    X                      Flag bits
F1INPDS  EQU   X'80'  1... ....        Input dataset is a PDS, 0=SEQL
F1ATTN   EQU   X'40'  .1.. ....        User pressed ATTN key       v201
F1BATCH  EQU   X'08'  .... 1...        Running in BATCH TSO
F1ACEE   EQU   X'04'  .... .1..        Security is available on system
F1AUSR   EQU   X'02'  .... ..1.        Special user
F1APF    EQU   X'01'  .... ...1        Authorized at invocation
*                     .xxx ....        available bits
*
FLAGS2   DS    X                      Flag bits
F2INOPN  EQU   X'80'  1... ....        INDS DCB open
F2NCBOPN EQU   X'40'  .1.. ....        NETSPOOL NCB open
F2OUTOPN EQU   X'20'  ..1. ....        OUTDS DCB open
F2NJE38  EQU   X'10'  ...1 ....        NJE38 is active (LCLNODE valid)
F2SYSOPN EQU   X'08'  .... 1...        SYSINDS DCB open
F2EXIST  EQU   X'04'  .... .1..        OUTDATASET previously existed
F2UNIT   EQU   X'02'  .... ..1.        UNIT specified              v200
*                     .... ...x        available bits
*
FLAGS3   DS    X                      Flag bits from CMD line parse
F3DEST   EQU   X'80'  1... ....        Valid node.user destination spec
F3PDS    EQU   X'40'  .1.. ....        1=PDS,0=SEQL specified
F3VOLSER EQU   X'20'  ..1. ....        VOLSER specified
F3OUTDS  EQU   X'10'  ...1 ....        OUTDATASET specified
F3OUTMEM EQU   X'08'  .... 1...        OUTDATASET MEMBER specified
F3INDS   EQU   X'04'  .... .1..        DATASET specified
F3INMEM  EQU   X'02'  .... ..1.        DATASET member specified
F3QUIET  EQU   X'01'  .... ...1        1=QUIET suppress info msgs
*
FLAGS4   DS    X                      Flag bits
*                     xxxx xxxx        available bits
*                                                                       NET02470
         DS    0F
INMF01   DS    (INMFSZ)X              Fields for INMR01 record
INMF02A  DS    (INMFSZ)X              Fields for 1st INMR02 record
INMF02B  DS    (INMFSZ)X              Fields for 2nd INMR02 record
INMF03   DS    (INMFSZ)X              Fields for INMR03 record
*                                                                       NET02590
         DS    0F
CAMWORK  DS    0XL140                 CAMLST work area
BUFF     DS    CL256                  GB buffer containing request data NET02600
LIST     DS    CL80                   Print line
REC      DS    CL133                  Physical record from spool
*
*----
LS99PTR  DS    A                       PTR TO S99RB
LS99RB   DS    XL20                    SPACE FOR S99RB
*
TXTPTRS  DS    15A                     -> Text unit ptr list
*
         DS    0H
UTXT     DS    0XL06,Y,AL2,AL2         DDNAME Unallocation
UDDNAME  DS    CL8                      DDNAME
*
         DS    0H
TXT01    DS    0XL06,Y,AL2,AL2         Return DDNAME
TDDNAME  DS    CL8                      DDNAME
*
         DS    0H
TXT02    DS    0XL06,Y,AL2,AL2         DSN=
TDSNAME  DS    CL44                     DSNAME
*
         DS    0H
TXT03    DS    0XL07,Y,AL2,AL2,X       DISP=(NEW,
*
         DS    0H
TXT04    DS    0XL07,Y,AL2,AL2,X       DISP=(,CATLG)
*
         DS    0H
TXT05    DS    0XL06,Y,AL2,AL2         SPACE BLOCK LEN
TBLKLEN  DS    XL3                      BLKLEN
*
         DS    0H
TXT06    DS    0XL06,Y,AL2,AL2         SPACE PRIMARY
TPRIME   DS    XL3                      Primary
*
         DS    0H
TXT07    DS    0XL06,Y,AL2,AL2         SPACE SECONDARY
TSECND   DS    XL3                      Secondary
*
         DS    0H
TXT08    DS    0XL06,Y,AL2,AL2         SPACE DIRECTORY BLOCKS
TDIRBLKS DS    XL3                      DIR BLKS
*
         DS    0H
TXT09    DS    0XL06,Y,AL2,AL2         VOLUME
TVOLSER  DS    CL6                      VOLSER
*
         DS    0H
TXT10    DS    0XL14,Y,AL2,AL2         UNIT                        v200
TUNIT    DS    CL8                      UNITNAME                   v200
*
         DS    0H
TXT11    DS    0XL06,Y,AL2,AL2         EXPDT
TEXPDT   DS    CL5                      EXPDT=yyddd
*
         DS    0H
TXT12    DS    0XL06,Y,AL2,AL2         BLKSIZE
TBLKSIZE DS    XL2                      BLKSIZE
*
         DS    0H
TXT13    DS    0XL06,Y,AL2,AL2         DSORG
TDSORG   DS    XL2                      DSORG
*
         DS    0H
TXT14    DS    0XL06,Y,AL2,AL2         LRECL
TLRECL   DS    XL2                      LRECL
*
         DS    0H
TXT15    DS    0XL06,Y,AL2,AL2         RECFM
TRECFM   DS    XL1                      RECFM
*
         DS    0H
TXT16    DS    0XL04,Y,AL2             DUMMY
*
         DS    0H
TXT17    DS    0XL04,Y,AL2             SYSOUT
*
         DS    0H
TXT18    DS    0XL04,Y,AL2             TERM
*
         DS    0H
TXT19    DS    0XL04,Y,AL2             CYLINDER
*
         DS    0H
TXT20    DS    0XL04,Y,AL2             FREE=CLOSE
*
         DS    0H
TXT21    DS    0XL06,Y,AL2,AL2         MEMBER
TMEMBER  DS    CL8
*---
*
CTL      DS    X                      Segment descriptor byte
*
*
         DS    0F
TAGDATA  DS    XL108                  TAG data area
TYPPRT   EQU   X'40'                   PRT dev
TYPPUN   EQU   X'80'                   PUN dev
*
NCB1     DS    XL48                   NCB for Spool Access
SYSINDS  DS    0X                     SYSIN DCB for IEBCOPY ctl cards
INDS     DS    (DMYINDSL)X            Input dataset DCB
OUTDS    DS    (DMYOUTDL)X            OUTDATASET DCB
CAMLST   DS    (DMYLSTL)X             Space to hold a CAMLST
*
CPYPLIST DS    XL(COPYPRML)            IEBCOPY PARM FIELD
*
         DS    0H
DDLISTL  DS    AL2(DDLISTSZ)           DDNAME LIST LENGTH
DDLIST   DS    4XL8'00'                    FOUR DDNAMES UNDEFINED
DDSYSIN  DS    CL8    DDNAME representing IEBCOPY's SYSIN
DDSYSPR  DS    CL8    DDNAME representing IEBCOPY's SYSPRINT
         DS    XL8'00'                     UNDEFINED DD
DDSYSUT1 DS    CL8    DDNAME of the dataset to be transmitted (SYSUT1)
DDSYSUT2 DS    CL8    DDNAME representing IEBCOPY's SYSUT2
         DS    XL8'00'                    SYSUT3 unused
DDSYSUT4 DS    CL8    DDNAME representing IEBCOPY's SYSUT4
DDLISTSZ EQU   *-DDLIST                LENGTH OF DDLIST for IEBCOPY
DDOUTDS  DS    XL8'00'                 OUTDATASET DDNAME
DDNETSPL DS    XL8'00'                 NETSPOOL DDNAME
UNLISTSZ EQU   *-DDLIST                TOTAL of all DDs in list
*
*-- ESTAE exit used areas
*
FSAVE    DS    2D
FWORK    DS    D
DHDR     DS    CL30
ABCODE   DS    CL7
MVSSAVE  DS    18F                 ESTAE exit OS save
*-- End of ESTAE area
*
*
NJESA    DS    18F                    NJERCV OS save area               NJE00300
DYNSA    DS    18F                    NJEDYN OS save area               NJE00300
NETSA    DS    18F                    NJENET OS save area               NJE00300
PARSA    DS    18F                    NJEPAR OS save area               NJE00300
*
         DS    0D                     Force doubleword size
NJEWKSZ  EQU   *-NJEWK
*                                                                       NJE00930
*
*-- System DSECTs
*
         CVT   DSECT=YES,PREFIX=NO
         IEFZB4D0
         IEFZB4D2
         DCBD  DSORG=PS,DEVD=DA
*
IEFUCBOB DSECT
         IEFUCBOB LIST=YES
         IHAPSA
         IEESMCA
         IKJTCB
         IHASDWA
IEFTIOT  DSECT
         IEFTIOT1
         IHAASCB
         IHAASXB
         IKJUPT
         IKJCPPL
         IKJPGPB
         IKJIOPL
DSCBF1   DSECT
         IECSDSL1 (1)
*
VOLLIST  DSECT                         Volume list returned by LOCATE
VOLCOUNT DS    H                       Volume count
VOLDEV   DS    CL4                     UCB dev type
VOLSER   DS    CL6                     Volser
VOLSTAT  DS    H                       Status bytes
*
ACEE     DSECT                         Maps a portion of ACEE in MVS3.8
ACEEEYE  DS    CL4'ACEE'
         DS    16X
ACEEUSRL DS    X                       Length of userid
ACEEUSR  DS    CL8                     Userid
*
         COPY  NETSPOOL                                                 NJE00940
         COPY  TAG
*
*-- NJE38 DSECTs
*
         NJEWRE                                                    v220
*
         END   NJETRN                                                   NJE01000
