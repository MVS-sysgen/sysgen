//VTOC     JOB (SYS),'INSTALL VTOC',CLASS=A,MSGCLASS=A
//*
//* SOURCE: CBT (V129) FILE #112
//* TARGET: SYS2.CMDLIB   SYS2.HELP
//*
//*********************************************************************
//* This job installs the VTOC TSO command and help.                  *
//*********************************************************************
//*
//INSTALL PROC SOUT='*',               <=== SYSOUT CLASS
//             LIB='SYS2.CMDLIB',      <=== TARGET LOAD LIBRARY
//             HELP='SYS2.HELP',       <=== HELP LIBRARY
//             SYSTS=SYSDA,            <=== UNITNAME FOR WORK DATASETS
//             ASMBLR=IFOX00,          <=== NAME OF YOUR ASSEMBLER
//             ALIB='SYSC.LINKLIB',    <=== LOCATION OF YOUR ASSEMBLER
//             MACLIB='SYS1.MACLIB',   <=== MACLIB DATASET NAME
//             AMODGEN='SYS1.AMODGEN'  <=== AMODGEN DATASET NAME
//*
//LOADMACS EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=&SOUT
//SYSUT2   DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(,PASS),
//             SPACE=(TRK,(120,,5),RLSE),DCB=(SYS1.MACLIB)
//*
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=&SOUT
//SYSUT1   DD  DSN=&HELP,DISP=SHR
//SYSUT2   DD  DSN=&HELP,DISP=SHR
//*
//ASM1    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(,PASS,DELETE),
//             SPACE=(TRK,(30,15))
//*
//ASM2    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//ASM3    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//ASM4    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//ASM5    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//ASM6    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//ASM7    EXEC PGM=&ASMBLR,REGION=2048K,PARM=(NOLOAD,DECK,'LINECNT=55')
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//         DD  DSN=&&LCLMAC,UNIT=&SYSTS,DISP=(OLD,PASS)
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(30,15))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(MOD,PASS)
//*
//LKED    EXEC PGM=IEWL,COND=(0,NE),
//             PARM='XREF,LET,LIST,SIZE=(600K,64K)'
//SYSPRINT DD  SYSOUT=&SOUT
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,10)
//SYSLMOD  DD  DSN=&LIB,DISP=SHR
//SYSLIN   DD  DSN=&&SYSLIN,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//        PEND
//*
//        EXEC INSTALL
//*
//LOADMACS.SYSIN DD *
./       ADD   NAME=ALLOC
         MACRO
&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X
               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X
               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X
               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X
               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X
               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X
               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=
.**********************************************************************
.*                                                                    *
.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *
.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *
.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *
.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *
.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *
.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *
.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *
.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *
.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *
.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *
.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *
.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *
.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *
.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *
.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *
.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *
.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *
.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *
.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *
.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *
.*    THAT QUANTITY. (SEE DYNSPACE)                                   *
.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *
.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *
.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *
.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *
.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *
.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *
.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *
.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *
.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *
.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *
.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *
.*                                                                    *
.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *
.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *
.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *
.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *
.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *
.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *
.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *
.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *
.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *
.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *
.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *
.*    CONTAIN THE LENGTH.                                            *
.*    EG          ALLOC DSN=LOCATOR                                  *
.*       LOCATOR  DC    A(DSN),Y(12)                                 *
.*       DSN      DC    C'SYS1.LINKLIB'                              *
.*                                                                   *
.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *
.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *
.*       A VALUE IN A REGISTER, COPIES=(R3),                         *
.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *
.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *
.*       FULLWORD FIELD.                                             *
.*                                                                   *
.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *
.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *
.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *
.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *
.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *
.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *
.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *
.*       SUPERVISOR AND TSO).                                        *
.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *
.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *
.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *
.*       ARE TO RECEIVE THE DDNAME.                                  *
.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *
.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *
.*                                                                   *
.**********************************************************************
         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO
         GBLA  &DTUO              OFFSET TO TEXT UNITS
         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS
         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS
         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL
         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC
         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS
         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS
         LCLA  &I                 COUNTER
         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E
         LCLC  &C,&T,&PAR
.*
.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,
&RCPS99(1)     SETB           1
&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER
&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX
&NAME    DS    0H
         AIF   ('&PREFIX' EQ '').TMF
         AIF   (K'&PREFIX LT 4).POK
         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'
&DYNP    SETC  '&PREFIX'(1,4)
         AGO   .TMF
.POK     ANOP
&DYNP    SETC  '&PREFIX'
.TMF     AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF' NE 'AUTO').TMFE
NAME     DYNSPACE             GET NAME FOR SPACE
         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST
         USING &DYNP.DS,R1             USE GENERATED DSECT
&T       SETC  'A'
&PAR     SETC  '&DYNSP+4'
&DSECT   SETB  1
         AGO   .START
.TMFE    AIF   ('&MF(2)' NE '').E2OK
         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'
         AGO   .GEN
.E2OK    ANOP
&DSECT   SETB  1
         AIF   ('&MF(2)' EQ '(').RMFE
         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START
         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS
         AGO   .START
.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP
.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB
         USING S99RB,R15
         ST    R15,0(R1)               AND STORE IN RB POINTER
         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST
         MVI   S99RBLN,20              MOVE IN LIST LENGTH
         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE
         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS
         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB
         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS
         USING S99TUNIT,R15
&DTUO    SETA  0
&DTUPO   SETA  0
         AIF   ('&SSREQ' EQ 'YES').SSREQ
.TDSN    AIF   ('&DSN&DA' NE '').DSN
         AIF   ('&DSNPDE' NE '').DSNPDE
         AIF   ('&DSNRET' NE '').DSNRT
         AIF   ('&SYSOUT' NE '').SYSOUT
         AIF   ('&DUMMY' NE '').DUMMY
         AIF   ('&QNAME' NE '').QNAME
.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN
         AIF   ('&DDNRET&DDNTO' NE '').DDNRT
.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT
.TVOLRET AIF   ('&VOLRET' NE '').VOLRET
.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT
.TLABEL  AIF   ('&LABEL' NE '').LABEL
.TPSWD   AIF   ('&PASWORD' NE '').PASWORD
.TFORUSE AIF   ('&FORUSER' NE '').FORUSER
.TTU     AIF   ('&TU' NE '').TU
.TDISP   AIF   ('&DISP' NE '').DISP
.TSPACE  AIF   ('&SPACE' NE '').SPACE
.TLRECL  AIF   ('&LRECL' NE '').DCB
         AIF   ('&DEN' NE '').DCB
         AIF   ('&RECFM' NE '').DCB
         AIF   ('&BLKSIZE' NE '').DCB
         AIF   ('&DSORG' NE '').DCB
         AIF   ('&KEYLEN' NE '').DCB
.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN
.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN
.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343
.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM
         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM
.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL
         AGO   .SVC99
.SSREQ   RCPSSREQ
         AGO   .TDSN
.DSN     RCPDSN &DSN&DA,&MEMBER
         AGO   .TDDN
.DSNPDE  RCPDSNPD &DSNPDE
         AGO   .TDDN
.DSNRT   RCPDSNRT &DSNRET
&DSNRTO  SETA  &DTUO-46
         AGO   .TDDN
.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X
               FORMS=&FORMS
         AGO   .TDDN
.DUMMY   RCPDUMMY &DUMMY
         AGO   .TDDN
.QNAME   RCPQNAME &QNAME
         AGO   .TDDN
.DDN     RCPDDN &DDN&F&FILE
         AGO   .TUNIT
.DDNRT   RCPDDNRT &DDNRET
&DDNRTO  SETA  &DTUO-10
         AGO   .TUNIT
.UNIT   RCPUNIT &UNIT,&VOL
         AGO   .TVOLRET
.VOLRET  RCPVOLRT &VOLRET
&VOLRTO  SETA  &DTUO-8
         AGO   .TDSRGO
.DSORGRT RCPDSRGR
&DSRGRTO SETA  &DTUO-2
         AGO   .TLABEL
.LABEL   RCPLABEL &LABEL
         AGO   .TPSWD
.PASWORD RCPPSWD &PASWORD
         AGO   .TFORUSE
.FORUSER RCPFORUS &FORUSER
         AGO   .TTU
.TU      RCPTU &TU
         AGO   .TDISP
.DISP    RCPDISP &DISP
         AGO   .TSPACE
.SPACE   RCPSPACE &SPACE
         AGO   .TLRECL
.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X
               DSORG=&DSORG,KEYLEN=&KEYLEN
         AGO .TDCBDSN
.DCBDSN  RCPDCBDS &DCBDSN
         AGO .TDCBDDN
.DCBDDN  RCPDCBDD &DCBDDN
         AGO .TFREE                                              TE7343
.FREE    RCPFREE  &FREE                                          TE7343
         AGO   .TPERM
.PERM    RCPPERM
         AGO   .TSPECI
.SPECIAL RCPSPEC &SPECIAL
.SVC99   ANOP
&DTUPO   SETA  &DTUPO-4
         SPACE
         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS
         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR
         RCPSR2 UNSAVE
&DTUPO   SETA  &DTUPO+4
         AIF   (NOT &DSECT).DYNA
         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY
         LA    R14,4(R1)               POINT TO REQUEST BLOCK
.DYNA    DYNALLOC
         AIF   (NOT &DSECT).LTR
         USING &DYNP.RB,R14            SET UP ADDRESSABILITY
**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **
.LTR     AIF   ('&ERROR' EQ '').TDDTO
         LTR   R15,R15                 TEST RETURN CODE
         BNZ   &ERROR                  BRANCH IF NON ZERO
.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE
&I       SETA  0
.DDNTOL  ANOP
&I       SETA  &I+1
         AIF   ('&DDNTO(&I)' EQ '').RESERVE
         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR
         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.DDNTOR  ANOP
&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)
         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.RESERVE AIF   (&DSECT).RESDS
         SPACE 1
***********************************************************************
**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **
***********************************************************************
         RCPDS
.SSP     ANOP
&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER
&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK
&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS
         AIF   (&DTUO EQ 0).DTU21
&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS
         AIF   (&DSNRTO EQ 0).TDDNRTO
&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN
.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11
&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME
.DTU11   AIF   (&VOLRTO EQ 0).DTU12
&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER
.DTU12   AIF   (&DSRGRTO EQ 0).DTU10
&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG
         AGO   .DTU10
.DTU21   ANOP
&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS
.DTU10   ANOP
&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED
         AIF   (&DSECT).DSP
         RCPDS
         SPACE 3
         AGO   .EXIT
.RESDS   ANOP
         AIF   ('&DYNSP' EQ '').SP3
         DYNSPACE ADD
.SP3     SPACE
&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA
         AGO   .SSP
.DSP     AIF   ('&MF(3)' EQ '').END1
&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA
.END1    ANOP
&SYSECT  CSECT
         SPACE 3
.EXIT    MEND
./       ADD   NAME=CLEAR
         MACRO
&NAME    CLEAR &FIELD,&CHAR,&LENGTH
         LCLC  &FILL,&L
&L       SETC  'L'''
&FILL    SETC  '&CHAR'
         AIF   ('&CHAR' NE '').CHSPEC
&FILL    SETC  '40'
.CHSPEC  ANOP
&NAME    MVI   &FIELD,X'&FILL'   SET THE FIRST POSITION
         AIF   ('&LENGTH' EQ '').NOLSPEC
         MVC   &FIELD+1(&LENGTH),&FIELD  FILL THE ENTIRE FIELD
         MEXIT
.NOLSPEC ANOP
         MVC   &FIELD+1(&L&FIELD-1),&FIELD  FILL THE ENTIRE FIELD
         MEND
./       ADD   NAME=CONV
         MACRO
&LABEL   CONV  &TO,&FROM,&LEN,&EDMASK,&SCOMP
         LCLC  &L,&FIRSTFR,&EDM,&COMP
         LCLA  &COUNT
&L       SETC  'L'''
         AIF   ('&LABEL' EQ '').NOLABEL  SKIP LABEL IF NOT PRESENT
&LABEL   DS    0H             SET THE LABEL
.NOLABEL ANOP
&EDM     SETC  'EDMASK'      DEFAULT EDIT MASK
         AIF   ('&EDMASK' EQ '').DEFMASK  IF NOT ENTERED USE DEFAULT
&EDM     SETC  '&EDMASK'     USE THE ENTERED VALUE
.DEFMASK ANOP
&COMP    SETC  'BLANKS'      DEFAULT COMPARISON CHARS
         AIF   ('&SCOMP' EQ '').DEFCOMP  NOT ENTERED, USE THE DEFAULT
&COMP    SETC  '&SCOMP'      GET WHAT THE GUY WANTS
.DEFCOMP ANOP
&FIRSTFR SETC  '&FROM'(1,1)   GET FIRST CHAR OF &FROM
         AIF   ('&FIRSTFR' EQ '(').REGISTR
         L     R1,&FROM       GET THE DATA TO CONVERT
         CVD   R1,DOUBLE      CONVERT TO PACKED DECIMAL
         AGO   .INDEC
.REGISTR ANOP
&COUNT   SETA  K'&FROM-2
&FIRSTFR SETC  '&FROM'(2,&COUNT)  STRIP THE PERRONS
         CVD   &FIRSTFR,DOUBLE   CONVERT TO PACKED DECIMAL
.INDEC   ANOP
         MVC   CHARS,&EDM     PUT IN THE EDIT MASK
         ED    CHARS,DOUBLE   CONVERT TO CHARACTERS
         AIF   ('&LEN' NE '').LENSET
         MVC   &TO,CHARS+16-&L&TO  MOVE IN THE NUMBER
         CLC   CHARS(16-&L&TO),&COMP   WAS THERE AN OVERFLOW?
         BE    *+10           NO, EVERYTHING WAS OK
         MVC   &TO,STARS      BAD NEWS, NOTE IT
         MEXIT
.LENSET  ANOP
         MVC   &TO.(&LEN),CHARS+16-&LEN MOVE IN THE NUMBER
         CLC   CHARS(16-&LEN),&COMP   WAS THERE AN OVERFLOW?
         BE    *+10           NO, EVERYTHING WAS OK
         MVC   &TO.(&LEN),STARS   BAD NEWS, NOTE IT
         MEND
./       ADD   NAME=DYNSPACE
         MACRO
&NAME    DYNSPACE &TYPE
.*
.*    THIS IS AN INNER MACRO TO ALLOC/FREE.
.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST
.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY
.*                         EACH, REMEMBERING THE LARGEST.
.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.
.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,
.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,
.*    OR BY BEGINWKA, IF THE LATTER IS USED.
.*
.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE
.*     NAME DYNSPACE
.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE
.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL
.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.
.*
.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL
.*          DYNSPACE ADD
.*     (NO NAME FIELD AND ONE OPERAND)
.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE
.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE
.*     CURRENT REQUEST IS FOR A GREATER AMOUNT
.*
.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO
.*     NAME OR OPERAND FIELD.
.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME
.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.
.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.
.*
         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN
         GBLC  &DYNP,&DYNSP
         LCLA  &I
         AIF   ('&NAME' NE '').NAME
         AIF   ('&TYPE' EQ '').ALLOC
.*   THE ACCUMULATE FUNCTION IS REQUIRED
&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST
         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT
&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM
         MEXIT
.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT
&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME
.EXIT    MEXIT
.ALLOC   AIF   ('&DYNSP' EQ '').EXIT
*
**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA
*
&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE
&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0
&DYNSPQ  SETA 0
         MEND
./       ADD   NAME=ENTER
         MACRO
&SUBR    ENTER &BASES,&SAVE,&CSECT
.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM
.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA
.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,
.*   IF THAT IS DESIRED.
.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE
.*   THE OPERANDS ARE
.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT
.*    WHERE
.*       &SUBR    IS THE NAME OF THE CSECT
.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE
.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL
.*                AND LENGTH FOR THE GETMAIN
.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY
.*                POINT &SUBR
.*
.*    EXAMPLES -
.*               ENTER 13,*
.*
.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA
.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE
.*       REGISTER.
.*
.*       RENTMOD  ENTER (12,11),(,LDSECT)
.*
.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND
.*       11 FOR BASE REGISTERS.  A GETMAIN WILL BE DONE FOR THE
.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.
.*
         GBLC  &LV,&SP
         LCLA  &K,&N
         LCLC  &AREA,&B(16),&SUBNAME,&S
&SUBNAME SETC  '&SUBR'
         AIF   ('&SUBNAME' NE '').SUBSPEC
&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME
.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?
&CSECT   CSECT
&SUBNAME DS    0F
         AGO   .CSSPEC
.NOTENT  ANOP
&SUBNAME CSECT
.CSSPEC  ANOP
         SAVE  (14,12),T,&SUBNAME   SAVE THE REGISTERS
         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET
         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET
         LR    &BASES(1),15  SET FIRST BASE REG
.R15SET  CNOP  0,4
&S       SETC  '&SUBNAME'
         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?
         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT
&AREA    SETC  '&SAVE'
         AIF   ('&SAVE' NE '*').P2
&AREA    SETC  'SAVEAREA'
.P2      AIF   ('&BASES(1)' NE '13').P4
&S       SETC  '*'
         USING &SUBNAME,15
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
         BAL   13,*+76        SKIP AROUND THE SAVEAREA
         DROP  15
         AGO   .P4
.P3      AIF   ('&BASES(1)' NE '13').P4
         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX
               TABLISHED.'
.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5
         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX
               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'
.P5      AIF   ('&BASES' EQ '').P9
&N       SETA  N'&BASES
.P6      ANOP
&K       SETA  &K+1
&B(&K)   SETC  ','.'&BASES(&K)'
         AIF   (N'&SAVE EQ 1).PE
         AIF   ('&BASES(&K)' NE '13').P7
         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX
               NTRANT CODE.'
         AGO   .P7
.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7
         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX
                A SECONDARY BASE REGISTER.'
.P7      AIF   ('&BASES(&K+1)' NE '').P6
         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X
               11)&B(12)&B(13)&B(14)&B(15)&B(16)
&K       SETA  1
         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8
&AREA    DC    18F'0'
.P8      AIF   (&K GE &N).P10
         LA    &BASES(&K+1),X'FFF'(&BASES(&K))
         LA    &BASES(&K+1),1(&BASES(&K+1))
&K       SETA  &K+1
         AGO   .P8
.P9      USING &SUBNAME,15
.P10     AIF   (N'&SAVE GE 2).P13
         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12
         AIF   ('&SAVE' GE '0').P16  NUMERIC MEANS A PASSED AREA
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA
&AREA    DC    18F'0'
.P12     MEXIT
.P13     ANOP
&LV      SETC  '&SAVE(2)'
&SP      SETC  '0'
         AIF   ('&SAVE(1)' EQ '').P14
&SP      SETC  '&SAVE(1)'
.P14     CNOP  0,4          DO A GETMAIN FOR THE AREA
         BAL   1,*+8          POINT THE SP AND LV
ENT&SYSNDX DC  AL1(&SP)       SUBPOOL FOR THE GETMAIN
         DC    AL3(&LV)       LENGTH OF THE GETMAIN
         L     0,0(1)         GET THE DATA IN REG 1
         SVC   10             ISSUE THE GETMAIN
.*                            CHAIN THE SAVEAREAS
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         LM    0,2,20(2)      RESTORE ORIGINAL REGS
         MEXIT
.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         LM    0,2,20(2)      RESTORE ORIGINAL REGS
         MEND
./       ADD   NAME=ENTERX
         MACRO
&SUBR    ENTERX &BASES,&SAVE,&CSECT
.*   THIS MACRO, USED WITH THE LEAVE MACRO, WILL PERFORM
.*   STANDARD HOUSEKEEPING FOR A CSECT, INCLUDING SAVEAREA
.*   CONSTRUCTION AND CHAINING, AND GETTING SOME STORAGE,
.*   IF THAT IS DESIRED.
.*   THE LEAVE MACRO WILL FREE THE GOTTEN STORAGE
.*   THE OPERANDS ARE
.*       &SUBR    ENTER  &BASES,&SAVE,&CSECT
.*    WHERE
.*       &SUBR    IS THE NAME OF THE CSECT
.*       &BASES   ARE THE BASE REGISTERS FOR THE ROUTINE
.*       &SAVE    IS THE LABEL FOR A SAVEAREA, OR A SUBPOOL
.*                AND LENGTH FOR THE GETMAIN
.*       &CSECT   TO CONTINUE AN EXISTING CSECT WITH ENTRY
.*                POINT &SUBR
.*
.*    EXAMPLES -
.*               ENTER 13,*
.*
.*       THIS WILL GENERATE NON-REENTRANT CODE, USING SAVEAREA
.*       AS THE SAVE AREA LABEL, AND REGISTER 13 FOR THE BASE
.*       REGISTER.
.*
.*       RENTMOD  ENTER (12,11),(,LDSECT)
.*
.*       THIS WILL GENERATE REENTRANT CODE WITH REGISTERS 12 AND
.*       11 FOR BASE REGISTERS.  A GETMAIN WILL BE DONE FOR THE
.*       DEFAULT SUBPOOL (0) WITH A LENGTH 'LDSECT'.
.*
         GBLC  &LV,&SP
         LCLA  &K,&N
         LCLC  &AREA,&B(16),&SUBNAME,&S
&SUBNAME SETC  '&SUBR'
         AIF   ('&SUBNAME' NE '').SUBSPEC
&SUBNAME SETC  'MAIN'         DEFAULT CSECT NAME
.SUBSPEC AIF   ('&CSECT' EQ '').NOTENT  IS IT AN ENTRY POINT?
&CSECT   CSECT
&SUBNAME DS    0F
         AGO   .CSSPEC
.NOTENT  ANOP
&SUBNAME CSECT
.CSSPEC  ANOP
         SAVE  (14,12),T,&SUBNAME   SAVE THE REGISTERS
         AIF   ('&BASES(1)' EQ '15' OR '&BASES' EQ '').R15SET
         AIF   ('&BASES(1)' EQ '13' AND '&SAVE' NE '').R15SET
         LR    &BASES(1),15  SET FIRST BASE REG
.R15SET  CNOP  0,4
&S       SETC  '&SUBNAME'
         AIF   (N'&SAVE EQ 2).P4   SUBPOOL, SIZE SPEC?
         AIF   ('&SAVE' EQ '').P3  NO SAVEAREA - DEFAULT
&AREA    SETC  '&SAVE'
         AIF   ('&SAVE' NE '*').P2
&AREA    SETC  'SAVEAREA'
.P2      AIF   ('&BASES(1)' NE '13').P4
&S       SETC  '*'
         USING &SUBNAME,15
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
         BAL   13,*+76        SKIP AROUND THE SAVEAREA
         DROP  15
         AGO   .P4
.P3      AIF   ('&BASES(1)' NE '13').P4
         MNOTE 8,'*** CONTENTS OF REG 13 ARE LOST.  NO SAVE AREA WAS ESX
               TABLISHED.'
.P4      AIF   ('&BASES(1)' NE '14' OR '&SAVE' EQ '').P5
         MNOTE 8,'*** MACRO RESTRICTION - REG 14 MUST NOT BE USED AS THX
               E FIRST BASE REGISTER IF A SAVE AREA IS USED.'
.P5      AIF   ('&BASES' EQ '').P9
&N       SETA  N'&BASES
.P6      ANOP
&K       SETA  &K+1
&B(&K)   SETC  ','.'&BASES(&K)'
         AIF   (N'&SAVE EQ 1).PE
         AIF   ('&BASES(&K)' NE '13').P7
         MNOTE 8,'*** REG 13 MAY NOT BE USED AS A BASE REGISTER FOR REEX
               NTRANT CODE.'
         AGO   .P7
.PE      AIF   ('&BASES(&K+1)' NE '13' OR '&SAVE' EQ '').P7
         MNOTE 8,'*** WHEN USING A SAVE AREA, REG 13 MAY NOT BE USED ASX
                A SECONDARY BASE REGISTER.'
.P7      AIF   ('&BASES(&K+1)' NE '').P6
         USING &S&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)&B(9)&B(10)&B(X
               11)&B(12)&B(13)&B(14)&B(15)&B(16)
&K       SETA  1
         AIF   ('&BASES(1)' NE '13' OR '&SAVE' EQ '').P8
&AREA    DC    18F'0'
.P8      AIF   (&K GE &N).P10
         LA    &BASES(&K+1),X'FFF'(&BASES(&K))
         LA    &BASES(&K+1),1(&BASES(&K+1))
&K       SETA  &K+1
         AGO   .P8
.P9      USING &SUBNAME,15
.P10     AIF   (N'&SAVE GE 2).P13
         AIF   ('&SAVE' EQ '' OR '&BASES(1)' EQ '13').P12
         AIF   ('&SAVE(1,1)' GE '0').P16  NUMERIC MEANS A PASSED AREA
         ST    14,&AREA+4
         LA    14,&AREA
         ST    14,8(13)
         L     14,&AREA+4
         ST    13,&AREA+4
.P11     BAL   13,*+76       SKIP AROUND THE SAVEAREA
&AREA    DC    18F'0'
.P12     MEXIT
.P13     ANOP
&LV      SETC  '&SAVE(2)'
&SP      SETC  '0'
         AIF   ('&SAVE(1)' EQ '').P14
&SP      SETC  '&SAVE(1)'
.P14     CNOP  0,4          DO A GETMAIN FOR THE AREA
         BAL   1,*+8          POINT THE SP AND LV
ENT&SYSNDX DC  AL1(&SP)       SUBPOOL FOR THE GETMAIN
         DC    AL3(&LV)       LENGTH OF THE GETMAIN
         L     0,0(1)         GET THE DATA IN REG 1
         SVC   10             ISSUE THE GETMAIN
.*                            CHAIN THE SAVEAREAS
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         LA    4,12(13)       YES, POINT PAST THE CHAIN
         L     5,ENT&SYSNDX   GET THE SIZE
         LA    6,12           MINUS THE CHAIN AREA (12 BYTES )
         SR    5,6            GIVES THE AMOUNT TO CLEAR
         SR    7,7            CLEAR THE FROM COUNT AND CLEAR BYTE
         MVCL  4,6            WHEE, CLEAR IT OUT
         LM    0,7,20(2)      RESTORE THE ORIGINAL REGISTERS
         MEXIT
.P16     L     1,&AREA+0(1)   NUMERIC &SAVE IMPLIES A PASSED SAVEAREA
         ST    13,4(1)        PRIOR SAVEAREA ADDRESS TO MINE
         ST    1,8(13)        MY SAVEAREA ADDRESS TO HIS
         LR    2,13           KEEP THE SAVEAREA ADDRESS FOR REGS
         LR    13,1           THIS IS MY SAVEAREA
         LM    0,2,20(2)      RESTORE ORIGINAL REGS
         MEND
./       ADD   NAME=FREE
         MACRO
&NAME    FREE  &UNALC,&DSN=,&DDN=,&MEMBER=,&DISP=,&SYSOUT=,            X
               &ERROR=,&MF=AUTO,&PREFIX=,&FILE=,&F=,&DA=,&HOLD=
         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO
         GBLA  &DTUO              OFFSET TO TEXT UNITS
         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS
         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS
         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL
         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC
         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E
         LCLC  &C,&T,&PAR
&RCPS99(1)     SETB           1
&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER
&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX
&NAME    DS    0H
         AIF   ('&PREFIX' EQ '').TMF
         AIF   (K'&PREFIX LT 4).POK
         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'
&DYNP    SETC  '&PREFIX'(1,4)
         AGO   .TMF
.POK     ANOP
&DYNP    SETC  '&PREFIX'
.TMF     AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF' NE 'AUTO').TMFE
NAME     DYNSPACE             GET NAME FOR SPACE
         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST
         USING &DYNP.DS,R1             USE GENERATED DSECT
&T       SETC  'A'
&PAR     SETC  '&DYNSP+4'
&DSECT   SETB  1
         AGO   .START
.TMFE    AIF   ('&MF(2)' NE '').E2OK
         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'
         AGO   .GEN
.E2OK    ANOP
&DSECT   SETB  1
         AIF   ('&MF(2)' EQ '(').RMFE
         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS
&T       SETC  'A'
&PAR     SETC  '&MF(2)+4'
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START
&PAR     SETC  '&MF(2)'(2,K'&MF(2)-2)
&T       SETC  'R'
         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS
&PAR     SETC  '4&MF(2)'
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP
&T       SETC  'A'
&PAR     SETC  '&DYNP.RB'
.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB
         USING S99RB,R15
         ST    R15,0(R1)               AND STORE IN RB POINTER
         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST
         MVI   S99RBLN,20              MOVE IN LIST LENGTH
         MVI   S99VERB,S99VRBUN        MOVE IN VERB CODE
         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS
         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB
         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS
         USING S99TUNIT,R15
&DTUO    SETA  0
&DTUPO   SETA  0
         AIF   ('&DSN&DA' NE '').DSN
         AIF   ('&SYSOUT' NE '').SYSOUT
.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN
.TDISP   AIF   ('&DISP' NE '').DISP
.TUNALC  AIF   ('&UNALC' NE '').PERM
.THOLD   AIF   ('&HOLD' NE '').HOLD
         AGO   .SVC99
.DSN     RCPFDSN &DSN&DA,&MEMBER
         AGO   .TDDN
.SYSOUT  RCPFSYS &SYSOUT
         AGO   .TDDN
.DDN     RCPFDDN &DDN&F&FILE
         AGO   .TDISP
.DISP RCPFDISP &DISP
         AGO   .TUNALC
.PERM    RCPUNALC
         AGO   .THOLD
.HOLD    RCPFHOLD &HOLD
.SVC99   ANOP
&DTUPO   SETA  &DTUPO-4
         SPACE
         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS
         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR
         RCPSR2 UNSAVE
&DTUPO   SETA  &DTUPO+4
         AIF   (NOT &DSECT).DYNA
         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY
.DYNA    DYNALLOC
         AIF   ('&ERROR' EQ '').RESERVE
         AIF   ('&PAR' EQ '').LTR
         L&T   R14,&PAR                 LOAD REG 14 WITH ADDRESS OF RB
         AIF   (NOT &DSECT).LTR
         USING &DYNP.RB,R14            SET UP ADDRESSABILITY
.LTR     LTR   R15,R15                 TEST RETURN CODE
         BNZ   &ERROR                  BRANCH IF NON ZERO
**       NOTE.  R14 POINTS TO REQUEST BLOCK, R15 HAS RETURN CODE     **
.RESERVE AIF   (&DSECT).RESDS
         SPACE
***********************************************************************
**       RESERVE SPACE FOR DYNALLOC DATA                             **
***********************************************************************
         RCPDS
.SSP     ANOP
&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER
&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK
&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS
         AIF   (&DTUO EQ 0).DTU11
&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS
         AGO   .DTU10
.DTU11   ANOP
&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS
.DTU10   ANOP
&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED
         AIF   (&DSECT).DSP
         RCPDS
         SPACE 3
         AGO   .EXIT
.RESDS   ANOP
         AIF   ('&DYNSP' EQ '').SP3
         DYNSPACE ADD
.SP3     SPACE
&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA
         AGO   .SSP
.DSP     AIF   ('&MF(3)' EQ '').END1
&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA
.END1    ANOP
&SYSECT  CSECT
         SPACE 3
.EXIT    MEND
./       ADD   NAME=LEAVE
         MACRO
&NAME    LEAVE &EQ,&RC=
         GBLC  &LV,&SP
&NAME    LR    2,13
         L     13,4(13)
         AIF   ('&RC' EQ '').L0
         LA    15,&RC         LOAD THE RETURN CODE
.L0      STM   15,1,16(13)  STORE RETURN REGS
         AIF   ('&LV' EQ '').L1  ANYTHING TO FREE?
         FREEMAIN R,LV=&LV,SP=&SP,A=(2)  FREE THE AREA
.L1      RETURN (14,12),T     RETURN FROM WHENCE WE CAME
         AIF   ('&EQ' NE 'EQ').L4  REGISTERS TOO?
         COPY  REGS
.L4      MEND
./       ADD   NAME=MSG
         MACRO
&NAME    MSG   &TEXT
         LCLA  &A
&A       SETA  K'&TEXT-2+4  SUBTRACT QUOTES, ADD PREFIX FOUR BYTES
&NAME    DC    H'&A',H'0',C&TEXT
         MEND
./       ADD   NAME=PDEDSNAM
         MACRO
         PDEDSNAM
*
*        DEFINE A DSECT FOR THE DSNAME PARSE DESCRIPTION
*
PDEDSNAM DSECT
PDEDSN   DS    A              POINTER TO DSNAME
PDEDSNL  DS    H              LENGTH OF DSNAME
PDEDFLG1 DS    X              DATA SET NAME FLAGS
PDEDFLD1 EQU   X'80'          ONE IF THE DSNAME IS PRESENT
PDEDFLQ1 EQU   X'40'          ONE IF THE DSNAME IS WITHIN QUOTES
PDEDMEM  DS    A              POINTER TO MEMBER NAME
PDEDMEML DS    H              LENGTH OF MEMBER NAME
PDEDFLG2 DS    X              MEMBER   NAME FLAGS
PDEDFLD2 EQU   X'80'          ONE IF THE MEMBER IS PRESENT
PDEDPASS DS    A              POINTER TO PASSWORD
PDEDPASL DS    H              LENGTH OF PASSWORD
PDEDFLG3 DS    X              PASSWORD      FLAGS
PDEDFLD3 EQU   X'80'          ONE IF THE PASSWORD IS PRESENT
PDEDCHAN DS    0F             CHAIN ADDRESS
PDEDCHNF DS    X              CHAIN FLAGS ( X'FF' FOR END )
PDEDCHN  DS    AL3            TRUE CHAIN POINTER
         MEND
./       ADD   NAME=RCPBFRGS
         MACRO
         RCPBFRGS &BUFPTR,&WKREGS
         GBLC  &RCPBFRP,&RCPBFR1,&RCPBFR2
         AIF   ('&BUFPTR' EQ '').TGP
&RCPBFRP SETC  '&BUFPTR'
         AGO   .TWK1
.TGP     AIF   ('&RCPBFRP' NE '').TWK1
&RCPBFRP SETC  'R1'
.TWK1    AIF   ('&WKREGS(1)' EQ '').TG1
&RCPBFR1 SETC  '&WKREGS(1)'
         AGO   .TWK2
.TG1     AIF   ('&RCPBFR1' NE '').TWK2
&RCPBFR1 SETC  'R14'
.TWK2    AIF   ('&WKREGS(2)' EQ '').TG2
&RCPBFR2 SETC  '&WKREGS(2)'
         MEXIT
.TG2     AIF   ('&RCPBFR2' NE '').EXIT
&RCPBFR2 SETC  'R15'
.EXIT    MEND
./       ADD   NAME=RCPBTU
         MACRO
         RCPBTU &KEY,&NUM,&PAR
         LCLA  &L
.*
.*  INNER MACRO FOR ALLOC, TO GENERATE TEXT UNITS ENTERED
.*  IN QUOTES
.*
&L       SETA  K'&PAR-2                GET LENGTH OF TEXT UNIT
         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY
         MVI   S99TUNUM+1,&NUM         SET NUMBER FIELD
         MVI   S99TULNG+1,&L           MOVE IN LENGTH
         MVC   S99TUPAR(&L.),=C&PAR    MOVE IN TEXT UNIT
&L       SETA  &L+6
         AIF   (&L/2 EQ (&L+1)/2).LOK
&L       SETA  &L+1
.LOK     RCPDINC &L
         MEND
./       ADD   NAME=RCPBTU2
         MACRO
         RCPBTU &KEY,&NUM,&PAR
         GBLA  &DTUPO
         GBLC  &DYNP
         LCLA  &L
.*
.*  INNER MACRO FOR ALLOC, TO BRANCH AROUND TEXT UNIT AND
.*  CREATE TEXT UNIT
.*
&L       SETA  K'&PAR+8                GET LENGTH TO BRANCH AROUND
         AIF   (&L/2 EQ (&L+1)/2).LOK  MAKE SURE LENGTH IS EVEN
&L       SETA  &L+1
.LOK     BAL   R14,*+&L                BRANCH AROUND TEXT UNIT
&L       SETA  K'&PAR-2
         DC    Y(&KEY,&NUM,&L),C&PAR   TEXT UNIT
         LA    R14,0(R14)              CLEAR HIGH ORDER BYTE
         ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
&DTUPO   SETA  &DTUPO+4
         MEND
./       ADD   NAME=RCPCKID
         MACRO
&NAME    RCPCKID              &CHECKID
         GBLB  &RCPECT(2),&RCPPSCB(2)
         GBLC  &RCPPRE
         LCLC  &CHARVAR,&P
         LCLA  &COUNTR,&L
&P       SETC  '&RCPPRE'
&RCPPSCB(1) SETB  1
&RCPECT(1)  SETB  1
         EJECT
         SPACE 4
***********************************************************************
***  THE USERID OF THE USER IS CHECKED. IF IT IS NOT VALID, THE    ****
***   COMMAND PRETENDS IT DOES NOT EXIST BY LINKING TO EXEC IN     ****
***   THE SAME WAY THE TMP DOES IF IT CANNOT FIND THE COMMAND.     ****
***********************************************************************
         SPACE 3
         L     R1,CPPLPSCB             LOAD ADDRESS OF PSCB
         USING PSCB,R1                 PSCB ADDRESSABILITY
.NID     ANOP
&COUNTR  SETA  &COUNTR+1
         AIF   ('&CHECKID(&COUNTR)' EQ '').ENDID
&CHARVAR SETC  '&CHECKID(&COUNTR)'
&L       SETA  K'&CHARVAR
         AIF   ('&CHARVAR'(1,1) EQ '''').QCID
         CLC   PSCBUSER(&L),=C'&CHARVAR'  IS THE USERID VALID?
         BE    &P.IDOK                     YES, BRANCH OUT
         AGO   .NID
.QCID    ANOP
&L       SETA  &L-2
         CLC   PSCBUSER(&L),=C&CHARVAR    IS THE USERID VALID?
         BE    &P.IDOK                     YES, BRANCH OUT
         AGO   .NID
.ENDID   L     R1,CPPLECT              LOAD ECT ADDRESS
         SPACE 2
         USING ECT,R1
         MVC   ECTPCMD,&P.EXECN        MOVE IN COMMAND NAME
         DROP  R1                      KILL ECT ADDRESSABILITY
         L     R1,CPPLCBUF             LOAD CBUF ADDRESS
         XC    2(2,R1),2(R1)           ZERO OFFSET FIELD
         L     R1,&P.CPPL              RELOAD CPPL ADDRESS
         XCTL  EPLOC=&P.EXECN
&P.EXECN DC    CL8'EXEC'               NAME OF EXEC PROCESSOR
&P.IDOK  DS    0H
         MEND
./       ADD   NAME=RCPDDN
         MACRO
         RCPDDN &DDN
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE DDNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU
         AIF   ('&DDN'(1,1) EQ '''').Q
         RCPSR2
         AIF   ('&DDN'(1,1) EQ '(').R
         L     R14,&DDN                LOAD ADDRESS OF DDNAME
         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME
         AGO   .STH
.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME
         LH    R2,4&DDN                LOAD LENGTH OF DDNAME
.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DDNAME
         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DALDDNAM,1,&DDN
         MEXIT
.BTU     RCPTUBFR DALDDNAM,14,&DDN
         MEND
./       ADD   NAME=RCPDDNRT
         MACRO
         RCPDDNRT
         SPACE 1
***********************************************************************
**    DDNAME RETURN TEXT UNIT                                        **
***********************************************************************
         MVI   S99TUKEY+1,DALRTDDN     SET RETURN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,8            SET LENGTH FIELD
         MVC   S99TUPAR(8),=CL8' '     INITIALIZE FIELD TO BLANKS
         RCPDINC 14
         MEND
./       ADD   NAME=RCPDEBUG
         MACRO
         RCPDEBUG &ON
         GBLA  &RCPBGN#,&RCPSWS(10)
         GBLB  &RCPDBUG
         GBLC  &RCPPRE,&RCPWKDS,&RCPWKCS
         AIF   ('&ON' EQ '').TSW
&RCPDBUG SETB 1
.TSW     AIF   (&RCPDBUG).DEBUG
         MEXIT
.DEBUG   MNOTE *,'RCPBGN# IS &RCPBGN#'
         MNOTE *,'RCPSWS(1) IS &RCPSWS(1)'
         MNOTE *,'RCPSWS(2) IS &RCPSWS(2)'
         MNOTE *,'RCPSWS(3) IS &RCPSWS(3)'
         MNOTE *,'RCPSWS(4) IS &RCPSWS(4)'
         MNOTE *,'RCPSWS(5) IS &RCPSWS(5)'
         MNOTE *,'RCPWKCS IS ''&RCPWKCS'''
         MNOTE *,'RCPWKDS IS ''&RCPWKDS'''
         MNOTE *,'RCPPRE IS ''&RCPPRE'''
         MEND
./       ADD   NAME=RCPDFPL
         MACRO
         RCPDFPL
         GBLC  &RCPPRE
         GBLB  &RCPDFPL(2)
         GBLB  &RCPDFPB(2)
         LCLC  &P,&L,&L1
&P       SETC  '&RCPPRE'
         EJECT
         AIF   (&RCPDFPL(2)).BYPDFPL
&RCPDFPL(2) SETB 1
         IKJDFPL
L#DFPL   EQU   *-DFPL                  LENGTH OF DEFAULT PARAM LIST
         IKJDFPB
L#DFPB   EQU   *-DFPB                  LENGTH OF DEFAULT PARAM BLOCK
&SYSECT  CSECT                         RESUME PROGRAM CSECT
         SPACE 3
.BYPDFPL RCPDS
&P.DFPL  DS    CL(L#DFPL)              RESERVE SPACE FOR DFPL
&P.DFPB  DS    CL(L#DFPB)              RESERVE SPACE FOR DFPB
&P.DSNB  DS    CL48                    RESERVE SPACE FOR DSNAME BUFFER
         RCPDS
         EJECT
***********************************************************************
***   THIS CODE GENERATES AN DEFAULT SERVICE ROUTINE PARAMETER LIST ***
***       AND PARAMETER BLOCK                                       ***
***********************************************************************
         LA    R1,&P.DFPL              LOAD DFPL ADDRESS
         USING DFPL,R1                 DFPL ADDRESSABLE
         MVC   DFPLUPT,CPPLUPT         MOVE IN ADDRESS OF UPT
         MVC   DFPLECT,CPPLECT         MOVE IN ADDRESS OF ECT
         LA    R15,&P.ECB              LOAD ADDRESS OF ATTN ECB
         ST    R15,DFPLECB             AND STORE IN DFPL
         LA    R15,&P.DFPB             LOAD DFBP ADDRESS
         ST    R15,DFPLDFPB             AND STORE IT IN DFPB
         DROP  R1
         USING DFPB,R15                ADDRESS DFPB DSECT
         XC    DFPB(L#DFPB),DFPB       CLEAR DEFAULT PARAMETER BLOCK
         MVC   DFPBPSCB,CPPLPSCB       MOVE IN ADDRESS OF PSCB
         LA    R1,&P.DSNB              LOAD DSNAME BUFFER ADDRESS
         ST    R1,DFPBDSN               AND STORE IT INTO DFPB
         MVI   DFPBCODE,DFPB04          SET ENTRY CODE
         DROP  R15                     DFPB NO LONGER ADDRESSABLE
         EJECT
         MEND
./       ADD   NAME=RCPDINC
         MACRO
         RCPDINC &L1
         GBLA  &DTUO,&DTUPO
         GBLC  &DYNP
         AIF   ('&L1' EQ '').T2
         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT
&DTUPO   SETA  &DTUPO+4
&DTUO    SETA  &DTUO+&L1
         MEXIT
.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
&DTUPO   SETA  &DTUPO+4
         MEND
./       ADD   NAME=RCPDISP
         MACRO
         RCPDISP &DISP
         LCLA  &I
         LCLB  &B(4)
         AIF   ('&DISP(1)' EQ '').TD2
         SPACE
***********************************************************************
**     DATA SET INITIAL STATUS                                       **
***********************************************************************
&B(1)    SETB  ('&DISP(1)' EQ 'SHR')
&B(2)    SETB  ('&DISP(1)' EQ 'NEW')
&B(3)    SETB  ('&DISP(1)' EQ 'MOD')
&B(4)    SETB  ('&DISP(1)' EQ 'OLD')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1
         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'
&B(1)    SETB  1
.OK1     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')
         RCPDINC 8
.TD2     AIF   ('&DISP(2)' EQ '').TD3
         SPACE
***********************************************************************
**    DATA SET NORMAL DISPOSITION                                    **
***********************************************************************
&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2
         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'
&B(1)    SETB  1
.OK2     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')
         RCPDINC 8
.TD3     AIF   ('&DISP(3)' EQ '').EXIT
         SPACE
***********************************************************************
**   DATASET CONDITIONAL DISPOSITION                                 **
***********************************************************************
&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3
         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'
&B(1)    SETB  1
.OK3     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVI   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')
         RCPDINC 8
.EXIT    MEND
./       ADD   NAME=RCPDS
         MACRO
         RCPDS
         GBLB  &RCPDSBR
         GBLC  &RCPWKDS,&RCPWKCS,&RCPDS
         AIF   ('&RCPDS' NE '').RESUME
&RCPDS   SETC  '&SYSECT'
         AIF   ('&RCPWKDS' EQ '').CSECT
&RCPWKDS DSECT                         ENTER WORKAREA DSECT
         MEXIT
.CSECT   AIF   ('&RCPWKCS' EQ '').BRANCH
&RCPWKCS CSECT                         ENTER WORKAREA CSECT
         MEXIT
.RESUME  AIF   (&RCPDSBR).BRTO
&RCPDS   CSECT                         RESUME PROGRAM CSECT
&RCPDS   SETC  ''
         MEXIT
.BRANCH  ANOP
&RCPDS   SETC  'RCP&SYSNDX'
&RCPDSBR SETB  1
         B     &RCPDS                  BRANCH AROUND CONSTANTS
         MEXIT
.BRTO    ANOP
&RCPDS   DS    0H
&RCPDSBR SETB  0
&RCPDS   SETC  ''
         MEND
./       ADD   NAME=RCPDSECT
         MACRO
&NAME    RCPDSECT &LTORG=YES
         AIF   ('&LTORG' NE 'YES').RCPDS
***********************************************************************
****                  LITERALS                                     ****
***********************************************************************
         SPACE 3
         LTORG
         EJECT
.RCPDS   RCPDS
         MEND
./       ADD   NAME=RCPDSN
         MACRO
         RCPDSN &DSN,&MEM
         LCLC  &MEMBER
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE DSNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DSN'(1,1) EQ '''').Q
         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD
         AIF   ('&DSN'(1,1) EQ '(').REG
         AIF   ('&DSN'  EQ '*').TERM
         RCPSR2
         L     R14,&DSN                LOAD ADDRESS OF DSNAME
         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME
.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DSNAME
         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 50
         AGO   .TMEMBER
.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME
         RCPSR2
         LH    R2,4&DSN                LOAD LENGTH OF DSNAME
         AGO   .STH
.TERM    MVI   S99TUKEY+1,DALTERM
         RCPDINC 4
         MEXIT
.BD      RCPTUBFR DALDSNAM,50,&DSN
         AGO   .TMEMBER
.Q       RCPBTU DALDSNAM,1,&DSN
.TMEMBER AIF   ('&MEM' EQ '').EXIT
         SPACE
***********************************************************************
**   BUILD THE MEMBER NAME TEXT UNIT                                 **
***********************************************************************
&MEMBER  SETC  '&MEM'
         AIF   ('&MEM' NE '*').MOK
         AIF   ('&DSN'(1,1) NE '''').MAST
         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'
         MEXIT
.MAST    ANOP
&MEMBER  SETC  '8+&DSN'
.MOK     ANOP
         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM
         RCPSR2
         AIF   ('&MEMBER'(1,1) EQ '(').RM
         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER
         AGO   .STHM
.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER
.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME
         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.BM      RCPTUBFR DALMEMBR,14,&MEMBER
         MEXIT
.QM      RCPBTU DALMEMBR,1,&MEMBER
.EXIT    MEND
./       ADD   NAME=RCPDSNPD
         MACRO
         RCPDSNPD &PDE
         AIF   ('&PDE'(1,1) EQ '(').RPDE
         RCPDSN &PDE,8+&PDE
         RCPPSWD 16+&PDE
         MEXIT
.RPDE    RCPDSN &PDE,8&PDE
         RCPPSWD 16(&PDE)
         MEND
./       ADD   NAME=RCPDSNRT
         MACRO
         RCPDSNRT
         SPACE
***********************************************************************
**    DSNAME RETURN TEXT UNIT                                        **
***********************************************************************
         MVI   S99TUKEY+1,DALRTDSN     SET RETURN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,44           SET LENGTH FIELD
         RCPDINC 50
         MEND
./       ADD   NAME=RCPDSRGR
         MACRO
         RCPDSRGR
         SPACE
***********************************************************************
**    DSORG RETURN TEXT UNIT                                         **
***********************************************************************
         MVI   S99TUKEY+1,DALRTORG     SET RETURN DSORG KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,2            SET LENGTH FIELD
         XC    S99TUPAR(2),S99TUPAR    INITIALIZE FIELD TO ZERO
         RCPDINC 8
         MEND
./       ADD   NAME=RCPDUMMY
         MACRO
         RCPDUMMY &DUMMY
         SPACE
***********************************************************************
**      DUMMY DATASET TEXT UNIT                                      **
***********************************************************************
         MVI   S99TUPAR+1,DALDUMMY     MOVE IN DUMMY DS TEXT UNIT KEY
         RCPDINC 4
         MEND
./       ADD   NAME=RCPENDD
         MACRO
&NAME    RCPENDD
         GBLB  &RCPECT(2),&RCPUPT(2),&RCPPSCB(2),&RCPS99(2)
         GBLC  &RCPPRE,&RCPWKDS,&RCPDS
         LCLC  &P,&CS
&CS      SETC  '&RCPDS'                PROGRAM CSECT
         AIF   (NOT &RCPS99(1)).TDS
         DYNSPACE
.TDS     AIF   ('&RCPWKDS' EQ '').RCPDS
         DS    0D                      ALIGN TO DOUBLEWORD
&P       SETC  '&RCPPRE'
&P.WKLEN EQU   *-&RCPWKDS              LENGTH OF WORK AREA
.RCPDS   RCPDS
         EJECT
         AIF   (NOT &RCPECT(1) OR &RCPECT(2)).TRYUPT
         IKJECT
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPECT(2)     SETB           1
.TRYUPT  AIF   (NOT &RCPUPT(1) OR &RCPUPT(2)).TRYPSCB
         IKJUPT
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPUPT(2) SETB  1
.TRYPSCB AIF   (NOT &RCPPSCB(1) OR &RCPPSCB(2)).TRYS99
         IKJPSCB
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPPSCB(2) SETB  1
.TRYS99  AIF   (NOT &RCPS99(1) OR &RCPS99(2)).TRYREST
         IEFZB4D0
         EJECT
         IEFZB4D2
&CS      CSECT                         REENTER MAIN CSECT
         EJECT
&RCPS99(2) SETB  1
.TRYREST MEND
./       ADD   NAME=RCPFDDN
         MACRO
         RCPFDDN &DDN
         GBLC &DYNP
         SPACE
***********************************************************************
**        FREE DDNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DDN'(1,1) EQ '''').Q
         AIF   ('&DDN'(K'&DDN,1) EQ '/').B
         RCPSR2
         AIF   ('&DDN'(1,1) EQ '(').R
         L     R14,&DDN                LOAD ADDRESS OF DDNAME
         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME
         AGO   .STH
.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME
         LH    R2,4&DDN                LOAD LENGTH OF DDNAME
.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DDNAME
         MVI   S99TUKEY+1,DUNDDNAM     MOVE IN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DUNDDNAM,1,&DDN
         MEXIT
.B       RCPTUBFR DUNDDNAM,14,&DDN
         MEND
./       ADD   NAME=RCPFDISP
         MACRO
         RCPFDISP &DISP
         LCLB  &B(4)
         LCLA  &I
         SPACE
***********************************************************************
**       OVERRIDING DISPOSITION                                      **
***********************************************************************
&B(1)    SETB  ('&DISP' EQ 'KEEP')
&B(2)    SETB  ('&DISP' EQ 'DELETE')
&B(3)    SETB  ('&DISP' EQ 'CATLG')
&B(4)    SETB  ('&DISP' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3
         MNOTE 8,'&DISP IS INVALID, DISP=KEEP USED'
&B(1)    SETB  1
.OK3     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DUNOVDSP,1,1,X'0&I.00')
         RCPDINC 8
.EXIT    MEND
./       ADD   NAME=RCPFDSN
         MACRO
         RCPFDSN &DSN,&MEM
         LCLC  &MEMBER
         GBLC  &DYNP
         SPACE
***********************************************************************
**      FREE DATA SET TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DSN'(1,1) EQ '''').Q
         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD
         AIF   ('&DSN'(1,1) EQ '(').REG
         RCPSR2
         L     R14,&DSN                LOAD ADDRESS OF DSNAME
         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME
.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DSNAME
         MVI   S99TUKEY+1,DUNDSNAM     MOVE IN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 50
         AGO   .TMEMBER
.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME
         RCPSR2
         LH    R2,4&DSN                LOAD LENGTH OF DSNAME
         AGO   .STH
.BD      RCPTUBFR DUNDSNAM,50,&DSN
         AGO   .TMEMBER
.Q       RCPBTU DUNDSNAM,1,&DSN
.TMEMBER AIF   ('&MEM' EQ '').EXIT
         SPACE
***********************************************************************
**       FREE MEMBER NAME TEXT UNIT                                  **
***********************************************************************
&MEMBER  SETC  '&MEM'
         AIF   ('&MEM' NE '*').MOK
         AIF   ('&DSN'(1,1) NE '''').MAST
         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'
         MEXIT
.MAST    ANOP
&MEMBER  SETC  '8+&DSN'
.MOK     ANOP
         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM
         RCPSR2
         AIF   ('&MEMBER'(1,1) EQ '(').RM
         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER
         AGO   .STHM
.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER
.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME
         MVI   S99TUKEY+1,DUNMEMBR     MOVE IN MEMBER KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.BM      RCPTUBFR DUNMEMBR,14,&MEMBER
         MEXIT
.QM      RCPBTU DUNMEMBR,1,&MEMBER
.EXIT    MEND
./       ADD   NAME=RCPFHOLD
         MACRO
         RCPFHOLD &H
         AIF   ('&H' EQ 'YES').YES
         AIF   ('&H' EQ 'NO').NO
         MNOTE 4,'HOLD PARMETER VALUE INCORRECT - IGNORED'
         MEXIT
.YES     ANOP
         SPACE 1
***********************************************************************
**       OVERIDING SYSOUT HOLD TEXT UNIT                             **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DUNOVSHQ MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEXIT
.NO      ANOP
         SPACE 1
***********************************************************************
**       OVERIDING SYSOUT NO HOLD TEXT UNIT                          **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DUNOVSHQ MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEND
./       ADD   NAME=RCPFORUS
         MACRO - TO SET UP SVC 99 TEXT UNIT 'FOR USER'
         RCPFORUS &T
         SPACE 1
***********************************************************************
**       'FOR USER' TEXT UNIT                                        **
***********************************************************************
         RCPVCHAR 0,5,&T,N=X'7701'
         MEND
./       ADD   NAME=RCPFREE
         MACRO
         RCPFREE &FREE
         SPACE
***********************************************************************
**      UNALLOC AT CLOSE TEXT UNIT                                   **
***********************************************************************
         MVI   S99TUPAR+1,DALCLOSE     MOVE IN CLOSE TEXT UNIT KEY
         RCPDINC 4
         MEND
./       ADD   NAME=RCPIOPL
         MACRO
&NAME    RCPIOPL
         GBLC  &RCPPRE
         GBLB  &RCPIOPL(2)
         GBLB  &RCPSTPB(2),&RCPPTPB(2),&RCPPGPB(2),&RCPGTPB(2)
         LCLC  &P,&L,&L1
&P       SETC  '&RCPPRE'
         EJECT
         AIF   (&RCPIOPL(2)).BYPIOPL
&RCPIOPL(2) SETB 1
         IKJIOPL
L#IOPL   EQU   *-IOPL                  LENGTH OF IO PARAM LIST
&SYSECT  CSECT                         RESUME PROGRAM CSECT
         SPACE 3
.BYPIOPL RCPDS
&P.IOPL  DS    CL(L#IOPL)              RESERVE SPACE FOR IOPL
         RCPDS
         SPACE 5
***********************************************************************
***   THIS CODE GENERATES AN I/O SERVICE ROUTINE PARAMETER LIST     ***
***********************************************************************
         LA    R1,&P.IOPL              LOAD IOPL ADDRESS
         USING IOPL,R1                 IOPL ADDRESSABLE
         MVC   IOPLUPT,CPPLUPT         MOVE IN ADDRESS OF UPT
         MVC   IOPLECT,CPPLECT         MOVE IN ADDRESS OF ECT
         LA    R15,&P.ECB              LOAD ADDRESS OF ATTN ECB
         ST    R15,IOPLECB             AND STORE IN IOPL
         DROP  R1
  AIF (&RCPSTPB(1) OR &RCPGTPB(1) OR &RCPPGPB(1) OR &RCPPTPB(1)).I
         MEXIT
.I       EJECT
         AIF   (NOT &RCPSTPB(1) OR &RCPSTPB(2)).TPT
         IKJSTPB
&RCPSTPB(2) SETB 1
L#STPB   EQU   *-STPB         LENGTH OF STPB
&SYSECT  CSECT
.TPT     AIF   (NOT &RCPPTPB(1) OR &RCPPTPB(2)).TGT
         IKJPTPB
&RCPPTPB(2) SETB 1
L#PTPB   EQU   *-PTPB         LENGTH OF PTPB
&SYSECT  CSECT
.TGT     AIF   (NOT &RCPGTPB(1) OR &RCPGTPB(2)).TPG
         IKJGTPB
&RCPGTPB(2) SETB 1
L#GTPB   EQU   *-GTPB         LENGTH OF GTPB
&SYSECT  CSECT
.TPG     AIF   (NOT &RCPPGPB(1) OR &RCPPGPB(2)).STO
         IKJPGPB
&RCPPGPB(2) SETB 1
L#PGPB   EQU   *-PGPB         LENGTH OF PGPB
&SYSECT  CSECT
.STO     SPACE 3
&L       SETC  ''
         RCPDS
         AIF   (NOT &RCPSTPB(1)).XPT
&P.STPB  DS    CL(L#STPB)              RESERVE SPACE FOR STPB
&L       SETC  '&L.+L#STPB'
.XPT     AIF   (NOT &RCPPTPB(1)).XGT
&P.PTPB  DS    CL(L#PTPB)              RESERVE SPACE FOR PTPB
&L       SETC  '&L.+L#PTPB'
.XGT     AIF   (NOT &RCPGTPB(1)).XPG
&P.GTPB  DS    CL(L#GTPB)              RESERVE SPACE FOR GTPB
&L       SETC  '&L.+L#GTPB'
.XPG     AIF   (NOT &RCPPGPB(1)).XC
&P.PGPB  DS    CL(L#PGPB)              RESERVE SPACE FOR PGPB
&L       SETC  '&L.+L#PGPB'
.XC      RCPDS
&L1      SETC  '&L'(2,K'&L-1)
&L       SETC  '&P'.'&L1'(3,4)
         XC    &L.(&L1.),&L            CLEAR IOPB AREA
         MEND
./       ADD   NAME=RCPLINK
         MACRO
&NAME    RCPLINK &MODULE
         LCLC  &OFFSET,&C
         AIF   ('&MODULE' EQ '').ERROR
         AIF   ('&MODULE' NE 'IKJPARS').T1
&OFFSET  SETC  '524'
         AGO   .START
.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2
&OFFSET  SETC  '732'
         AGO   .START
.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3
&OFFSET  SETC  '736'
         AGO   .START
.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4
&OFFSET  SETC  '740'
         AGO   .START
.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5
&OFFSET  SETC  '444'
         AGO   .START
.T5      AIF   ('&MODULE' NE 'IKJGETL').T6
&OFFSET  SETC  '348'
         AGO   .START
.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7
&OFFSET  SETC  '480'
         AGO   .START
.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8
&OFFSET  SETC  '464'
         AGO   .START
.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9
&OFFSET  SETC  '472'
         AGO   .START
.T9      ANOP
&NAME    DS    0H
*
 MNOTE *,' EP OF &MODULE. NOT IN CVT. STANDARD LINK USED'
*
         AGO   .LINK
.START   ANOP
&NAME    L     R15,16                  LOAD CVT ADDRESS
         L     R15,&OFFSET.(R15)       LOAD MODULE ADDRESS
         LTR   R15,R15                 IS MODULE ADDRESS THERE?
&C       SETC  'RCP&SYSNDX'
         BNM   &C.L                     IF NOT, BRANCH TO LINK
         BALR  R14,R15                  ELSE BALR TO IT
         B     &C.B                      AND BYPASS LINK
&C.L     LINK  EP=&MODULE
&C.B     DS    0H                      BRANCHED TO IF LINK BYPASSED
         MEXIT
.LINK    ANOP
&NAME    LINK  EP=&MODULE
         MEXIT
.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'
         MEND
./       ADD   NAME=RCPLOAD
         MACRO
&NAME    RCPLOAD &MOD,&EP1
         GBLC  &RCPPTEP,&RCPGTEP,&RCPPGEP
         GBLC  &RCPDFEP,&RCPSTEP,&RCPPREP
         GBLC  &RCPPRE
         LCLA  &I,&J
         LCLB  &EPXISTS
         LCLC  &OFFSET,&C,&EP,&MODULE
&EP      SETC  '&EP1'
&MODULE  SETC  '&MOD'
         AIF   ('&MODULE' EQ '').ERROR
         AIF   ('&MODULE'(K'&MOD,1) NE ')').NOBR
&I       SETA  K'&MOD
.LOOP    ANOP
&I       SETA  &I-1
         AIF   (&I LT 2).NOLB
         AIF   ('&MOD'(&I,1) NE '(').LOOP
&MODULE  SETC  '&MOD'(1,&I-1)
&J       SETA  K'&MOD-1-&I
&EP      SETC  '&MOD'(&I+1,&J)
         RCPDS
&EP      DS    F                       TO STORE MODULE ADDRESS
         RCPDS
.NOBR    ANOP
&EPXISTS  SETB  ('&EP' NE '')
         AIF   ('&MODULE' NE 'IKJPARS').T1
&OFFSET  SETC  '524'
&RCPPREP SETC '&EP'
         AIF   (&EPXISTS).START
         RCPDS
&RCPPREP SETC '&RCPPRE.PREP'
&EP      SETC  '&RCPPREP'
&RCPPREP DS    F                       TO HOLD ADDRESS OF IKJPARS
         RCPDS
         AGO   .START
.T1      AIF   ('&MODULE' NE 'IKJDAIR').T2
&OFFSET  SETC  '732'
         AGO   .START
.T2      AIF   ('&MODULE' NE 'IKJEHDEF').T3
&RCPDFEP SETC  '&EP'
&OFFSET  SETC  '736'
         AIF   (&EPXISTS).START
&RCPDFEP SETC  '&RCPPRE.DFEP'
         RCPDS
&RCPDFEP DS    F                       ADDR OF DEFAULT SERVICE ROUTINE
         RCPDS
&EP      SETC  '&RCPDFEP'
         AGO   .START
.T3      AIF   ('&MODULE' NE 'IKJEHCIR').T4
&OFFSET  SETC  '740'
         AGO   .START
.T4      AIF   ('&MODULE' NE 'IKJPUTL').T5
&RCPPTEP SETC  '&EP'
&OFFSET  SETC  '444'
         AIF   (&EPXISTS).START
&RCPPTEP SETC  '&RCPPRE.PTEP'
&EP      SETC  '&RCPPTEP'
         RCPDS
&RCPPTEP DS    F                       ADDR OF PUTLINE ROUTINE
         RCPDS
         AGO   .START
.T5      AIF   ('&MODULE' NE 'IKJGETL').T6
&RCPGTEP SETC  '&EP'
&OFFSET  SETC  '348'
         AIF   (&EPXISTS).START
&RCPGTEP SETC  '&RCPPRE.GTEP'
&EP      SETC  '&RCPGTEP'
         RCPDS
&RCPGTEP DS    F                       ADDR OF GETLINE ROUTINE
         RCPDS
         AGO   .START
.T6      AIF   ('&MODULE' NE 'IKJSCAN').T7
&OFFSET  SETC  '480'
         AGO   .START
.T7      AIF   ('&MODULE' NE 'IKJPTGT').T8
&RCPPGEP SETC  '&EP'
&OFFSET  SETC  '464'
         AIF   (&EPXISTS).START
&RCPPGEP SETC  '&RCPPRE.PGEP'
&EP      SETC  '&RCPPGEP'
         RCPDS
&RCPPGEP DS    F                       ADDR OF PUTGET ROUTINE
         RCPDS
         AGO   .START
.T8      AIF   ('&MODULE' NE 'IKJSTCK').T9
&RCPSTEP SETC  '&EP'
&OFFSET  SETC  '472'
         AIF   (&EPXISTS).START
&RCPSTEP SETC  '&RCPPRE.STEP'
&EP      SETC  '&RCPSTEP'
         RCPDS
&RCPSTEP DS    F                       ADDR OF STACK ROUTINE
         RCPDS
         AGO   .START
.T9      ANOP
&NAME    DS    0H
*
 MNOTE *,' EP OF &MODULE. NOT IN CVT. STANDARD LOAD USED'
*
         AGO   .LOAD
.START   ANOP
&NAME    L     R15,16                  LOAD CVT ADDRESS
         L     R0,&OFFSET.(R15)        LOAD MODULE ADDRESS
         LTR   R0,R0                   IS MODULE LOADED?
&C       SETC  'RCP&SYSNDX'
         BM    &C                      IF SO, BYPASS LOAD MACRO
.LOAD    LOAD EP=&MODULE.
         AIF   ('&EP' EQ '').EPERR
&C       ST    R0,&EP                  STORE ENTRY POINT ADDRESS
         MEXIT
.EPERR   MNOTE 4,'EP RETURN FIELD NOT SPECIFIED'
         MEXIT
.ERROR   MNOTE 4,'NO MODULE NAME SPECIFIED'
         MEXIT
.NOLB    MNOTE 4,'INVALID MODULE NAME ''&MOD'''
         MEND
./       ADD   NAME=RCPLOCSW
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLB  &RCPDSW3(20)   INVERT INDICATOR
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES
         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N
         LCLB  &NOT
         LCLC  &C,&SW1,&SW2
&RCPDSW0 SETA  0                       INITIALIZE
&N       SETA  N'&SW                   NO OF SWITCHES ENTERED
&J       SETA  &RCPDSW#*8+8            INDEX TO LAST DECLARED SW BIT
.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW
&M       SETA  &M+1
&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR
         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL
&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1
&NOT     SETB  0
         AIF   ('&SW2'(1,1) NE ' ' AND '&SW2'(1,1) NE '-').TNOT2
&SW2     SETC  '&SW2'(2,K'&SW2-1)       REMOVE NOT SIGN
&NOT     SETB  1                       INDICATE INVERT FUNCTION
         AGO   .LOOP1A                 CONTINUE
.TNOT2   AIF   (K'&SW2 LT 5).LOOP1A    CHECK LENGTH
         AIF   ('&SW2'(1,4) NE 'NOT-').LOOP1A  WAS SWITCH INVERTED?
&SW2     SETC  '&SW2'(5,K'&SW2-4)      STRIP OFF 'NOT-'
&NOT     SETB  1                       INDICATE INVERTED
.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A
.*
.*   WE FOUND IT
.*
&L       SETA  (&I-1)/8                INDEX TO BYTE NAME
&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME
.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?
&K       SETA  0
.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1
&K       SETA  &K+1
         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1
         AIF   (&RCPDSW3(&K) NE &NOT).SWL1  ENSURE INVERT BIT THE SAME
.*
.* WE FOUND IT
.*
&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW
         AGO   .LOOP1                  GO DO NEXT
.NEWSW1  ANOP
&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX
&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME
&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME
&RCPDSW3(&RCPDSW0) SETB (&NOT)         SET INVERT INDICATOR
         AGO   .LOOP1                  GO DO NEXT
.TGEN    ANOP  SEARCH GENERIC NAME ARRAY
&I       SETA  0
&L       SETA  K'&SW2
.LOOP2   ANOP
&I       SETA  &I+1
         AIF   (&I GT &RCPGSW#).NOTFND
&C       SETC  '&RCPGSWB(&I)'
         AIF   (&L LT K'&C).LOOP2
         AIF   ('&SW2'(1,K'&C) NE '&C').LOOP2
&SW1     SETC  '&RCPGSWN(&I)'
         AGO   .FOUNDSW                EUREKA
.NOTFND  MNOTE 4,'SWITCH ''&SW2'' NOT DECLARED'
         AGO   .LOOP1
.EXIT    MEND
./       ADD   NAME=RCPLOCS1
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLA  &RCPDSW0                NO OF SWS FOUND BY RCPLOCSW
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1(20)            SWITCH BYTE NAMES
         GBLC  &RCPDSW2(20)            SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS
         LCLC  &C,&SW1,&SW2
&RCPDSW0 SETA  0                       INITIALIZE
&N       SETA  N'&SW                   NO OF SWITCHES ENTERED
&J       SETA  &RCPDSW#*8              INDEX TO LAST DECLARED SW BIT
.LOOP1   AIF   (&M GE &N).EXIT        LOOP FOR EACH SW
&M       SETA  &M+1
&SW2     SETC  '&SW(&M)'               SWITCH TO SEARCH FOR
         AIF   ('&SW2' EQ '').LOOP1    SKIP IF NULL
&I       SETA  8                       INDEX TO FIRST DECLARED SW - 1
.LOOP1A  AIF   (&I GE &J).TGEN         SEARCH NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&SW2').LOOP1A
.*
.*   WE FOUND IT
.*
&L       SETA  (&I-1)/8                INDEX TO BYTE NAME
&SW1     SETC  '&RCPDSWN(&L)'          GET BYTE NAME
.FOUNDSW ANOP                          HAVE WE HAD IT BEFORE?
&K       SETA  0
.SWL1    AIF   (&K GE &RCPDSW0).NEWSW1
&K       SETA  &K+1
         AIF   ('&RCPDSW1(&K)' NE '&SW1').SWL1
.*
.* WE FOUND IT
.*
&RCPDSW2(&K) SETC '&RCPDSW2(&K)+&SW2'  CONCATENATE CURRENT SW
         AGO   .LOOP1                  GO DO NEXT
.NENSW1  ANOP
&RCPDSW0 SETA  &K+1                    NEXT SW BYTE INDEX
&RCPDSW1(&RCPDSW0) SETC '&SW1'         BYTE NAME
&RCPDSW2(&RCPDSW0) SETC '&SW2'         BIT NAME
         AGO   .LOOP1                  GO DO NEXT
.TGEN    ANOP  SEARCH GENERIC NAME ARRAY
&I       SETA  0
&L       SETA  K'&SW2
.LOOP2   ANOP
&I       SETA  &I+1
         AIF   (&I GT &RCPGSW#).NOTFND
&SW1     SETC  '&RCPGSWN(&I)'
         AIF   (&L LT K'&SW1).LOOP2
         AIF   ('&SW1'(1,&L) NE '&SW2').LOOP2
         AGO   .FOUNDSW                EUREKA
.NOTFND  MNOTE 4,'SWITCH ''&SW2'' NOT DECLARED'
         AGO   .LOOP1
.EXIT    MEND
./       ADD   NAME=RCPLOCS2
*23456789*12345*78921234567893123456789*
         MACRO
         RCPLOCSW &SW
.********************************************************************
.*                                                                  *
.*       INNER MACRO USED BY GOIF, SET, RESET AND FLIP.             *
.*       THE PARM PASSED IS THE SWITCH OR LIST OF SWITCHES.         *
.*       RCPLOCSW SCANS THE ARRAYS SET UP BY DCLSW TO SEE IF THE    *
.*       SWITCH BIT NAMES WERE DECLARED, AND IF A LIST WAS PASSED,  *
.*       WHETHER ALL THE SWITCH BITS BELONG TO THE SAME BYTE.       *
.*       RCPLOCSW PASSES BACH THE SWITCH BYTE NAME IN GLOBAL SETC   *
.*       VARIABLE &RCPDSW1 AND THE SWITCH BIT NAME IN GLOBAL SETC   *
.*       &RCPDSW2. IF A LIST OF SWITCHES WAS PASSED, &RCPDSW2       *
.*       CONTAINS THE SWITCH NAMES SEPARATED BY PLUS SIGNS.         *
.*       IF THE FIRST OR ONLY SWITCH WAS NOT FOUND, &RCPDSW1 IS SET *
.*       TO NULL. IF A LIST OF SWITCHES IS PASSED AND ANY SWITCH IS *
.*       NOT DECLARED IN THE SAME SWITCH BYTE AS THE FIRST, AN MNOTE*
.*       IS ISSUED WARNING OF POSSIBLE ERROR, BUT &RCPDSW1 IS SET   *
.*       TO THE NAME OF THE SWITCH BYTE CONTAINING THE FIRST SWITCH *
.*       BIT IN THE LIST.                                           *
.*                                                                  *
.********************************************************************
         GBLA  &RCPDSW#,&RCPGSW#       COUNTER FOR DECLARED SWITCHES
         GBLB  &RCPDSWD(99)            DEFER DECLARE INDICATORS
         GBLC  &RCPDSWN(99)            SWITCH BYTE NAMES
         GBLC  &RCPDSWB(800)           SWITCH BIT NAMES
         GBLC  &RCPGSWN(99)            GENERIC SWITCH BYTE NAMES
         GBLC  &RCPGSWB(99)            GENERIC SWITCH BIT PREFIXES
         GBLC  &RCPDSW1                SWITCH BYTE NAME
         GBLC  &RCPDSW2                SWITCH BIT NAME(S)
         LCLA  &I,&J,&K,&L,&M,&N       LOCAL COUNTERS
         LCLC  &C
&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH BIT
&J       SETA  &RCPDSW#*8+8            ARRAY POS OF LAST SW BIT
&I       SETA  8                       ARRAY POS-1 OF 1ST SW BIT
.LOOP1   AIF   (&I GE &J).TGEN         IF SW NOT FOUND IN 1ST ARRAY,
.*                                      GO SEARCH GENERIC NAME ARRAY
&I       SETA  &I+1
         AIF   ('&RCPDSWB(&I)' NE '&RCPDSW2').LOOP1  LOOK FOR MATCH
.*
.*       OK, WE'VE FOUND A MATCH.
.*
&I       SETA  (&I-1)/8               GET POS OF SWITCH BYTE
&RCPDSW1 SETC  '&RCPDSWN(&I)'         MOVE IT TO EXIT PARM VAR
&I       SETA  &I*8+1                 POINT TO 1ST SW BIT IN IT
&J       SETA  &I+8                   POINT TO LAST SW BIT IN IT
&M       SETA  N'&SW                  GET NO OF SWITCHES
&L       SETA  1
.*
.*       NOW WE PROCESS SUBSEQUENT SWITCHES IN THE LIST
.*
.LOOP2   AIF   (&L GE &M).EXIT        EXIT WHEN FINISHED
&L       SETA  &L+1                   POINT TO NEXT SW IN LIST
&C       SETC  '&SW(&L)'               EXTRACT IT
&RCPDSW2 SETC  '&RCPDSW2.+&C'           THEN APPEND TO PREVIOUS
.*
.*       NOW WE CHECK THAT THE SWITCH IS DECLARED IN THE SAME
.*       BYTE AS THE FIRST.
.*
&N       SETA  &I-1                     POINT TO 1ST BIT POS MINUS 1
.LOOP3   AIF   (&N GE &J).NM            IF SW NOT FOUND, ISSUE MNOTE
&N       SETA  &N+1                     POINT TO NEXT
         AIF   ('&C' NE '&RCPDSWB(&N)').LOOP3  SEARCH FOR MATCH
         AGO   .LOOP2                   IF FOUND, GO PROCESS NEXT
.NM      MNOTE 4,'WARNING: SWITCH ''&C'' NOT DECLARED IN SAME BYTE AS  X
               SWITCH ''&SW(1)'' - LOGIC ERROR MAY OCCUR'
         AGO   .LOOP2            CONTINUE FOR NEXT SWITCH BIT
.*
.*       IF THE SWITCH WAS NOT LOCATED IN THE EXPLICIT NAME ARRAY,
.*       THE GENERIC NAME ARRAY IS SEARCHED.
.*
.TGEN    ANOP
&I       SETA  0
&RCPDSW2 SETC  '&SW(1)'                EXTRACT 1ST SWITCH
&L       SETA  K'&RCPDSW2              GET LENGTH OF 1ST SW
.LOOP4   AIF   (&I GE &RCPGSW#).ERROR  IF NOT SW NOT DECLARED, ERROR
&I       SETA  &I+1
&C       SETC  '&RCPGSWB(&I)'          GET GENERIC PREFIX
&K       SETA  K'&C                    GET LENGTH OF GENERIC PREFIX
         AIF   (&L LT &K).LOOP4         AND SKIP IF LEN OF SWITCH NAME
.*                                          < LEN OF GENERIC PREFIX
         AIF   ('&RCPDSW2'(1,&K) NE '&C').LOOP4  ALSO SKIP IF NO MATCH
&RCPDSW1 SETC  '&RCPGSWN(&I)'          SAVE SWITCH BYTE NAME
&I       SETA   1
&J       SETA   N'&SW
.LOOP5   AIF   (&I GE &J).EXIT         EXIT WHEN FINISHED
&I       SETA   &I+1
&RCPDSW2 SETC   '&RCPDSW2.+&SW(&I)'     APPEND THIS SWITCH
         AIF    ('&SW(&I)    '(1,&K) EQ '&C').LOOP5 CHECK PREFIX
         MNOTE 4,'WARNING: SWITCH ''&SW(&I)'' NOT GENERICALLY EQUAL TO X
               SWITCH ''&SW(1)'''
         AGO   .LOOP5
.ERROR   MNOTE 8,'SWITCH ''&SW(1)'' NOT DECLARED'
&RCPDSW1 SETC  ''             INDICATE ERROR
.EXIT    MEND
./       ADD   NAME=RCPMCA
         MACRO
         RCPMCA &DSECT=YES
         GBLC  &RCPPRE
         GBLA  &RCPSWS(10)
         LCLC  &P
     RCPDEBUG
&P       SETC  '&RCPPRE'
         AIF   (&RCPSWS(2) NE 2).DSECT
&P.MCA   DS    0F                      MODULE COMMUNICATIONS AREA
         AGO   .MCA2
.DSECT   ANOP
&P.MCA   DSECT                         MODULE COMMUNICATIONS AREA
.MCA2    ANOP
&P.XDS   DS    F                       ADDR OF EXTERNAL DUMMY SECTION
         AIF   (&RCPSWS(3) LT 1).EXIT
&P.A#GET DS    F                       ADDRESS OF LIFO GET ROUTINE
&P.A#FRE DS    F                       ADDRESS OF LIFO FREE ROUTINE
&P.#S    DS    F                       ADDRESS OF CURRENT LIFO STACK
&P.#E    DS    F                       ADDRESS OF END OF LIFO STACK
&P.#N    DS    F                       ADDRESS OF NEXT FREE AREA
&P.#C    DS    F                       ADDRESS OF NEXT LIFO STACK
&P.#L    DS    F                       LENGTH OF CURRENT LIFO STACK
.EXIT    MEND
./       ADD   NAME=RCPNTU
         MACRO
         RCPNTU &KEY,&LEN,&PAR
.*
.*     THIS IS AN ALLOC/FREE MACRO TEXT UNIT PROCESSOR SUBROUTINE
.*     MACRO. IT BUILDS NUMERIC TYPE TEXT UNITS.
.*
         LCLA  &L,&R
         LCLC  &C
         GBLC  &RCPTYPE
.*  ALLOC/FREE INNER MACRO TO SET UP NUMERIC TEXT UNITS
&L       SETA  1                       DEFAULT LENGTH
         AIF   ('&LEN' EQ '').NL
&L       SETA  &LEN
.NL      MVI   S99TUKEY+1,&KEY         SET KEY FIELD
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,&L           SET LENGTH FIELD
         AIF   ('&PAR'(1,1) EQ '(').REG
         RCPTYPE &PAR                  ANALYSE PARAMETER
         AIF   ('&RCPTYPE' EQ 'N').NUMERIC
&R       SETA  4-&L
         MVC   S99TUPAR(&L),&R+&PAR    MOVE IN QUANTITY
         RCPDINC 10
         MEXIT
.NUMERIC AIF   (&L EQ 1).NL1
         MVC   S99TUPAR(&L.),=AL&L.(&PAR) MOVE IN QUANTITY
&R       SETA  &L+6
         AIF   (&R/2 EQ (&R+1)/2).LOK ENSURE LENGTH EVEN
&R       SETA  &R+1
.LOK     RCPDINC &R
         MEXIT
.NL1     MVI   S99TUPAR,&PAR           MOVE IN QUANTITY
         RCPDINC 8
         MEXIT
.REG     ANOP
&C       SETC  '&PAR'(2,K'&PAR-2)
         AIF   (&L EQ 3).STCM
         AIF   (&L EQ 2).STH
         AIF   (&L EQ 1).STC
         ST    &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STH     STH   &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STC     STC   &C,S99TUPAR             STORE TEXT UNIT QUANTITY
         AGO   .RCPDINC
.STCM    STCM  &C,7,S99TUPAR           STORE TEXT UNIT QUANTITY
.RCPDINC RCPDINC 10
         MEND
./       ADD   NAME=RCPPERM
         MACRO
         RCPPERM
         SPACE
***********************************************************************
**     PERMANENTLY ALLOCATED ATTRIBUTE TEXT UNIT                     **
***********************************************************************
         MVI   S99TUKEY+1,DALPERMA     SET TEXT UNIT KEY
         RCPDINC  4
         MEND
./       ADD   NAME=RCPPPL
         MACRO
&NAME    RCPPPL &PCL=,&NOPARM=,&PARSERR=,&PDLREG=R11,                  X
               &PDLNAME=,&PARSEP=,&PARSWKA=
         GBLB  &RCPPPL(2),&RCPECT(2)
         GBLC  &RCPPRE,&RCPPREP
         LCLC  &P
&P       SETC  '&RCPPRE'
         AIF   (&RCPPPL(2)).BPPL
         EJECT
         IKJPPL
L#PPL    EQU   *-PPL                   LENGTH OF PPL
&SYSECT  CSECT
         SPACE 1
&RCPPPL(2) SETB 1
.BPPL    RCPDS
&P.PPL   DS    CL(L#PPL)               RESERVE SPACE FOR PPL
&P.PDLP  DS    F                       POINTER TO PDL
         RCPDS
         SPACE 6
***********************************************************************
***   THIS CODE GENERATES A PARSE PARAMETER LIST                    ***
***********************************************************************
         XC    &P.PDLP,&P.PDLP         ZERO PDL POINTER
         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' NE '').PB2
         L     R1,CPPLECT              LOAD ECT ADDRESS
&RCPECT(1) SETB 1
         USING ECT,R1                  ECT ADDRESSABLE
         TM    ECTSWS,ECTNOPD          WERE ANY OPERANDS SUPPLIED?
         BO    &NOPARM(1)              NO, BRANCH OUT
         SPACE
.PB2     LA    R1,&P.PPL               LOAD PPL ADDRESS
         USING PPL,R1
         MVC   PPLUPT,CPPLUPT          MOVE IN UPT ADDRESS
         MVC   PPLECT,CPPLECT          MOVE IN ECT ADDRESS
         MVC   PPLCBUF,CPPLCBUF        MOVE IN CBUF ADDRESS
         LA    R15,&P.ECB              LOAD ATTN ECB ADDRESS
         ST    R15,PPLECB              AND STORE IN PPL
         LA    R15,&P.PDLP             LOAD PDL POINTER ADDRESS
         ST    R15,PPLANS               AND STORE IN PPL
         AIF   ('&PARSWKA' EQ '').PB3
         AIF   ('&PARSWKA'(1,1) EQ '').PB4
         LA    R15,&PARSWKA            LOAD ADDRESS OF WORK AREA
         ST    R15,PPLUWA               AND STORE IN PPL
         AGO   .PB3
.PB4     ST    &PARSWKA(1),PPLUWA      STORE ADDRESS OF WORKAREA
.PB3     AIF   ('&PCL' EQ '').EXIT
         L     R15,=V(&PCL)            LOAD PCL ADDRESS
         ST    R15,PPLPCL              AND STORE IN PPL
         SPACE 2
         AIF   ('&NOPARM(1)' EQ '' OR '&NOPARM(2)' EQ '').PB5
         L     R1,CPPLECT              LOAD ECT ADDRESS
&RCPECT(1) SETB 1
         USING ECT,R1
         TM    ECTSWS,ECTNOPD          WERE ANY OPERANDS SUPPLIED?
         BO    &NOPARM(1)               NO, BRANCH OUT
         SPACE
.PB5     AIF   ('&SYSPARM' EQ 'MVT').MVTBYP
         AIF   ('&RCPPREP' EQ '').NOPREP
         L     R15,&RCPPREP            LOAD EP OF IKJPARS
         BALR  R14,R15                  AND ENTER IT
         AGO   .PRET
.NOPREP  ANOP
         L     R15,16                  LOAD CVT ADDRESS
         TM    524(R15),X'80'          IS IKJPARS LOADED?
         AIF   ('&PARSEP' EQ '').PBL1
         BZ    &P.LOAD                  NO, BRANCH TO LOAD SVC
         L     R15,524(15)             LOAD EP OF IKJPARS
         ST    R15,&PARSEP             SAVE ITS ADDRESS
         BALR  R14,R15                 THEN BALR TO IT
         B     &P.PLNKB                BYPASS LOAD SVC
&P.LOAD  LOAD  EP=IKJPARS
         LR    R15,R0                  LOAD EP OF IKJPARS
         ST    R15,&PARSEP             SAVE IT
         BALR  R14,R15                 THEN BALR TO IT
&P.PLNKB DS    0H
         AGO   .PRET
.PBL1    BZ    &P.PLINK                 NO, BRANCH TO LINK SVC
         L     R15,524(R15)            ELSE LOAD ITS ADDRESS
         BALR  R14,R15                  AND BALR TO IT
         B     &P.PLNKB                BYPASS LINK SVC
.MVTBYP  ANOP
&P.PLINK LINK  EP=IKJPARS
&P.PLNKB DS    0H
.PRET    AIF   ('&PARSERR' EQ '').EXIT
         SPACE
         LTR   R15,R15                 TEST RETURN CODE
         BNZ   &PARSERR                 AND BRANCH ON NON-ZERO
         SPACE
         AIF   ('&PDLREG' EQ '' OR '&PDLNAME' EQ '').EXIT
         L     &PDLREG,&P.PDLP         LOAD PDL ADDRESS
         USING &PDLNAME,&PDLREG        PDL DSECT ADDRESSABLE
.EXIT    MEND
./       ADD   NAME=RCPPROC
         MACRO
         RCPPROC &WKCSECT=,&WKDSECT=,                                  X
               &REG1=,&REG0=,&ISA=,&SAVEPRE=,                          X
               &SAVESUF=,&SP=
         GBLA  &RCPSWS(10)
         GBLC  &RCPPRE,&RCPWKCS,&RCPWKDS
         GBLC  &RCPSPN
         LCLC  &P,&C
         RCPDEBUG
&P       SETC  '&RCPPRE'
         AIF   ('&WKCSECT' EQ '').TDS
         SPACE
         MNOTE 4,'WKCSECT= OPTION INVALID WITH PROC OPTION, '
         MNOTE *,'    WKDSECT=  USED INSTEAD'
&RCPWKDS SETC  '&WKCSECT'
         AGO   .SETCS
.TDS     AIF   ('&WKDSECT' EQ '').SYSECT
&RCPWKDS SETC  '&WKDSECT'
         AGO   .SETCS
.SYSECT  ANOP
&RCPWKDS SETC  '&SYSECT'
.SET1    AIF   (K'&RCPWKDS LT 8).LOK
&RCPWKDS SETC  '&RCPWKDS'(1,4)'&RCPWKDS'(6,3)'1'
         AGO   .SETCS
.LOK     ANOP
&RCPWKDS SETC  '&RCPWKDS.1'
.SETCS   ANOP
&RCPWKCS SETC  ''
&RCPSWS(4) SETA &RCPSWS(2)-1 SET W/A TO BE FREED OPT IF PROC(MAIN)
         AIF   ('&ISA' EQ '').NISA
&RCPSWS(3) SETA 1                      SET LIFO FLAG IF ISA SPEC
.NISA    ANOP
         SPACE 2
         RCPDS
         DS    9D                      SAVE AREA
&P.RCODE DS    F                       RETURN CODE
         RCPMCA
         RCPDS
         SPACE 2
         AIF   ('&REG1' EQ '').TR0
         LR    &REG1,R1                SAVE CONTENTS OF REG 1
.TR0     AIF   ('&REG0' EQ '').TP
         LR    &REG0,R0                SAVE CONTENTS OF REG 0
.TP      AIF   (&RCPSWS(2) EQ 2).PROCMN   PROCMAIN OPTION
         AIF   (&RCPSWS(3) EQ 1).PL    LIFO OPTION
         L     R15,0(R13)              R15 -> MODULE COMMUNIC. AREA
         L     R15,&P.XDS-&P.MCA(R15)  LOAD EXTERNAL DUMMY SECT ADDR
         AL    R15,&P.QCON             GET OFFSET TO WORK AREA
         ST    R15,8(R13)              CHAIN SAVE
         ST    R13,4(R15)               AREAS TOGETHER
         MVC   0(4,R15),0(R13)         COPY POINTER TO COMM AREA
         LR    R13,R15                 LOAD WORK AREA ADDRESS
         USING &RCPWKDS,R13              ESTABLISH ADDRESSABLITY TO IT
         MEXIT
.PL      ANOP
***********************************************************************
*        GET WORKAREA FROM LIFO STACK                                 *
***********************************************************************
         #GET  LV=&P.WKLEN
         ST    R1,8(R13)               CHAIN SAVE
         ST    R13,4(R1)                AREAS TOGETHER
         MVC   0(4,R1),0(R13)          PROPAGATE MODULE COMM. AREA ADDR
         LR    R13,R1                  LOAD WORK AREA ADDRESS
         USING &RCPWKDS,R13             ESTABLISH ADDRESSABILITY TO IT
         MEXIT
.PROCMN  L     R0,&P.CXD               LOAD WORK AREA LENGTH
         AIF   ('&SYSPARM' EQ 'MVT').MVT
 MNOTE *,'      GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE'
         GETMAIN RU,LV=(0),SP=&SP,BNDRY=PAGE
         AGO   .CONT
.MVT     AIF   ('&SP' EQ '').NOSP
         ICM   R0,8,=AL1(&SP)          INSERT SUBPOOL NUMBER
.NOSP    ANOP
*        GETMAIN R,LV=(0)              OBTAIN A WORK AREA
.CONT    ANOP
&RCPSPN  SETC  '&SP'
         LR    R15,R13                 SAVE CALLER'S SAVE AREA ADDR
         LR    R13,R1                  LOAD EXT DUMMY SECTION ADDR
         AL    R13,&P.QCON              ADD OFFSET TO WORK AREA
         ST    R13,8(R15)              CHAIN SAVE
         ST    R15,4(R13)               AREAS TOGETHER
         USING &RCPWKDS,R13            GET WORKAREA ADDRESSABILITY
         ST    R1,&P.XDS               STORE DUMMY SECTION ADDR IN     X
                                         MODULE COMMUNICATIONS AREA
         LA    R15,&P.MCA              STORE COMMUNICATIONS AREA ADDR
         ST    R15,0(R13)               IN WORD 1 OF SAVE AREA
         AIF   (&RCPSWS(3) EQ 0 AND '&ISA' EQ '').EXIT
&RCPSWS(3) SETA 1                      SET LIFO IN CASE ONLY ISA SPEC
&C       SETC  '&ISA'
         AIF   ('&ISA' NE '').TK
&C       SETC  '8192'
         AGO   .NK
.TK      AIF   ('&C'(K'&C,1) NE 'K').NK
&C       SETC  '&C'(1,K'&C-1)'*1024'
.NK      EJECT
***********************************************************************
**       INITIALIZE MODULE COMMUNICATIONS AREA WITH POINTERS         **
**       TO LIFO STACK AND LIFO GET/FREE ROUTINES                    **
***********************************************************************
         SPACE 1
         MVC   &P.A#GET,=V(#####GET)   MOVE LIFO GET AND FREE
         MVC   &P.A#FRE,=V(####FREE)    ROUTINE ADDRESSES TO MCA
         L     R15,=Q(#####ISA)        COMPUTE LIFO STACK
         AL    R15,&P.XDS               PSEUDO REGISTER OFFSET
         ST    R15,&P.#S                 AND INITIALIZE POINTERS
         ST    R15,&P.#N                  IN MODULE COMMUNICATIONS AREA
         L     R14,=A(&C)              LOAD SIZE OF INITIAL STACK AREA
         ST    R14,&P.#L               STORE THIS IN MCA
         ALR   R15,R14                  THEN COMPUTE STACK END ADDRESS
         ST    R15,&P.#E                 AND STORE THIS INTO MCA
         EJECT
***********************************************************************
**       LIFO STACK GET/FREE ROUTINES                                **
***********************************************************************
         SPACE 1
#####ISA DXD   CL(&C)                  DEFINE PSEUDO REGISTER FOR ISA
         SPACE 1
#####GET CSECT                         LIFO GET ROUTINE
         USING *,R15
         USING &P.MCA,R1
         A     R0,&P.F7                ROUND LENGTH UP TO
         N     R0,&P.F8                 A MULTIPLE OF 8
         AL    R0,&P.#N                COMPUTE NEXT FREE LIFO SLOT ADDR
         CL    R0,&P.#E                COMPARE TO STACK END ADDRESS
         BH    &P.GA                    AND IF TOO BIG, BRANCH
         LR    R15,R1                  PRESERVE MCA ADDRESS
         USING &P.MCA,R15              NEW BASE
         L     R1,&P.#N                LOAD ADDRESS OF SLOT
         ST    R0,&P.#N                 AND STORE ADDRESS OF NEXT SLOT
         BR    R14                     RETURN TO CALLER
         SPACE 1
&P.GA    EQU   *                       IF CURRENT SLOT TOO SMALL
*        ABEND 1000,DUMP                ABEND FOR NOW
         ABEND 1000,DUMP
         SPACE 2
####FREE DS    0H                      LIFO FREE ROUTINE
         ENTRY ####FREE
         USING *,R15                   BASE ADDRESS
         USING &P.MCA,R1               MCA ADDRESS
         CL    R0,&P.#S                CHECK THAT
         BL    &P.FA                    ADDRESS TO BE
         CL    R0,&P.#E                  FREED IS WITHIN
         BH    &P.FA                      BOUND OF CURRENT STACK
         AL    R0,&P.F7                GET UPPER DOUBLE
         N     R0,&P.F8                 WORD BOUNDARY
         ST    R0,&P.#N                  AND UPDATE MCA
         BR    R14                     RETURN TO CALLER
         SPACE 1
&P.FA    EQU   *                       IF ADDRESS NOT WITHIN THIS STACK
*        ABEND 1001,DUMP               ABEND
         ABEND 1001,DUMP
         SPACE 2
&P.F7    DC    F'7'                    CONSTANTS
&P.F8    DC    F'-8'                    TO ROUND UP TO DOUBLEWORD SIZE
         DROP  R1,R15                  KILL ADDRESSABILITY
&SYSECT  CSECT                         RESUME MAIN PROGRAM CSECT
.EXIT    MEND
./       ADD   NAME=RCPPSWD
         MACRO
         RCPPSWD &PASSW
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE PASSWORD TEXT UNIT                                    **
***********************************************************************
         RCPVCHAR DALPASSW,14,&PASSW
         MEND
./       ADD   NAME=RCPQNAME
         MACRO
         RCPQNAME &QNAME
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE QNAME TEXT UNIT                                       **
***********************************************************************
         RCPVCHAR DALQNAME,14,&QNAME
         MEND
./       ADD   NAME=RCPRNGE
         MACRO - BREAK A RANGE PARAMETER INTO TWO
         RCPRNGE &P
         GBLC  &RCPRNGE(2)
         LCLA  &I,&J,&K
&K       SETA  K'&P
&RCPRNGE(1) SETC ''
&RCPRNGE(2) SETC ''
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &K).NR
         AIF   ('&P'(&I,1) NE '-' AND '&P'(&I,1) NE ':').LOOP
&RCPRNGE(1) SETC '&P'(1,&I-1)
&RCPRNGE(2) SETC '&P'(&I+1,&K-&I)
         MEXIT
.NR      ANOP
&RCPRNGE(1) SETC '&P'
         MEND
./       ADD   NAME=RCPSPACE
         MACRO
         RCPSPACE &SPACE
         GBLA  &RCPSUB#                NO OF SUBLIST ELEMENTS
         GBLC  &RCPSUBL(100)           SUBLIST ELEMENTS
.**********************************************************************
.*    THIS IS AN ALLOC INNER MACRO TO BUILD THE ALLOCATION SPACE
.*    QUANTITY TEXT UNIT. IT SHOULD BE SPECIFIED AS:-
.*     SPACE=(TYPE,(PRIMARY,SECONDARY,DIRECTORY),RLSE,CONTIG,ROUND)
.*   WHERE TYPE IS 'TRK', 'CYL', 'ABSTR' OR A BLOCK QUANTITY
.*     'CYL' OR 'TRK' SHOULD NOT BE ENTERED IN QUOTES. THE BLOCK
.*     QUANTITY CAN BE A NUMBER, A REGISTER (IN BRACKETS), OR THE
.*     NAME OF A FULLWORD CONTAINING THE BLOCK SIZE.
.**********************************************************************
         AIF   ('&SPACE(1)' EQ '' OR '&SPACE(1)' EQ 'TRK').TRK
         AIF   ('&SPACE(1)' EQ 'CYL').CYL
***********************************************************************
**        SPACE UNIT IN BLOCKS                                       **
***********************************************************************
         RCPNTU DALBLKLN,3,&SPACE(1)  GENERATE BLOCK UNIT TU
         AGO   .TPRIME        GO TEST PRIME QUANTITY
.TRK     ANOP  TRACK SPEC REQ OR DEFAULTED
         SPACE
***********************************************************************
**       SPACE QUANTITY IN TRACKS                                    **
***********************************************************************
         MVI   S99TUKEY+1,DALTRK       SET TEXT UNIT KEY
         RCPDINC 4
         AGO   .TPRIME
.CYL     ANOP  CYL QUANTITY
         SPACE 1
***********************************************************************
**      SPACE UNIT IN CYLINDERS                                      **
***********************************************************************
         MVI   S99TUKEY+1,DALCYL       SET TEXT UNIT KEY
         RCPDINC 4                     STORE TEXT UNIT ADDR
.TPRIME  RCPSUBL &SPACE(2)             BREAK UP SUBLIST
         AIF   (&RCPSUB# EQ 0).TCONTIG
         AIF   ('&RCPSUBL(1)' EQ '').TSP2
         SPACE
***********************************************************************
**       PRIMARY SPACE QUANTITY                                      **
***********************************************************************
         RCPNTU DALPRIME,3,&RCPSUBL(1)
.TSP2    AIF   (&RCPSUB# LT 2).TCONTIG
         AIF   ('&RCPSUBL(2)' EQ '').TSP3
         SPACE
***********************************************************************
**       SECONDARY SPACE QUANTITY                                    **
***********************************************************************
         RCPNTU DALSECND,3,&RCPSUBL(2)
.TSP3    AIF   (&RCPSUB# LT 3).TCONTIG
         AIF   ('&RCPSUBL(3)' EQ '').TCONTIG
         SPACE
***********************************************************************
**       DIRECTORY BLOCK QUANTITY                                    **
***********************************************************************
         RCPNTU DALDIR,3,&RCPSUBL(3)
.TCONTIG AIF  ('&SPACE(3)' EQ 'CONTIG' OR '&SPACE(4)' EQ 'CONTIG').CON
         AIF   ('&SPACE(3)' EQ 'MXIG' OR '&SPACE(4)' EQ 'MXIG').MXIG
         AIF   ('&SPACE(3)' EQ 'ALX' OR '&SPACE(4)' EQ 'ALX').ALX
.TRLSE   AIF   ('&SPACE(3)' EQ 'RLSE' OR '&SPACE(4)' EQ 'RLSE').RLSE
.TROUND  AIF   ('&SPACE(4)'EQ'ROUND'OR'&SPACE(5)'EQ'ROUND').ROUND
         MEXIT
.CON     ANOP
***********************************************************************
**      CONTIGUOUS SPACE TEXT UNIT                                   **
***********************************************************************
         RCPNTU DALSPFRM,1,8
         AGO   .TRLSE
.MXIG    ANOP
***********************************************************************
**       MAXIMUM CONTIGUOUS SPACE TEXT UNIT                          **
***********************************************************************
         RCPNTU DALSPFRM,1,4
         AGO   .TRLSE
.ALX     ANOP
***********************************************************************
**       'ALX' SPACE TEXT UNIT                                       **
***********************************************************************
         RCPNTU DALSPFRM,1,2
         AGO   .TRLSE
.RLSE    ANOP
***********************************************************************
**      RELEASE UNUSED SPACE TEXT UNIT                               **
***********************************************************************
         MVI   S99TUKEY+1,DALRLSE      SET TEXT UNIT KEY
         RCPDINC 4
         AGO   .TROUND
.ROUND   ANOP
***********************************************************************
**      RELEASE UNUSED SPACE TEXT UNIT                               **
***********************************************************************
         MVI   S99TUKEY+1,DALROUND     MOVE IN TEXT UNIT KEY
         RCPDINC 4
         MEND
./       ADD   NAME=RCPSPEC
         MACRO - SET UP USER DEFINED TEXT UNIT
         RCPSPEC &T
         LCLA  &I,&J
&I       SETA  1
&J       SETA  K'&T
         SPACE
***********************************************************************
**       PROCESS SPECIAL TEXT UNITS                                  **
***********************************************************************
.LOOP    RCPVCHAR &T(&I),&T(&I+2),&T(&I+3),N=&T(&I+1)
&I       SETA  &I+4
         AIF   (&I LE &J).LOOP
         MEND
./       ADD   NAME=RCPSR2
         MACRO
         RCPSR2 &A
         GBLB  &RCPSR2
         GBLC  &DYNP
         LCLC  &C
.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY
.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND
.*    GENERATES MOVE INSTRUCTION FOR EXECUTE
         AIF   ('&A' NE '').UNSAVE
         AIF   (&RCPSR2).EXIT
&RCPSR2  SETB  1
         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2
         MEXIT
.UNSAVE  AIF   (NOT &RCPSR2).EXIT
         B     *+10                    SKIP NEXT INSTRUCTION
&C       SETC  '&DYNP.MVC'
&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE
         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2
&RCPSR2  SETB  0
.EXIT    MEND
./       ADD   NAME=RCPSSREQ
         MACRO
         RCPSSREQ
         SPACE 1
***********************************************************************
**       SUBSYSTEM REQUEST TEXT UNIT                                 **
***********************************************************************
         SPACE 1
         MVI   S99TUKEY+1,DALSSREQ MOVE IN TEXT UNIT KEY
         RCPDINC                   4
         MEND
./       ADD   NAME=RCPSUBL
         MACRO - BREAK DOWN A SUBLIST
         RCPSUBL &L
         GBLA  &RCPSUB#                NO OF ELEMENTS FOUND
         GBLC  &RCPSUBL(100)           ELEMENTS
         LCLA  &I,&J,&K
&RCPSUB# SETA  0                       INITIALIZE
         AIF   ('&L' EQ '').EXIT       EXIT IF NULL STRING
         AIF   ('&L'(1,1) NE '(').NOSUB
&K       SETA  K'&L-1
&I       SETA  2
&J       SETA  1
.LOOP    ANOP
&J       SETA  &J+1
         AIF   (&J  GT &K).LAST
         AIF   ('&L'(&J,1) NE ',').LOOP
&RCPSUB# SETA &RCPSUB#+1
         AIF   (&J EQ &I).NULL
&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)
&I       SETA  &J+1
         AGO   .LOOP
.NULL    ANOP
&RCPSUBL(&RCPSUB#) SETC ''
&I       SETA  &J+1
         AGO   .LOOP
.LAST    AIF   (&J EQ &I).LASTNUL
&RCPSUB# SETA  &RCPSUB#+1
&RCPSUBL(&RCPSUB#) SETC '&L'(&I,&J-&I)
         AGO   .EXIT
.LASTNUL ANOP
&RCPSUB# SETA  &RCPSUB#+1
&RCPSUBL(&RCPSUB#) SETC ''
         AGO   .EXIT
.NOSUB   ANOP
&RCPSUBL(1) SETC '&L'
&RCPSUB# SETA 1
.EXIT    MEND
./       ADD   NAME=RCPSYSOU
         MACRO
         RCPSYSOU &CLASS,&COPIES=,&FREE=,&DEST=,&FORMS=
         GBLC  &DYNP
         LCLC  &C
         AIF   ('&CLASS(1)' EQ '').TPGN
&C       SETC  '&CLASS(1)'
         SPACE
***********************************************************************
**       SYSOUT CLASS TEXT UNIT                                      **
***********************************************************************
         AIF   ('&C'(1,1) EQ '''').Q
         AIF   ('&C'(K'&C,1) EQ '/').BS
         AIF   ('&C'(1,1) EQ '(').REG
         L     R14,&C                  LOAD ADDRESS OF SYSOUT CLASS
         MVC   S99TUPAR(1),0(R14)       AND MOVE IT TO TEXT UNIT
         AGO   .SKEY
.REG     MVC   S99TUPAR(1),0&C         MOVE SYSOUT CLASS TO TEXT UNIT
.SKEY    MVI   S99TUKEY+1,DALSYSOU     SET SYSOUT KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,1            SET LENGTH FIELD
         RCPDINC 8
         AGO   .TPGN
.BS      RCPTUBFR DALSYSOU,14,&C
         AGO   .TPGN
.Q       RCPBTU DALSYSOU,1,&C
.TPGN    AIF   ('&CLASS(2)' EQ '').TCOP
         SPACE
***********************************************************************
**   SYSOUT PROGRAM NAME TEXT UNIT                                   **
***********************************************************************
&C       SETC  '&CLASS(2)'
         RCPVCHAR DALSPGNM,14,&C
.TCOP    AIF   ('&COPIES' EQ '').TFREE
         SPACE
***********************************************************************
**    SYSOUT COPIES TEXT UNIT                                        **
***********************************************************************
         RCPNTU DALCOPYS,1,&COPIES
.TFREE   AIF   ('&FREE' EQ '').TDEST
         SPACE
***********************************************************************
**     FREE = CLOSE TEXT UNIT                                        **
***********************************************************************
         AIF   ('&FREE' EQ 'CLOSE').CLOSEOK
         MNOTE 4,' **** FREE=&FREE INVALID, FREE=CLOSE USED'
.CLOSEOK MVI   S99TUKEY+1,DALCLOSE     MOVE IN TEXT UNIT KEY
         RCPDINC 4
.TDEST   AIF   ('&DEST' EQ '').TFORMS
         SPACE
***********************************************************************
**       SYSOUT DESTINATION TEXT UNIT                                **
***********************************************************************
         RCPVCHAR DALSUSER,14,&DEST
.TFORMS  AIF   ('&FORMS' EQ '').EXIT
         SPACE
***********************************************************************
**     SYSOUT FORMS NUMBER TEXT UNIT                                 **
***********************************************************************
         RCPVCHAR DALSFMNO,14,&FORMS
.EXIT    MEND
./       ADD   NAME=RCPTU
         MACRO
         RCPTU &TU            TEXT UNIT LIST
         GBLA  &DTUPO         TEXT UNIT POINTER OFFSET
         GBLC  &DYNP          ALLOC SYMBOL PREFIX
         LCLA  &I,&J
         LCLC  &C
         SPACE 1
***********************************************************************
**       ADD SPECIAL TEXT UNITS                                      **
***********************************************************************
&J       SETA  N'&SYSLIST
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &J).EXIT
         AIF   ('&TU(&I)'(1,1) EQ '(').R
         LA    R15,&TU(&I)             LOAD TEXT UNIT ADDRESS
         ST    R15,&DYNP.TUP+&DTUPO     AND STORE IT IN POINTER LIST
&DTUPO   SETA  &DTUPO+4
         AGO   .LOOP
.R       ANOP
&C       SETC  '&TU(&I)'(2,K'&TU(&I)-2)
         ST    &C,&DYNP.TUP+&DTUPO     STORE TEXT UNIT ADDR IN PTR LIST
&DTUPO   SETA  &DTUPO+4
         AGO   .LOOP
.EXIT    MEND
./       ADD   NAME=RCPTUBFR
         MACRO  - BUILD TEXT UNIT FROM BUFFER
         RCPTUBFR &KEY,                TEXT UNIT KEY                   X
               &L,                     MAXIMUM LENGTH VALUE            X
               &C,                     TEXT UNIT                       X
               &N=1                    TEXT UNIT NUMBER
         GBLC  &EXECNAM
         LCLC  &C1,&C2
         LCLA  &I,&K
         MVI   S99TUKEY+1,&KEY         SET TEXT UNIT KEY
         AIF   ('&N' EQ '' OR '&N' EQ '1').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE INTO TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET TEXT UNIT NUMBER
.ENDN    ANOP
&K       SETA  K'&C
&I       SETA  &K-1
.LOOP1   ANOP
&K       SETA  &K-1
         AIF   (&K LE 0).STD
         AIF   ('&C'(&K,1) NE '/').LOOP1
&C2      SETC  '&C'(&K+1,&I-&K)
&C1      SETC  '&C'(1,&K-1)
         AIF   ('&C1'(1,1) NE '(').TC2
&C1      SETC  '0&C1'
.TC2     AIF   ('&C2' EQ '0000').V2B
         AIF   ('&C2' EQ '00').V1B
         AIF   ('&C2' EQ '0').V0B
         AIF   ('&C2'(1,1) EQ '(').RL
         MVI   S99TULNG+1,&C2          SET LENGTH FIELD
         MVC   S99TUPAR(&C2.),&C1      MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.STD     ANOP
&K       SETA  &L-6
         MVI   S99TULNG+1,&K           SET TEXT UNIT LENGTH
&C1      SETC  '&C'(1,&I)              REMOVE TRAILING SLASH
         MVC   S99TUPAR(&K),&C1        MOVE IN TEXT UNIT
         RCPDINC &L
         MEXIT
.V2B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
         S     R14,=A(4)               EXCLUDE LENGTH OF HEADER
&C1      SETC  '4+&C1'
         AGO   .MOVE
.V1B     LH    R14,&C1                 LOAD TEXT UNIT LENGTH
&C1      SETC  '2+&C1'
         AGO   .MOVE
.V0B     SLR   R14,R14                 CLEAR FOR IC
         IC    R14,&C1                 INSERT TEXT UNIT LENGTH
&C1      SETC  '1+&C1'
         AGO   .MOVE
.RL      ANOP
&C2      SETC  '&C2'(2,K'&C2-2)
         LR    R14,&C2                 LOAD TEXT UNIT LENGTH
.MOVE    STH   R14,S99TULNG             AND STORE INTO LENGTH FIELD
         BCTR  R14,0                   GET MACHINE LENGTH
         EXECUTE ,MVC,S99TUPAR-S99TUNIT(0,R15),&C1
         EX    R14,&EXECNAM            MOVE IN TEXT UNIT
         RCPDINC &L
         MEND
./       ADD   NAME=RCPTXTL
         MACRO - TO COUNT CHARACTERS IN A STRING
         RCPTXTL &S
         GBLA  &RCPTXTL
         LCLA  &I,&K,&L
&RCPTXTL SETA  0
         AIF   (K'&S LT 3).MEND
&RCPTXTL SETA  K'&S-2
&L       SETA  &RCPTXTL
&I       SETA  1
.LOOP    ANOP
&I       SETA  &I+1
.LOOP2   AIF   (&I GT &L).MEND
         AIF   ('&S'(&I,2) NE '''''' AND '&S'(&I,2) NE '&&').LOOP
&I       SETA  &I+2
&RCPTXTL SETA  &RCPTXTL-1
         AGO   .LOOP2
.MEND    MEND
./       ADD   NAME=RCPTYPE
         MACRO
         RCPTYPE &T
         GBLC  &RCPTYPE
         LCLA  &I,&K
&K       SETA  K'&T
&RCPTYPE SETC  ''
         AIF   (&K EQ 0).EXIT
&RCPTYPE SETC  'C'
.LOOP    ANOP
&I       SETA  &I+1
         AIF   ('&T'(&I,1) LT '0' OR '&T'(&I,1) GT '9').EXIT
         AIF   (&I LT &K).LOOP
&RCPTYPE SETC  'N'
.EXIT    MEND
./       ADD   NAME=RCPUNALC
         MACRO
         RCPUNALC
         SPACE 1
***********************************************************************
**     FREE EVEN IF PERMANENTLY ALLOCATED                            **
***********************************************************************
         MVI   S99TUKEY+1,DUNUNALC     SET TEXT UNIT KEY
         RCPDINC  4
         MEND
./       ADD   NAME=RCPUNIT
         MACRO
         RCPUNIT &U,&V
         GBLC  &DYNP
         AIF   ('&U' EQ '').TVOL
         SPACE 1
***********************************************************************
**       UNIT NAME TEXT UNIT                                         **
***********************************************************************
         RCPVCHAR DALUNIT,14,&U
.TVOL    AIF   ('&V' EQ '').EXIT
         SPACE 1
***********************************************************************
**       VOLUME SERIAL TEXT UNIT                                     **
***********************************************************************
         RCPVCHAR DALVLSER,14,&V
.EXIT    MEND
./       ADD   NAME=RCPVCHAR
         MACRO
         RCPVCHAR &KEY,&LEN,&C,&N=1
         GBLC  &DYNP
         AIF   ('&C'(K'&C,1) EQ '/').BM
         AIF   ('&C'(1,1) EQ '''').QM
         RCPSR2
         AIF   ('&C'(1,1) EQ '(').RM
         LH    R2,&C+4                 LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,&C                  LOAD ADDRESS OF TEXT UNIT
         AGO   .STHM
.RM      LH    R2,4&C                  LOAD LENGTH OF TEXT UNIT
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO TEXT UNIT, SKIP
         L     R14,0&C                 LOAD ADDRESS OF TEXT UNIT
.STHM    STH   R2,S99TULNG             STORE LENGTH OF TEXT UNIT
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN TEXT UNIT
         MVI   S99TUKEY+1,&KEY         MOVE IN TEXT UNIT KEY
         AIF   ('&N' EQ '1' OR '&N' EQ '').N1
         LA    R14,&N                  LOAD TEXT UNIT NUMBER
         STH   R14,S99TUNUM             AND STORE IT IN TEXT UNIT
         AGO   .ENDN
.N1      MVI   S99TUNUM+1,1            SET NUMBER FIELD
.ENDN    RCPDINC &LEN
         MEXIT
.BM      RCPTUBFR &KEY,&LEN,&C
         MEXIT
.QM      RCPBTU &KEY,&N,&C
         MEND
./       ADD   NAME=RCPVOLRT
         MACRO
         RCPVOLRT
         SPACE 1
***********************************************************************
**    VOLUME SERIAL RETURN TEXT UNIT                                 **
***********************************************************************
         MVI   S99TUKEY+1,DALRTVOL     SET RETURN VOLUME SERIAL KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         MVI   S99TULNG+1,8            SET LENGTH FIELD
         MVC   S99TUPAR(8),=CL8' '     INITIALIZE FIELD TO BLANKS
         RCPDINC 14
         MEND
./       ADD   NAME=REGS
R0       EQU   0        *USED BY O.S.
R1       EQU   1        *USED BY O.S. // ADDRESS OF PARAMETER LIST
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13       *USED BY O.S. // SAVE-AREA ADDRESS
R14      EQU   14       *USED BY O.S. // RETURN ADDRESS
R15      EQU   15       *USED BY O.S. // ENTRY-PT ADDR, RETURN CODE
./       ADD   NAME=S99FAIL
         MACRO
&NAME    S99FAIL &RB=(R14),&RC=(R15),&CPPL=,&MF=G,&CP=
         GBLB  &RCPCPPL(2)             CP INDICATOR
         GBLC  &RCPPRE
         LCLB  &GEN
         LCLC  &C
&NAME    DS    0H
         AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF(1)' EQ 'E').EXEC
         MNOTE 4,'&MF(1) IS AN INVALID MF, MF=G USED'
.GEN     LA    R1,FAIL&SYSNDX     LOAD PLIST ADDRESS
&GEN     SETB  1
         AGO   .L
.EXEC    AIF   ('&MF(2)' NE '').LISTOK
         MNOTE 8,'LIST ADDRESS NOT SPECIFIED'
         MEXIT
.LISTOK  AIF   ('&MF(3)' EQ '').TMF2
&MF(3)   EQU   24                      LENGTH OF PARAMETER LIST
.TMF2    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').L
         AIF   ('&MF(2)'(1,1) EQ '(').REG
         LA    R1,&MF(2)          LOAD DAIRFAIL PARAM LIST ADDRESS
         AGO   .L
.REG     ANOP
&C       SETC  '&MF(2)'(2,K'&MF(2)-2)
         LR    R1,&C              LOAD DAIRFAIL PARAM LIST ADDR
.L       AIF   ('&RB'(1,1) EQ '(').RBR
         AIF   ('&RB' NE '').RBA
         MNOTE 8,'REQ BLOCK ADDRESS NOT SPECIFIED'
         MEXIT
.RBR     ST    &RB(1),0(R1)       STORE S99 RB ADDRESS
         AGO   .RC
.RBA     LA    R14,&RB            LOAD ADDRESS OF REQ BLOCK
         ST    R14,0(R1)          AND STORE IN PLIST
.RC      AIF   ('&RC'(1,1) EQ '(').RCR
         LA    R14,&RC            LOAD ADDRESS OF RET CODE
         ST    R14,4(R1)          AND STORE IN PLIST
         AGO   .EFF02
.RCR     ANOP
.GRC     LA    R14,20(R1)         LOAD ADDR RET CODE FLD
         ST    &RC(1),0(R14)      STORE RET CODE
         ST    R14,4(R1)          AND STORE ITS ADDRESS
.EFF02   LA    R14,=A(0)          LOAD ADDR OF FULLWORD OF 0
         ST    R14,8(R1)          STORE IT.
         AIF   ('&CP' EQ 'YES' OR &RCPCPPL(1)).CPID
         LA    R14,=X'8032'       LOAD ADDRESS OF CALLERID
         ST    R14,12(R1)          AND STORE IT
         XC    16(4,R1),16(R1)    CLEAR CPPL POINTER
         AGO   .GO
.CPID    LA    R14,=Y(50)         LOAD ADDRESS OF CALLERID
         ST    R14,12(R1)         AND STORE IT
         AIF   ('&CPPL' EQ '').DCPPL
         AIF   ('&CPPL'(1,1) EQ '(').RCPPL
         LA    R14,&CPPL          LOAD CPPL ADDRESS
         ST    R14,16(R1)          AND STORE IT
         AGO   .GO
.DCPPL   MVC   16(4,R1),&RCPPRE.CPPL MOVE IN CPPL ADDRESS
         AGO   .GO
.RCPPL   ST    &CPPL(1),16(R1)    STORE ADDRESS OF CPPL
.GO      LINK  EP=IKJEFF18
         AIF   (NOT &GEN).EXIT
         SPACE 1
         RCPDS
&C SETC 'FAIL&SYSNDX'
&C       DS    6F             RESERVE SPACE FOR PARAM LIST
         RCPDS
.EXIT    MEND
./       ADD   NAME=VTCALL
         MACRO
&LAB     VTCALL &RTN,&TEST
&LAB     LA    R1,VTOCOM      POINT TO THE COMMON AREA
         L     R15,VAD&RTN    POINT TO THE ROUTINE
         AIF ('&TEST' NE 'TEST').NOTEST
         LTR   R15,R15       SEE IF THE ROUTINE IS PRESENT
         BZ    *+6           DON'T CALL IT IF IT'S NOT THERE
.NOTEST  ANOP
         BALR  R14,R15        THEN CALL IT
         MEND
./       ADD   NAME=VTFMT
         MACRO
         VTFMT
*
*        THIS DSECT DESCRIBES THE FORMATTED DSCB
*
VTFMT    DSECT
VTFNEXT  DS    A              POINTER TO NEXT DSCB
VTFALLOC DS    F              ALLOCATION IN UNITS AS DEFINED BY THE
*                               COMMAND.  KBYTES, MBYTES, TRACKS, OR
*                               CYLS MAY BE THE UNIT.
VTFUSED  DS    F                AMOUNT USED, SAME UNIT
VTFUNUSD DS    F                AMOUNT UNUSED, SAME UNIT
VTFPCT   DS    H                PERCENT USED,  0-100
VTFVOLUM DS    CL6            VOLUME SERIAL NUMBER
VTFCREDT DS    XL3            CREATION DATE YYDDD
VTFEXPDT DS    XL3            EXPIRATION DATE YYDDD
VTFLSTAC DS    XL3            LAST ACCESS DATE YYDDD
VTFNOEPV DS    AL1            NUMBER OF EXTENTS PER VOLUME
VTFDSORG DS    CL3            DATA SET ORGANIZATION
*                               PS, PO, DA, VS, IS, PERHAPS U
VTFRECFM DS    CL5            RECORD FORMAT
*                               F,V, OR U, B, T, S, A, M
VTFLRECL DS    H              LOGICAL RECORD LENTGH
VTFBLKSZ DS    H              BLOCK SIZE
VTFROUND DS    C             R IF ROUND WAS SPECIFIED
VTFPROT  DS    C              PASSWORD PROTECTION FLAG
VTFCATLG DS    C              CATALOG INDICATION
VTFSECAM DS    XL2           SECONDARY AMOUNT
VTFSECAL DS    C              SECONDARY ALLOCATION TYPE
*                               C FOR CYL, T FOR TRKS, B FOR BLOCKS
*                               R FOR BLOCKS WITH ROUND
VTFDSTYP DS    C              DATA SET TYPE, USER MAY DEFINE
*                               S = SYSTEM TEMPORARY DATA SET
*                               T = TEST DATA SET
*                               P = PRODUCTION DATA SET
VTFACTON DS    CL8            REQUESTED ACTION OR COMMENT
VTFDSNL  DS    H              LENGTH OF DSNAME
VTFMTL   EQU   *-VTFMT        FIXED LENGTH OF THIS DSECT
VTFDSN   DS    44C            VARIABLE LENGTH FIELD
         MEND
./       ADD   NAME=VTOCMSG
         MACRO
&LAB     VTOCMSG &MSG1,&MSG2    FIRST LEVEL MESSAGE, OPTIONAL SECOND
&LAB     LA    R1,&MSG1       POINT TO THE FIRST MESSAGE
         AIF   ('&MSG2' EQ '').NOSEC  IF NO SECOND LEVEL MSG
         LA    R0,&MSG2       POINT TO THE SECOND MESSAGE
         AGO   .SETMSG        SET UP THE MESSAGES
.NOSEC   SR    R0,R0          NO SECOND LEVEL MESSAGE
.SETMSG  STM   R0,R1,MSGADDRS SAVE THE MESSAGE ADDRESSES
*        THEN JUST CALL THE MESSAGE ISSUING ROUTINE
         VTCALL MSG           AWAY WE GO
         MEND
./       ADD   NAME=VTOCOM
         MACRO
         VTOCOM  &TYPE
*
*        THIS IS THE VTOC COMMAND COMMON AREA
*
         AIF   ('&TYPE' EQ 'NODSECT').NODSECT
VTOCOM   DSECT
         AGO   .NODS
.NODSECT ANOP
VTOCOM   DS    0D
.NODS    ANOP
*
*        WORKING STORAGE AREAS FOR THE VARIOUS ROUTINES
*
VTCWMSG  DS    A              WORKING STORAGE FOR THE MSG  ROUTINE
VTCWEXIT DS    A              WORKING STORAGE FOR THE EXIT ROUTINE
VTCWEXCP DS    A              WORKING STORAGE FOR THE EXCP ROUTINE
VTCWCHEK DS    A              WORKING STORAGE FOR THE CHEK ROUTINE
VTCWFORM DS    A              WORKING STORAGE FOR THE FORM ROUTINE
VTCWPRNT DS    A              WORKING STORAGE FOR THE PRNT ROUTINE
VTCWSORT DS    A              WORKING STORAGE FOR THE SORT ROUTINE
*
*        ADDRESSES OF THE ROUTINES
*
VADMSG   DC    V(VTOCMSG)     ADDRESS OF THE MESSAGE ROUTINE
VADEXIT  DC    V(VTOCEXIT)    ADDRESS OF THE EXIT ROUTINE
VADEXCP  DC    V(VTOCEXIT)    ADDRESS OF THE EXCP ROUTINE
VADCHEK  DC    V(VTOCEXIT)    ADDRESS OF THE CHECK ROUTINE
VADFORM  DC    V(VTOCEXIT)    ADDRESS OF THE FORMAT ROUTINE
VADPRNT  DC    V(VTOCEXIT)    ADDRESS OF THE PRINT ROUTINE
VADSORT  DC    V(VTOCEXIT)    ADDRESS OF THE SORT ROUTINE
*
*        TSO COMMAND PROCESSOR AND PARSE DATA
*
ADDRUPT  DS    A              USER PROFILE TABLE
ADDRECT  DS    A              ENVIRONMENT CONTROL TABLE
ADDRPSCB DS    A              PROTECTED STEP CONTROL BLOCK
ADDRCBUF DS    A              COMMAND BUFFER
         SPACE
ADDRANSR DS    A              PARSE ANSWER OR PDL ADDRESS
         SPACE
PARMLIST DS    8A             INTERNAL PARM AREA ( MSG )
ATTNECB  DS    F              ECB FOR ATTENTIONS
DOUBLE   DS    D
         SPACE
MSGADDRS DS    2A             ADDRESSES OF MESSAGES FOR VTOCMSG
MSGTEXT1 DS    XL124
MSGTEXT2 DS    XL124
         SPACE 3
PUTOLD1  DS    3F
PUTOLD2  DS    3F
*
*        PARAMETER LIST FOR THE EXIT ROUTINE
*
EXITLIST DS    0F
EXITAREA DS    A       WORKAREA LOCATION
DSCBADDR DS    A       ADDRESS OF THE DSCB
FORMATAD DS    A       ADDRESS OF THE FORMATTED DSCB
CPPLADDR DS    A       ADDRESS OF THE CPPL
ACTIONAD DS    A       ADDRESS OF THE RECOMMENDED OR REQUESTED ACTION
*
*        INTER ROUTINE FLAGS
*
VTCEFUNC DS    X              VTOCEXCP FUNCTION FLAG
VTCFMTCK DS    X              FORMAT IS CALLED BY CHECK RTN
VTCFMTCD EQU   X'80'          FORMAT WAS CALLED BY CHECK
VTCFMTCC EQU   X'08'          FORMAT WAS CALLED BY CHECK THIS CALL
*
TABFULL  DS    X             FLAG TABLES FULL, STOP INPUT
LOCAT    DS    X              FLAG TO PERFORM CATALOG LOCATE
VTCEPRNT DS    X               PRINT END AND CLEANUP FLAG
DSNLEN   DS    H              LENGTH OF THE DSNAME (NON-BLANKS)
ATABTITL DS    A              ADDRESS OF TABLE OF TITLES, LENGTHS
*
*
*
*        WORKING STORAGE FOR VOLUME UCB SEARCH
*
ADDR     DS    CL3     UCB ADDRESS IN CHARACTERS
VOLSER   DS    CL6     VOLUME SERIAL NUMBER FROM PARSE
VOLID    DS    CL6     CURRENT VOLUME SERIAL NUMBER TO PROCESS
FLAG     DS    X       UCB SEARCH FLAG
LASTADR  DS    F       LAST UCB ADDRESS FOUND ( NO DUP'S )
*
*
*
SORTTAB  DS    16F
*
* EACH ENTRY CONTAINS A KEY OFFSET (2 BYTES) AND A KEY LENGTH (2 BYTES)
* THIS TABLE IS BUILT AT PARSE TIME ACCORDING TO THE SORT PARAMETERS
* SPECIFIED. THE 1ST PARM IS THE HIGH KEY AND SO ON.
*
*
*
*        ADDRESSES OF GETMAIN FOR FORMATTED DATA
*
VTCCURAD DS    A             CURRENT AVAILABLE ADDRESS
VTCCURLN DS    A             CURRENT AVAILABLE LENGTH
VTCGETMN DS    50A           ADDRESSES OF BLOCKS
VTCGETMX EQU  (*-VTCGETMN)/4  NUMBER OF BLOCKS  MAXIMUM
VTCGETMS EQU   32768          GETMAIN SIZE
*
*        HASH SORT TABLE, POINTERS TO FIRST ENTRIES
*
VTCSORTH DS    256A           POINT TO FORMATED ENTRIES
VTCSORTE EQU   *              END OF LIST
*
*        PRINT ENTRIES - PAGE AND LINE COUNTERS
*
LINECT   DS    H              LINE COUNT
LINEMAX  DS    H              MAXIMUM LINES PER PAGE
PAGECT   DS    H              PAGE COUNT
LINELEN  DS    H              LENGTH OF THE PRINT LINE
*
*
*          VARIOUS ITEMS
*
FMT4     DS    XL44           SPACE FOR DSCB NAME
         IECSDSL1 4          SAVE EACH FORMAT 4 DSCB
         DS    0D
FMT3     DS    0XL148         SPACE FOR FORMAT3 DSCB
         IECSDSL1 3
         DS    0D
         MEND
./       ADD   NAME=VTOCPARS
         PUSH  PRINT
         PRINT NOGEN
PCLMAIN  IKJPARM DSECT=PDL
         SPACE 2
VOLS     IKJPOSIT DSNAME,VOLSER,LIST,                                  $
               PROMPT='VOLUMES TO SEARCH AND OTHER PARAMETERS',        $
               HELP=('VOLUME SERIAL NUMBERS WHICH ARE TO BE SEARCHED FO$
               DATA SETS TO LIST')
         SPACE 2
LEVKEY   IKJKEYWD
         IKJNAME 'LEVEL',SUBFLD=SUBLEV
         SPACE 2
ENDKEY   IKJKEYWD
         IKJNAME 'ENDING',SUBFLD=SUBEND
         SPACE 2
CONTAINK IKJKEYWD
         IKJNAME 'CONTAINING',SUBFLD=SUBCONT
         SPACE 2
         SPACE 2
SPACEK   IKJKEYWD DEFAULT='TRKS'
         IKJNAME 'TRKS'
         SPACE 2
CATK     IKJKEYWD
         IKJNAME 'CAT'
         SPACE 2
SORTK    IKJKEYWD
         IKJNAME 'SORT',SUBFLD=SUBSORTS
         IKJNAME 'NOSORT'
         SPACE 2
BREAKK   IKJKEYWD
         IKJNAME 'BREAK',SUBFLD=SUBBREAK
         SPACE 2
LIMITK   IKJKEYWD
         IKJNAME 'LIMIT',SUBFLD=SUBLIMIT
         SPACE 2
ANDOR1K  IKJKEYWD
         IKJNAME 'AND1',SUBFLD=SUBAO1,ALIAS='AND'
         IKJNAME 'OR1',SUBFLD=SUBAO1,ALIAS='OR'
         SPACE 2
ANDOR2K  IKJKEYWD
         IKJNAME 'AND2',SUBFLD=SUBAO2
         IKJNAME 'OR2',SUBFLD=SUBAO2
         SPACE 2
ANDOR3K  IKJKEYWD
         IKJNAME 'AND3',SUBFLD=SUBAO3
         IKJNAME 'OR3',SUBFLD=SUBAO3
         SPACE 2
PRINTK   IKJKEYWD
         IKJNAME 'PRINT',SUBFLD=SUBPRINT
         IKJNAME 'NOPRINT'
         SPACE 2
CHARSK   IKJKEYWD
         IKJNAME 'CHARS',SUBFLD=SUBCHARS
         SPACE 2
LINESK   IKJKEYWD
         IKJNAME 'LINES',SUBFLD=SUBLINES
         SPACE 2
HEADK    IKJKEYWD
         IKJNAME 'HEADING',SUBFLD=SUBHEAD
         IKJNAME 'NOHEADING'
         SPACE 2
TOTALK   IKJKEYWD
         IKJNAME 'TOTALS',SUBFLD=SUBTOTAL
         SPACE 2
OUTPUTK  IKJKEYWD
         IKJNAME 'OUTPUT'
         SPACE 2
FORMATK  IKJKEYWD
         IKJNAME 'FORMAT',SUBFLD=SUBFORMT
         SPACE 2
DSNPLNK  IKJKEYWD
         IKJNAME 'DSNLEN',SUBFLD=SUBDSNLN
         SPACE 5
SUBLEV   IKJSUBF
LEVEL    IKJPOSIT DSNAME,LIST,                                         X
               PROMPT='BEGINNING CHARACTERS OF DSNAMES TO PROCESS'
         SPACE 2
SUBEND   IKJSUBF
ENDING   IKJPOSIT DSNAME,LIST,                                         X
               PROMPT='ENDING CHARACTERS OF DSNAMES TO PROCESS'
         SPACE 2
SUBCONT  IKJSUBF
CONTAIN  IKJPOSIT DSNAME,LIST,                                         X
               PROMPT='CHARACTER STRING CONTAINED IN DSNAMES TO PROCESSX
               '
         SPACE 2
SUBSORTS IKJSUBF
SUBSORT  IKJIDENT 'SORT FIELDS',LIST,FIRST=ALPHA,MAXLNTH=6
         SPACE 2
SUBBREAK IKJSUBF
BREAK    IKJIDENT 'NUMBER OF CHARACTERS FOR A BREAK',FIRST=NUMERIC,    X
               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='3'
         SPACE 2
SUBCHARS IKJSUBF
CHARSPL  IKJIDENT 'NUMBER OF CHARACTERS PER LINE   ',FIRST=NUMERIC,    X
               OTHER=NUMERIC,MAXLNTH=3
BLKSZSET IKJIDENT 'PHYSICAL BLOCK SIZE',FIRST=NUMERIC,OTHER=NUMERIC,   X
               MAXLNTH=5
         SPACE 2
SUBLINES IKJSUBF
LINESPP  IKJIDENT 'NUMBER OF LINES PER PAGE        ',FIRST=NUMERIC,    X
               OTHER=NUMERIC,MAXLNTH=3
         SPACE 2
SUBPRINT IKJSUBF
SUBPRTKY IKJIDENT 'ADD, REP, NEW, OR DEL',                             X
               FIRST=ALPHA,OTHER=ALPHA,MAXLNTH=3
SUBPRTIT IKJIDENT 'ITEMS TO PRINT',LIST,FIRST=ALPHA,MAXLNTH=6
         SPACE 2
SUBHEAD  IKJSUBF
HEADING  IKJPOSIT QSTRING
         SPACE 2
SUBTOTAL IKJSUBF
TOTALN   IKJIDENT 'NUMBER OF CHARACTERS FOR TOTALS',FIRST=NUMERIC,     X
               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='0'
         SPACE 3
SUBLIMIT IKJSUBF
SUBLKEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X
               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8
         SPACE 2
SUBLOPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X
               MAXLNTH=2,                                              X
               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'
         SPACE 2
SUBLVALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X
               OTHER=ALPHANUM,                                         X
               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'
         SPACE 3
SUBAO1   IKJSUBF
SUB1KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X
               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8
         SPACE 2
SUB1OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X
               MAXLNTH=2,                                              X
               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'
         SPACE 2
SUB1VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X
               OTHER=ALPHANUM,                                         X
               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'
         SPACE 2
SUBAO2   IKJSUBF
SUB2KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X
               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8
         SPACE 2
SUB2OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X
               MAXLNTH=2,                                              X
               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'
         SPACE 2
SUB2VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X
               OTHER=ALPHANUM,                                         X
               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'
         SPACE 2
SUBAO3   IKJSUBF
SUB3KEY IKJIDENT 'FIELD IN DATA SET CONTROL BLOCK TO COMPARE',         X
               FIRST=ALPHA,OTHER=ALPHANUM,MAXLNTH=8
         SPACE 2
SUB3OPER IKJIDENT 'OPERATOR FOR COMPARISON',FIRST=ALPHA,OTHER=ALPHA,   X
               MAXLNTH=2,                                              X
               PROMPT=' OPERATORS ARE EQ, NE, LT, LE, GT, AND GE'
         SPACE 2
SUB3VALU IKJIDENT 'COMPARISON VALUE',FIRST=ALPHANUM,                   X
               OTHER=ALPHANUM,                                         X
               PROMPT='VALUE TO COMPARE FOR DATA SET KEYWORDS'
         SPACE 2
SUBFORMT IKJSUBF
FORMATSP IKJIDENT 'FORMAT TYPES TO OUTPUT',LIST,FIRST=NUMERIC,         X
               MAXLNTH=1,DEFAULT='1'
         SPACE 2
SUBDSNLN IKJSUBF
DSNPLN   IKJIDENT 'LENGTH OF DSNAME TO PRINT',FIRST=NUMERIC,           X
               OTHER=NUMERIC,MAXLNTH=2,DEFAULT='44'
DSNLNTYP IKJKEYWD DEFAULT='TRUNCATE'
         IKJNAME 'TRUNCATE'
         IKJNAME 'MULTILINE'
         IKJENDP
         SPACE 2
         POP   PRINT
ACTION   EQU   1
VOLUME   EQU   2
CDATE    EQU   3
LSTUS    EQU   4
EXPDT    EQU   5
ALLOC    EQU   6
UNUSED   EQU   7
PCT      EQU   8
EXT      EQU   9
DSORG    EQU   10
RECFM    EQU   11
BLKSZ    EQU   12
LRECL    EQU   13
PASS     EQU   14
CAT      EQU   15
SECT     EQU   16
SECQ     EQU   17
UNIT     EQU   18
ROUND    EQU   19
TYPE     EQU   20
USED     EQU   21
CCHH     EQU   22
DUMMY3   EQU   23
DUMMY4   EQU   24
DUMMY5   EQU   25
DSNAME   EQU   26
./ ENDUP
/*
//*----------------------------------------------------------- LOADMACS
//*
//IEBUPDTE.SYSIN DD *
./       ADD   NAME=VTOC
)F FUNCTION -
  THE VTOC COMMAND DISPLAYS SELECTED DATA SETS ON A DISK OR SET OF
  DISKS.  EACH DISK HAS A VOLUME TABLE OF CONTENTS ( VTOC ).  THIS
  TABLE IS SEARCHED FOR DATA SETS THAT MEET THE SPECIFICATIONS.
)X SYNTAX -
         VTOC     'VOLUME-LIST'           LEVEL('DSNAME-START')
                                          CONTAINING('DSNAME-STRING')
                                          ENDING('DSNAME-END')
                                          BREAK('BREAK-CHARS')
                  CAT
                  NOSORT/SORT('SORT-FIELDS')
                  NOPRINT/PRINT('PRINT-OP' ('PRINT-ITEM-LIST'))
                  LIMIT('KEYWORD' 'OPER' 'VALUE')
                  AND1/OR1('KEYWORD' 'OPER' 'VALUE')
                  AND2/OR2('KEYWORD' 'OPER' 'VALUE')
                  AND3/OR3('KEYWORD' 'OPER' 'VALUE')
                  CHARS('CHARS-PER-LINE')
                  LINES('LINES-PER-PAGE')
                  NOHEADING/HEADING('TEXT')
                  DSNLEN('LENGTH')
  REQUIRED - 'VOLUME-LIST'
  DEFAULTS - LIST ALL DATA SETS ON THE VOLUME(S) SELECTED.
             SORT, PRINT
)O OPERANDS -
))'VOLUME-LIST'     - A VOLUME SERIAL NUMBER OR A LIST OF VOLUMES.
              IF THE FIRST ONE TO FIVE CHARACTERS OF A VOLUME
              SERIAL NUMBER ARE ENTERED, ALL VOLUMES THAT ARE
              MOUNTED ON THE MACHINE WHICH START WITH THOSE
              CHARACTERS WILL BE LISTED.
              IF 'ALL' IS SPECIFIED, ALL NON-VIRTUAL VOLUMES
              WHICH ARE ONLINE AND READY WILL BE PROCESSED.
              IF 'ALV' IS SPECIFIED, ALL VIRTUAL VOLUMES
              WHICH ARE ONLINE AND READY WILL BE PROCESSED,
              IF THEY ARE MOUNTED PRIVATE/RESERVED OR
              PRIVATE/RESIDENT.
))LEVEL('DSNAME-START')  - SPECIFIES THE HIGH LEVEL QUALIFIERS TO BE
         SEARCHED.  THIS WILL NOT BE PREFIXED BY YOUR USERID OR
         PREFIX.  ONLY DATA SETS STARTING WITH THESE PREFIXES WILL
         BE LISTED.
))CONTAINING('DSNAME-STRING') - SPECIFIES A CHARACTER STRING CONTAINED
         IN THE DATA SET NAME.  AT LEAST ONE OF THE STRINGS MUST
         BE IN THE DSNAME FOR THE DATA SET TO BE LISTED.
         THESE STRINGS MUST CONFORM TO DSNAME STANDARDS.
         THEY CANNOT BEGIN WITH A PERIOD OR A NUMBER.
))ENDING('DSNAME-END')  - SPECIFIES THE ENDING CHARACTERS OF THE
         DSNAME.  THE FINAL NONBLANK CHARACTERS OF THE DSNAME MUST
         BE ONE OF THESE STRINGS TO ALLOW THE DATA SET TO BE LISTED.
         THESE STRINGS MUST CONFORM TO DSNAME STANDARDS.
))CAT      -  A LOCATE IS DONE FOR EACH DSNAME ON THE VOLUMES LISTED
         AND STATUS IS INDICATED.  NOTE -  THIS OPTION USES A
         CONSIDERABLE AMOUNT OF PROCESSING TIME.
         C -  CATALOGGED ON THIS VOLUME
         N -  NOT CATALOGGED
         W -  CATALOGGED ON ANOTHER VOLUME
         E -  CATALOG PROCESSING ERROR
))NOSORT   -  THE DATA SETS ARE NOT SORTED.  THEY ARE OUTPUT AS THEY
              ARE FOUND.
))SORT('SORT-FIELDS') DATA SETS ARE SORTED INTO ALPHABETICAL ORDER,
              BASED UPON THE SORT FIELDS SPECIFIED.
              DSNAME,VOLUME,ALLOC,USED,UNUSED,PCT,EX,DSO,RFM,
              LRECL,BLKSZ,CDATE,EXPDT,REFDT ARE VALID SORT FIELDS.
              'A/D'   ARE REQUIRED AFTER EACH SORT FIELD TO INDICATE
              ASCENDING/DESCENDING SEQUENCE.
))BREAK('BREAK-CHARS') - THE LISTING WILL CONTAIN A NEW HEADER,
              ( ON A NEW PAGE IF THE VTOCOUT DD CARD OPTION IS USED ),
              WHENEVER THE SPECIFIED NUMBER OF CHARACTERS DIFFERS
              FROM THE PRECEDING DATA SET.  THIS OPTION FUNCTIONS
              ONLY WITH THE SORT OPTION.
))CHARS('CHARS-PER-LINE') - SPECIFIES THE NUMBER OF CHARACTERS ON EACH
              LINE OF OUTPUT.  THE DEFAULT IS 150 FOR PRINT AND THE
              LINESIZE OF THE TERMINAL FOR TSO SESSIONS.
              YOU CAN GET MORE INFORMATION BY SPECIFYING A LARGER
              NUMBER OF CHARACTERS PER LINE OR YOU CAN LIMIT THE
              PRINTING BY SETTING A SMALLER NUMBER OF CHARACTERS
              PER LINE OF OUTPUT.
))LINES('LINES-PER-PAGE') - SPECIFIES THE NUMBER OF LINES BEFORE A NEW
              TITLE LINE IS PRODUCED.  IT DEFAULTS TO 60 FOR PRINT
              AND TO THE SCREEN SIZE FOR TSO SESSIONS.
))NOHEADING   - DO NOT PRODUCE A HEADING.  THE HEADING WILL ONLY BE
              OUTPUT IF THE VTOCOUT DD STATEMENT IS PRESENT.
))HEADING('TEXT') - IF A DD STATEMENT WITH A DDNAME OF VTOCOUT IS
              PRESENT, THIS TEXT WILL BE USED TO BEGIN EVERY PAGE.
              CARRIAGE CONTROL SHOULD BE INCLUDED ( ASA ).  THE
              DEFAULT HEADER CONSISTS OF VTOC COMMAND VERSION 02
              AND THE COMMAND THAT WAS ENTERED.
))DSNLEN('LENGTH') - SPECIFIES THE LENGTH OF THE DSNAME TO PRINT.
              THE REST OF THE DSNAME IS TRUNCATED.  THE CHARS PARAMETER
              WILL ALSO CAUSE THE DSNAME TO BE TRUNCATED, IF THE NAME
              AND THE PRECEDING INFORMATION EXCEEDS THE PRINT LINE.
))NOPRINT     - SPECIFIES THAT INDIVIDUAL ITEMS ARE NOT TO BE LISTED.
              THE COMMAND CAN BE USED TO CALCULATE TOTALS.
))PRINT('PRINT-OP' ('PRINT-ITEM-LIST')) -
              SPECIFIES THE ITEMS TO PRINT.  THE 'PRINT-OP' IS THE
              OPERATION TO BE DONE.  THEY INCLUDE THE FOLLOWING.
                NEW - THE 'PRINT-ITEM-LIST' IS A COMPLETE LIST OF WHAT
                      TO PRINT.
                REP - THE FIRST 'PRINT-ITEM' WILL BE REPLACED WITH THE
                      REST OF THE ITEMS ON THE LIST.
                ADD - THE REST OF THE 'PRINT-ITEM-LIST' WILL BE ADDED
                      AFTER THE FIRST ITEM ON THE LIST.
                DEL - THE ITEMS ON THE 'PRINT-ITEM-LIST' WILL NOT BE
                      PRINTED.
              THE 'PRINT-ITEM-LIST' NAMES ARE THE SAME KEYWORDS USED
              IN LIM, AND, AND OR FUNCTIONS AND ARE ALSO THE TITLES
              AS PRINTED.
              THE ADD, DEL, AND REP PRINT OPERATIONS REFER TO THE
              DEFAULT PRINT LIST.  THE DEFAULT LIST IS ALLOC, UNUSED,
              PCT, EX, DSO, RFM, BLKSZ, LRECL, REFDT, CDATE, VOLUME,
              DSNAME, EXPDT, SECQ, SECT, ROUND, PASS, ACTION,
              AND TYPE.  AS NOTED UNDER CHARS ABOVE, ONLY THE ITEMS
              THAT WILL FIT ON THE PRINT LINE WILL BE LISTED.
))LIMIT('VALUE' 'OPER' 'KEYWORD') - SPECIFIES WHICH DATA SETS ARE TO
              BE LISTED.  ONLY DATA SETS THAT SATISFY THE RELATION
              ARE LISTED.
))'KEYWORD'   - IS THE NAME OF A DATA SET FIELD.  THE LIST OF CURRENTLY
                PROVIDED FIELDS FOLLOWS.  THE KEYWORDS AND THEIR VALUES
                ARE THE SAME AS IN THE VTOC OUTPUT.

                      ALLOC      DATA SET ALLOCATION
                                    NUMBER OF KILOBYTES, TRACKS,
                                    CYLINDERS, OR MEGABYTES ALLOCATED.
                                    DEFAULT IS KILOBYTES.
                      UNUSED     AMOUNT OF UNUSED SPACE IN THE DATA
                                    SET.  SAME UNITS AS IN ALLOC.
                      USED       AMOUNT OF SPACE USED IN THE DATA SET.
                                    SAME UNITS AS IN ALLOC.
                      PCT        PERCENTAGE OF SPACE USED IN THE DATA
                                    USED.
                      EX         NUMBER OF EXTENTS IN THE DATA SET.
                      DSO        DATA SET ORGANIZATION
                                    PS = SEQUENTIAL   PO = PARTITIONED
                                    VS = VSAM         IS = ISAM
                                    DA = DIRECT ACCESS  U = UNMOVEABLE
                      RFM        RECORD FORMAT
                                    F  = FIXED        V  = VARIABLE
                                    U  = UNDEFINED    B  = BLOCKED
                                    T  = TRACK OVERFLOW
                                    S  = SPANNED OR STANDARD
                                    A  = ASA CARRIAGE CONTROL
                                    M  = MACHINE CARRIAGE CONTROL
                      BLKSZ      BLOCKSIZE FOR PHYSICAL BLOCKS OF
                                    DATA.
                      LRECL      LOGICAL RECORD LENGTH IN BYTES.
                      CDATE      CREATION DATE IN THE FORM YYDDD,
                                    SOMETIMES CALLED JULIAN.
                      EXPDT      EXPIRATION DATE IN THE SAME FORM.
                                    THIS FIELD IS RARELY USED HERE.
                      REFDT      LAST USE DATE IN THE SAME FORM.
                                    THIS DATE IS WHEN THE DATA SET WAS
                                    LAST OPENED.
                      SECT       TYPE OF ALLOCATION
                                    A  = ABSOLUTE TRACK
                                    B  = BLOCKS
                                    T  = TRACKS
                                    C  = CYLINDERS
                      PASS       PROTECTION INDICATORS
                                    N  = NONE
                                    R  = READ AND WRITE PROTECTION
                                    W  = WRITE PROTECTION
                      ROUND      SPACE ROUNDED UP TO CYLINDERS
                                    R  = ROUND
                                    N  = NO ROUND
                      CCHH       CYLINDER AND HEAD ADDRESS, IN 4 OR 8
                                    HEXADECIMAL DIGITS.  IF 4 DIGITS
                                    ARE USED, ONLY THE CYLINDER IS USED
                                    FOR COMPARISON, OTHERWISE, THE CYL
                                    AND TRACK ARE COMPARED.
                      VOLUME     VOLUME SERIAL NUMBER OR DISK NAME
                      DSNAME     NAME OF THE DATA SET
                      ACTION     SOME ERROR INDICATIONS
                      TYPE       RESERVED FOR EXIT USAGE.
))'OPER'      - IS AN OPERATOR.  THE LIST OF OPERATORS FOLLOWS.
                        EQ       IS EQUAL TO
                        NE       IS NOT EQUAL TO
                        LE       IS LESS THAN OR EQUAL TO
                        LT       IS LESS THAN
                        GE       IS GREATER THAN OR EQUAL TO
                        GT       IS GREATER THAN
))'VALUE'     - GIVES THE VALUE OF THE ITEM FOR COMPARISON, SUCH AS
              FB, PS, R, OR A NUMBER.
))AND1('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  BOTH THE LIMIT AND THIS CONDITION MUST
                 BE TRUE TO ALLOW THE LISTING.
))OR1('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  EITHER THE LIMIT OR THIS CONDITION MUST
                 BE TRUE TO ALLOW THE LISTING.
))AND2('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  BOTH THE PREVIOS RESULT AND THIS
                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.
))OR2('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  EITHER THE PREVIOUS RESULT OR THIS
                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.
))AND3('VALUE' 'OPER' 'KEYWORD') -  SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  BOTH THE PREVIOS RESULT AND THIS
                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.
))OR3('VALUE' 'OPER' 'KEYWORD') -   SPECIFIES WHICH DATA SETS ARE TO
                 BE LISTED.  EITHER THE PREVIOUS RESULT OR THIS
                 CONDITION MUST BE TRUE TO ALLOW THE LISTING.
))EXAMPLES -
  LIST ALL DATA SETS ON VOL             VTOC VOL
  LIST ALL DATA SETS ON ALL VOLUMES     VTOC ALL
  LIST ALL DATA SETS THAT START
     WITH  XXX   ON ANY MVXXXX VOLUME   VTOC MV LEV(XXX)
  LIST ALL RECENTLY CREATED DATA SETS   VTOC VOL LIM(CDATE GT 79001)
  LIST DATA SETS WITH UNUSED SPACE      VTOC VOL LIM(PCT LT 50)  -
                                                OR1(UNUSED GT 30)
  LIST DATA SETS WITH MULTIPLE EXTENTS  VTOC VOL LIM(EX GT 1)
  LIST ALL OF USER'S DATA ON TSO001   VTOC TSO001 LEVEL(TMTCEXX)
  LIST ALL DATA SETS OVER 100 TRKS      VTOC VOL LIM(ALLOC GT 100)
  LIST DATA SETS UNDER THE FIXED HEADS  VTOC VOL LIM(CC EQ 0001) -
                                                 OR1(CC EQ 0002)
  LIST USED SPACE INSTEAD OF UNUSED,
       IN TRACKS.                VTOC VOL PRINT(REP (UNUSED USED)) TRK
  LIST CLIST DATA SETS           VTOC VOL END(CLIST)
  LIST ALL OF THE INFORMATION ABOUT
       USER'S DATA SETS AT A 3270.   VTOC VOL CHAR(150)
  CHECK IF DATASETS ARE CATALOGGED ON THIS VOLUME.
                  VTOC VOL CAT PRINT(NEW (ALLOC PCT CAT DSNAME))
  LIST ALL DATA SETS ON 335XXX VOLUMES SORTED BY ALLOC IN DESCENDING
       SEQUENCE, VOLUME AND DSNAME IN ASCENDING SEQUENCE.
       VTOC 335 SORT(ALLOC,D,VOLUME,A,DSNAME,A)
./ ENDUP
/*
//*----------------------------------------------------------- IEBUPDTE
//*
//ASM1.SYSIN DD *
         TITLE 'VTOC COMMAND - LIST DATA SETS AND ATTRIBUTES'
***********************************************************************
*                                                                     *
*                                                                     *
* TITLE -      VTOC COMMAND - LIST DATA SETS AND ATTRIBUTES           *
*                                                                     *
* FUNCTION -   PROVIDE THE ABILITY FOR A TSO USER OR A BATCH JOB      *
*              TO LIST THE CONTENTS OF VARIOUS VOLUMES, WITH A        *
*              FAIR AMOUNT OF SELECTION.                              *
*                                                                     *
*                                                                     *
* OPERATION -  ACCEPT FROM THE TSO USER OR BATCH JOB A COMMAND        *
*              WITH THE FOLLOWING SYNTAX.  THEN CHECK THE COMMAND     *
*              AND LOOP THROUGH, GETTING A DSCB, FORMATTING IT,       *
*              PERFORMING THE DATA SET NAME AND LIMIT CHECKS, AND     *
*              CALLING AN EXIT ROUTINE IF DESIRED, THEN PUT THE       *
*              ENTRY IN THE CORRECT SORT SEQUENCE.                    *
*              FINALLY CALL THE PRINT ROUTINE TO PRINT THE            *
*              SPECIFIED ITEMS, HEADERS, AND BREAKS, OR JUST          *
*              THE TOTALS.                                            *
*                                                                     *
*                                                                     *
* INPUT -      STANDARD COMMAND PROCESSOR PARAMETER LIST              *
*              POINTED TO BY REGISTER 1                               *
*                                                                     *
*                                                                     *
* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *
*              THEIR ATTRIBUTES.                                      *
*                                                                     *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*              FIREMAN'S FUND INSURANCE  CPSD 2N                      *
*              ONE LUCAS GREEN                                        *
*              SAN RAFAEL, CA  94911                                  *
*                                                                     *
*                                                                     *
***********************************************************************
*
         MACRO
&LABEL   VTOCEXCP  &FUNC
         AIF   ('&FUNC' NE 'EQ').CALL
VTCOPEN  EQU   1              DEFINE FUNCTION CODES FOR VTOCEXCP
VTCCLOSE EQU   2
VTCREAD  EQU   0
         MEXIT
.CALL    ANOP                 CALL VTOCEXCP
&LABEL   MVI   VTCEFUNC,VTC&FUNC   SET THE FUNCTION CODE
         VTCALL EXCP          GO GET A DSCB
         MEND
*
*        MACRO FOR INITIALIZING SUBROUTINE WORK AREA ADDRESSES
*
         MACRO
&LABEL   WORKADDR &RTN,&PRMADDR
&LABEL   L     R1,=A(WORK&RTN-WORKAREA)  GET THE OFFSET ( OVER 4K )
         LA    R1,0(R1,R13)   RELOCATE IT
         ST    R1,&PRMADDR   THEN STORE IT FOR THE ROUTINES
         MEND
*
         EJECT
VTOCCMD  ENTERX 12,(1,LENWORK,C)     DO THE HOUSEKEEPING
         LR    R2,R1          SAVE ADDR OF CPPL
         SPACE
         USING WORKAREA,WORKREG
         EJECT
         BAL   R14,PARSINIT   PERFORM THE PARSING
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   RETURN         BAD NEWS, GET OUT
         VTCALL PRNT         INITIALIZE FOR PRINTING
         L     R9,ADDRANSR    ADDR OF PARSE DESCRIPTOR LIST
         USING PDL,R9         RETURNED BY PARSE
*
*
*        SCAN SORT PARSE LIST AND BUILD SORT FIELD TABLE
*
*
SORTPAR  LA    R4,SUBSORT     SORT PARSE LIST
         LA    R5,SORTTAB     SORT FIELD TABLE
         XC    0(64,R5),0(R5) CLEAR SORT FIELD TABLE
         MVC   0(4,R5),SORTTABX DEFAULT TO DSNAME
         SPACE 1
SORTPAR1 LA    R1,SORTTABX-12 SORT COMPARE TABLE
         SPACE 1
SORTPAR2 LA    R1,12(0,R1)    POINT TO NEXT COMPARE ENTRY
         CLC   0(4,R1),=F'0'  END OF TABLE
         BE    SORTPAR3       ITEM NOT FOUND, IGNORE
         L     R6,0(0,R4)     POINT TO TEXT
         LH    R3,4(0,R4)     TEXT LENGTH
         LTR   R3,R3          IGNORE IF ZERO
         BZ    SORTPAR3
         BCTR  R3,0
         EX    R3,SORTCOMP    FIELD NAME MATCH
         BE    SORTPAR4       YES
         B     SORTPAR2       NO, TRY NEXT
         SPACE 1
SORTPAR3 ICM   R4,7,9(R4)     NEXT ITEM
         BNZ   SORTPAR1       CONTINUE IF MORE
         B     SORTPAR5
         SPACE 1
SORTPAR4 MVC   0(4,R5),0(R1)  SET UP SORT FIELD
         ICM   R4,7,9(R4)     ASCENDING/DESCENDING INDICATOR
         BZ    PARMERR        ERROR IF MISSING
         L     R6,0(0,R4)     INDICATOR ADDR
         CLC   4(2,R4),=F'0'  ERROR IF MISSING
         BE    PARMERR
         MVC   0(1,R5),0(R6)  A/D INDICATOR
         LA    R5,4(0,R5)
         CLI   0(R6),C'A'     ASCENDING SORT
         BE    SORTPAR3       YES, OK
         CLI   0(R6),C'D'     DESCENDING SORT
         BNE   PARMERR        NO, ERROR
         B     SORTPAR3       CHECK IF ANY MORE
         SPACE 1
SORTCOMP CLC   4(0,R1),0(R6)
         SPACE 1
SORTPAR5 LA    R3,SORTKTAB-12 SORT HEADER INDEX TABLE
SORTK1   LA    R3,12(0,R3)    NEXT ENTRY
         CLC   0(4,R3),=F'0'  END OF TABLE
         BE    SORTK3         YES
         CLC   SORTTAB+1(1),1(R3)  ENTRY MATCH
         BNE   SORTK1         NO, CHECK NEXT
         SR    R4,R4
         LH    R5,2(0,R3)     LOAD TABLE LENGTH
         D     R4,=F'12'      TABLE ENTRIES
         LA    R5,1(0,R5)
         LA    R6,VTCSORTH
         L     R4,4(0,R3)     LOAD TABLE BEGIN ADDR
         CLI   SORTTAB,C'D'   DESCENDING SORT
         BE    SORTK2         YES
         L     R4,8(0,R3)     LOAD TABLE END ADDR
SORTK2   MVC   0(12,R6),0(R4)
         LA    R4,12(0,R4)
         LA    R6,12(0,R6)
         CLI   SORTTAB,C'D'   DESCENDING SORT
         BE    *+8            YES
         S     R4,=F'24'
         BCT   R5,SORTK2
         B     SORTK4
SORTK3   MVC   VTCSORTH(12),=3F'0'
SORTK4   MVC   0(12,R6),=3F'0'
*
*        CHECK THROUGH THE UCB'S TO SELECT THE VOLUMES TO PROCESS
*
*
**  FIND A VOLUME SERIAL NUMBER
*
         LA    R3,VOLS        POINT TO THE PDL
LOOP1    L     R5,0(R3)       GET THE ADDRESS OF THE TEXT
         LH    R4,4(R3)       ALSO GET ITS LENGTH
         LTR   R4,R4          FOR EXECUTES, GET THE LENGTH
         BZ    PHASE2         NO MORE VOLUMES, CONTINUE TO NEXT PHASE
         BCTR  R4,0           MAKE IT READY FOR THE EX INSTR
         MVC   VOLSER,BLANKS   INITIALIZE FIELD
         EX    R4,MOVVOL
*
**  VOLUME FOUND - VERIFY AND CHECK FOR GLOBAL OR SPECIAL REQUESTS
*
         CH    R4,H5          IS THE ENTIRE NAME THERE?
         BE    VOLSET         YES, IT'S A SPECIFIC VOLUME
         MVI   FLAG,X'01'     IT'S A GENERIC REQUEST
         CH    R4,H2          CHECK FOR THE ALL KEYWORD, FIRST LENGTH
         BNE   VOLSET         NOT A GLOBAL REQUEST
         CLC   0(3,R5),CHARALV  IS THIS THE KEYWORD 'ALLV'?
         BE    VOLSETV        NO, NOT A GLOBAL REQUEST
         CLC   0(3,R5),CHARALL  IS THIS THE KEYWORD 'ALL'?
         BNE   VOLSET         NO, NOT A GLOBAL REQUEST
         MVI   FLAG,X'02'   GLOBAL REQUEST
         B     VOLSET
*
**  FIND THE A(UCB)
*
VOLSETV  MVI   FLAG,X'82'   GLOBAL REQUEST FOR VIRTUAL
         B     VOLSET
VOLSET   XC    LASTADR,LASTADR CLEAR THE UCB COMPARE ADDRESS
         L     R5,16   A(CVT)
         SR    R6,R6
         L     R5,40(R5)   A(UCB ADDRESSES)
NEXTUCB  ICM   R6,3,0(R5)   A(A UCB)
         LTR   R6,R6   CHECK FOR VALID ENTRIES
         BZ    INCR1   UCB HOLE
         C     R6,FMIN1    CHECK FOR END
         BE    NOTMNT   END OF UCB LIST - VOLUME NOT FOUND
         CLI   18(R6),X'20'   MUST BE DIRECT ACCESS
         BNE   INCR1
         C     R6,LASTADR   UCB ADDRESSES MUST INCREASE
         BNH   INCR1        OTHERWISE THEY REPEAT.
         ST    R6,LASTADR   NEW ADDRESS
         TM    FLAG,X'02'   CHECK FOR GLOBAL
         BO    FNDGBL   IT IS
         TM    FLAG,X'01'   CHECK FOR SPECIAL REQUESTS
         BO    SPECUCB   IT IS
         CLC   VOLSER,28(R6)   COMPARE FULL VOLSER
         BE    FNDUCB   FOUND IT
         B     INCR1
SPECUCB  EX    R4,CLCVOL   COMPARE FIRST X CHARACTERS ONLY
         BE    CHKRDY
INCR1    LA    R5,2(R5)
         B     NEXTUCB   TRY NEXT UCB
*
*        VARIOUS ERRORS, LET THE PERSON KNOW
*
NOTMNT   TM    FLAG,X'04'     WAS A VOLUME  FOUND?
         BO    NEXTVOL        YES, LOOK FOR THE NEXT SPEC
         MVC   MSGTEXT2,MSGNOTMT  NO, GET THE ERROR MESSAGE
SETVOL   MVC   MSGTEXT2+5(6),VOLSER ADD THE VOLUME SERIAL NUMBER
         VTOCMSG MSGTEXT2     AND ISSUE THE MESSAGE
         B     NEXTVOL       GO GET THE NEXT VOLUME FROM PARSE
PENDING  MVC   MSGTEXT2,MSGPEND   SET UP THE MESSAGE
*
*        SEE IF THIS IS A GENERIC OR GLOBAL REQUEST
*
         TM    FLAG,X'03'    WAS IT ALL OR A PARTIAL VOLUME SERIAL?
         BNZ   INCR1         IN EITHER CASE, SKIP THE MESSAGE
*                            THEN FIND MORE VOLUMES
*
*        OUTPUT THE OFFLINE PENDING MESSAGE
         B     SETVOL         THEN ADD THE VOLUME
OFFLINE  MVC   MSGTEXT2,MSGOFFLN SET UP THE MESSAGE
         B     SETVOL         THEN ADD THE VOLUME
*
**  FOR GLOBAL REQUESTS JUST LIST ONLINE PACKS
*
FNDGBL   TM    3(R6),X'80'   ONLINE BIT
         BZ    INCR1   NOPE
*
**  FOR GLOBAL AND SPECIAL REQUESTS, CHECK FOR DEVICE READY
*
CHKRDY   TM    6(R6),X'40'   TEST READY BIT
         BO    INCR1   NOT READY
         TM    FLAG,X'80'   GLOBAL REQUEST FOR VIRTUAL
         BO    CHKVIRT
         TM    FLAG,X'02'   GLOBAL REQUEST
         BZ    FNDUCB
         TM    17(R6),X'08'  VIRTUAL UCB
         BO    INCR1   YES
         B     FNDUCB
CHKVIRT  TM    17(R6),X'08'  VIRTUAL UCB
         BZ    INCR1   NO
*
**  MOVE UCB INFORMATION TO OUTPUT LINE
*
FNDUCB   MVC   VOLID,28(R6)   MOVE VOLID
         MVC   ADDR,13(R6)   MOVE UNIT ADDRESS
         OI    FLAG,X'04'      NOTE THE VOLUME AS FOUND
*
**  IF OFFLINE, DO NOT PROCESS
*
         TM    3(R6),X'40'   PENDING BIT - SHOULD BE OFF
         BO    PENDING
         TM    3(R6),X'80'   ONLINE BIT - SHOULD BE ON
         BZ    OFFLINE
*
*        NOW GET DSCB'S FROM THE VOLUME
*
*
*        SET UP THE PARM LIST FOR VTOCEXCP
*
         VTOCEXCP OPEN        OPEN THE VTOC
         LTR   R15,R15        DID IT OPEN OK?
         BNE   RETURN         NO, JUST EXIT
READDSCB CLI   TABFULL,0     CHECK FOR FULL TABLES
         BNE   ENDVTOC       IF FULL, TRY END OF VTOC TO CLEAR
         VTOCEXCP READ        GET A DSCB
         CH    R15,H4         CHECK THE RETURN CODE
         BE    ENDVTOC        END OF VTOC
         BH    RETURN         BAD ERROR, VTOCEXCP GAVE THE MESSAGE
*
*        CHECK THE DATA SET QUALIFICATIONS, LIMIT, AND, OR
*
         VTCALL CHEK          CALL THE CHECK ROUTINE
         LTR   R15,R15        DOES THIS DATA SET GET PASSED ON?
         BNZ   READDSCB       NO, GET ANOTHER
*                             YES, CONTINUE PROCESSING
*
*        FORMAT THE DSCB INFORMATION
*
         TM    VTCFMTCK,VTCFMTCD WAS FORMAT CALLED BY CHECK?
         BO    CALLEXIT       YES, DON'T CALL IT AGAIN
         VTCALL FORM          CALL THE FORMATTING ROUTINE
         LTR   R15,R15        DID IT FUNCTION?
         BNZ   READDSCB       NO, GET ANOTHER DSCB
*
*        CALL THE EXIT ROUTINE IF ONE WAS SPECIFIED
*
CALLEXIT VTCALL EXIT,TEST     CALL THE EXIT ROUTINE
         LTR   R15,R15        SHOULD THE DATA SET BE PASSED ON?
         BNZ   READDSCB       NO, GET ANOTHER DSCB
*
*        SORT THE ENTRIES INTO THE NEW LIST
*
         VTCALL SORT          CALL THE SORT ROUTINE
         B     READDSCB       GET ANOTHER DSCB
*
*        END OF THE VOLUME, CHECK FOR MORE
*
ENDVTOC  VTOCEXCP CLOSE FIRST CLOSE THE VTOC
*
ENDVOL   TM    FLAG,X'03'         IS THIS A GENERIC VOLUME SEARCH
         BNZ   INCR1              YES, SEARCH FOR MORE
NEXTVOL  ICM   R3,B'0111',25(R3)  GET THE NEXT VOLUME FROM THE PDL
         BP    LOOP1              THERE IS ANOTHER, GET IT
*
*        PRINT THE SELECTED ITEMS FOR THE SELECTED DATA SETS
*
PHASE2   DS    0H
         VTCALL PRNT          CALL THE PRINT ROUTINE
         B     EXIT0
         EJECT
*
*        PROCESSING IS COMPLETE, EXEUNT
*
PARMERR  LA    R15,16
         B     RETURN
EXIT0    SR    R15,R15
         SPACE 3
RETURN   LTR   R2,R15         NORMAL EXIT?
         BZ    RETURN1        YES, LEAVE EVERY THING ALONE
         SPACE 2
         LA    R1,PARMLIST    AREA FOR STACK PARM LIST
         USING IOPL,R1        AN ERROR WAS FOUND, FLUSH THE STACK
         SPACE
         MVC   IOPLUPT,ADDRUPT
         MVC   IOPLECT,ADDRECT
         LA    R0,ATTNECB
         MVI   ATTNECB,0
         ST    R0,IOPLECB
         SPACE 2
         STACK PARM=PARMLIST+16,DELETE=ALL,MF=(E,(1))
         SPACE 3
         TCLEARQ INPUT        CLEAR INPUT BUFFERS
         SPACE 3
RETURN1  DS    0H
         BAL   R14,FREEPDL    FREE THE PARSE STROAGE
         MVI   VTCEPRNT,15    TELL PRINT TO CLEAN UP HIS ACT
*                                CLOSE DATA SETS AND FREE MAIN STORAGE
         VTCALL PRNT          CALL THE PRINT ROUTINE
         SPACE
         LR    R15,R2          GET THE RETURN CODE AGAIN
         LEAVE EQ
WORKREG  EQU   13
*
*        PARSE INITIALIZATION
*
         SPACE 3
PARSINIT DS    0H
         ST    R2,CPPLADDR    AND THE CPPL ADDRESS
         USING CPPL,R2        BASE FOR COMMAND PARM LIST
         MVC   ADDRUPT,CPPLUPT ADDR OF USER PROFILE TABLE
         MVC   ADDRPSCB,CPPLPSCB
         MVC   ADDRECT,CPPLECT ADDR OF ENVIROMENT TABLE
         MVC   ADDRCBUF,CPPLCBUF
         DROP  R2
         SPACE 3
*
*        PUT THE WORK AREA ADDRESSES INTO THE PARM LISTS
*
         WORKADDR MSG,VTCWMSG     WORK AREA FOR VTOCMSG
         WORKADDR EXCP,VTCWEXCP   WORK AREA FOR VTOCEXCP
         WORKADDR CHEK,VTCWCHEK   WORK AREA FOR VTOCCHEK
         WORKADDR FORM,VTCWFORM   WORK AREA FOR VTOCFORM
         WORKADDR EXIT,VTCWEXIT   WORK AREA FOR VTOCEXIT
         WORKADDR SORT,VTCWSORT   WORK AREA FOR VTOCSORT
         WORKADDR PRNT,VTCWPRNT   WORK AREA FOR VTOCPRNT
         SPACE 3
*        SET UP THE ADDRESSES FOR CALLING
*
         MVC   VADMSG(RTNADLEN),RTNADDRS  MOVE IN THE ADDRESSES
*
*
*
*        BUILD PARSE PARAMETER LIST AND INVOKE
*        IKJPARS TO ANALYZE COMMAND OPERANDS
*
         SPACE 3
GOPARSE  DS    0H
         ST    R14,R14PARSE   SAVE THE RETURN ADDRESS
         LA    R1,PARSELST    AREA FOR PARSE PARAMETERS
         USING PPL,R1         BASE FOR PARSE PARAMETER LIST
         SPACE 2
         MVC   PPLUPT,ADDRUPT PASS UPT ADDRESS
         MVC   PPLECT,ADDRECT AND ECT ADDRESS
         MVC   PPLCBUF,ADDRCBUF AND COMMAND BUFFER ADDR
         SPACE
         ST    WORKREG,PPLUWA ALSO WORK AREA ADDR FOR VALIDITY EXITS
         SPACE
         LA    R0,ATTNECB     ECB FOR ATTN INTERRUPTS
         MVI   ATTNECB,0      CLEAR ECB
         ST    R0,PPLECB      PASSE TO PARSE
         SPACE
         LA    R0,ADDRANSR    PASS ADDR OF WORD WHERE PARSE
         ST    R0,PPLANS      RETURNS PDL ADDRESS
         SPACE
         MVC   PPLPCL,ADDRPCL STORE PCL ADDRESS
         SPACE 3
         CALLTSSR EP=IKJPARS  INVOKE PARSE
         DROP  R1
         SPACE 2
         LA    R14,MAXPARSE   RETURN CODE LIMIT
         SPACE
         CR    R15,R14        VERIFY RETURN CODE WITHIN LIMITS
         BH    PARSEBAD       NO, ERROR
         SPACE
         B     *+4(R15)       PROCESS RETURN CODE
         SPACE
PARSERET B     PARSEOK         0- SUCESSFUL
         B     PARSEERR        4- PARSE UNABLE TO PROMPT
         B     PARSEERR        8- USER ENTERED ATTENTION
         B     PARSEBAD       12- INVALID PARAMETERS
         B     PARSEBAD       16- PARSE INTERNAL FAILURE
         B     PARSEERR       20 - VALIDITY CHECK ERROR
MAXPARSE EQU   *-PARSERET
         SPACE 5
PARSEBAD DS    0H
         MVC   MSGTEXT2+4(L'MSGPARSE),MSGPARSE
         LA    R1,MSGTEXT2+4+L'MSGPARSE
         SPACE
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(2,R1),DOUBLE
         SPACE
         LA    R0,MSGTEXT2-2
         SR    R1,R0
         SLL   R1,16
         ST    R1,MSGTEXT2
         SPACE 2
         VTOCMSG MSGCMDER,MSGTEXT2    PUT OUT 'COMMAND ERROR' MSG
         SPACE 3
PARSEERR LA    R15,12         ERROR CODE 12 - COMMAND FAILED
         B     PARSERTN       RETURN FROM PARSE
         SPACE
PARSEOK  SR    R15,R15        CLEAR THE RETURN CODE
PARSERTN L     R14,R14PARSE   GET THE RETURN LOCATION
         BR    R14            AND GET OUT OF HERE
         SPACE
         EJECT
*
*        PARSE CLEANUP ROUTINE
*
         SPACE 3
FREEPDL  DS    0H
         SPACE
         ST    R14,R14SAVE
         SPACE
         IKJRLSA ADDRANSR     RELEASE THE STORAGE
         SPACE 2
         XC    ADDRANSR,ADDRANSR
         SPACE
         L     R14,R14SAVE
         BR    R14
         EJECT
*
*
*        CONSTANTS
*
*
         LTORG
RTNADDRS DC    V(VTOCMSG)
         DC    A(0)           DUMMY ENTRY FOR THE EXIT ROUTINE
         DC    V(VTOCEXCP)
         DC    V(VTOCCHEK)
         DC    V(VTOCFORM)
         DC    V(VTOCPRNT)
         DC    V(VTOCSORT)
RTNADLEN EQU   *-RTNADDRS
ADDRPCL  DC    A(PCLMAIN)     ADDR OF MAIN PARSE CONTROL LIST
FMIN1    DC    X'0000FFFF'    END OF UCB LIST
BLANKS   DC    CL8' '         BALNKS
H2       DC    H'2'
H4       DC    H'4'
H5       DC    H'5'
*
*
*
*
*
CHARALL  DC    CL3'ALL'
CHARALV  DC    CL3'ALV'
MOVVOL   MVC   VOLSER(0),0(R5)
CLCVOL   CLC   VOLSER(0),28(R6)
         EJECT
SORTTABX DC    AL2(VTFDSN-VTFMT),AL2(43),CL8'DSNAME'
         DC    AL2(VTFVOLUM-VTFMT),AL2(5),CL8'VOLUME'
         DC    AL2(VTFALLOC-VTFMT),AL2(3),CL8'ALLOC'
         DC    AL2(VTFUSED-VTFMT),AL2(3),CL8'USED'
         DC    AL2(VTFUNUSD-VTFMT),AL2(3),CL8'UNUSED'
         DC    AL2(VTFPCT-VTFMT),AL2(1),CL8'PCT'
         DC    AL2(VTFNOEPV-VTFMT),AL2(0),CL8'EX'
         DC    AL2(VTFDSORG-VTFMT),AL2(2),CL8'DSO'
         DC    AL2(VTFRECFM-VTFMT),AL2(4),CL8'RFM'
         DC    AL2(VTFLRECL-VTFMT),AL2(1),CL8'LRECL'
         DC    AL2(VTFBLKSZ-VTFMT),AL2(1),CL8'BLKSZ'
         DC    AL2(VTFCREDT-VTFMT),AL2(2),CL8'CDATE'
         DC    AL2(VTFEXPDT-VTFMT),AL2(2),CL8'EXPDT'
         DC    AL2(VTFLSTAC-VTFMT),AL2(2),CL8'REFDT'
         DC    F'0'
         EJECT
*
*        PROGRAM MESSAGES
*
         SPACE 2
         PRINT NOGEN
         SPACE
MSGPARSE MSG   ' PARSE ERROR CODE '
MSGCMDER MSG   ' COMMAND SYSTEM ERROR'
MSGNOTMT MSG   ' VVVVVV VOLUME IS NOT MOUNTED'
MSGOFFLN MSG   ' VVVVVV VOLUME IS OFFLINE'
MSGPEND  MSG   ' VVVVVV VOLUME IS PENDING OFFLINE'
*
*
         EJECT
         DS    0F
SORTKTAB DC    AL2(VTFDSN-VTFMT),AL2(DSNSORTE-DSNSORT)
         DC    A(DSNSORT),A(DSNSORTE)
         DC    AL2(VTFVOLUM-VTFMT),AL2(VOLSORTE-VOLSORT)
         DC    A(VOLSORT),A(VOLSORTE)
         DC    AL2(VTFUSED-VTFMT),AL2(USESORTE-USESORT)
         DC    A(USESORT),A(USESORTE)
         DC    AL2(VTFALLOC-VTFMT),AL2(ALCSORTE-ALCSORT)
         DC    A(ALCSORT),A(ALCSORTE)
         DC    AL2(VTFUNUSD-VTFMT),AL2(UNUSORTE-UNUSORT)
         DC    A(UNUSORT),A(UNUSORTE)
         DC    AL2(VTFPCT-VTFMT),AL2(PCTSORTE-PCTSORT)
         DC    A(PCTSORT),A(PCTSORTE)
         DC    AL2(VTFNOEPV-VTFMT),AL2(EXTSORTE-EXTSORT)
         DC    A(EXTSORT),A(EXTSORTE)
         DC    AL2(VTFDSORG-VTFMT),AL2(DSOSORTE-DSOSORT)
         DC    A(DSOSORT),A(DSOSORTE)
         DC    AL2(VTFRECFM-VTFMT),AL2(RFMSORTE-RFMSORT)
         DC    A(RFMSORT),A(RFMSORTE)
         DC    AL2(VTFLRECL-VTFMT),AL2(LRCSORTE-LRCSORT)
         DC    A(LRCSORT),A(LRCSORTE)
         DC    AL2(VTFBLKSZ-VTFMT),AL2(BLKSORTE-BLKSORT)
         DC    A(BLKSORT),A(BLKSORTE)
         DC    AL2(VTFCREDT-VTFMT),AL2(CDTSORTE-CDTSORT)
         DC    A(CDTSORT),A(CDTSORTE)
         DC    AL2(VTFLSTAC-VTFMT),AL2(RDTSORTE-RDTSORT)
         DC    A(RDTSORT),A(RDTSORTE)
         DC    AL2(VTFEXPDT-VTFMT),AL2(EDTSORTE-EDTSORT)
         DC    A(EDTSORT),A(EDTSORTE)
         DC    2F'0'
         SPACE 3
DSNSORT  DC    A(0),AL2(0),CL6'Z'
         DC    A(0),AL2(1),CL6'TV'
         DC    A(0),AL2(1),CL6'TM'
         DC    A(0),AL2(2),CL6'T.Z'
         DC    A(0),AL2(2),CL6'T.Y'
         DC    A(0),AL2(2),CL6'T.X'
         DC    A(0),AL2(2),CL6'T.W'
         DC    A(0),AL2(2),CL6'T.V'
         DC    A(0),AL2(2),CL6'T.U'
         DC    A(0),AL2(2),CL6'T.T'
         DC    A(0),AL2(2),CL6'T.S'
         DC    A(0),AL2(2),CL6'T.R'
         DC    A(0),AL2(2),CL6'T.Q'
         DC    A(0),AL2(2),CL6'T.P'
         DC    A(0),AL2(2),CL6'T.O'
         DC    A(0),AL2(2),CL6'T.N'
         DC    A(0),AL2(2),CL6'T.M'
         DC    A(0),AL2(2),CL6'T.L'
         DC    A(0),AL2(2),CL6'T.K'
         DC    A(0),AL2(2),CL6'T.J'
         DC    A(0),AL2(2),CL6'T.I'
         DC    A(0),AL2(2),CL6'T.H'
         DC    A(0),AL2(2),CL6'T.G'
         DC    A(0),AL2(2),CL6'T.F'
         DC    A(0),AL2(2),CL6'T.E'
         DC    A(0),AL2(2),CL6'T.D'
         DC    A(0),AL2(2),CL6'T.C'
         DC    A(0),AL2(2),CL6'T.B'
         DC    A(0),AL2(2),CL6'T.A'
         DC    A(0),AL2(1),CL6'SY'
         DC    A(0),AL2(1),CL6'SV'
         DC    A(0),AL2(1),CL6'PV'
         DC    A(0),AL2(2),CL6'P.Z'
         DC    A(0),AL2(2),CL6'P.Y'
         DC    A(0),AL2(2),CL6'P.X'
         DC    A(0),AL2(2),CL6'P.W'
         DC    A(0),AL2(2),CL6'P.V'
         DC    A(0),AL2(2),CL6'P.U'
         DC    A(0),AL2(2),CL6'P.T'
         DC    A(0),AL2(2),CL6'P.S'
         DC    A(0),AL2(2),CL6'P.R'
         DC    A(0),AL2(2),CL6'P.Q'
         DC    A(0),AL2(2),CL6'P.P'
         DC    A(0),AL2(2),CL6'P.O'
         DC    A(0),AL2(2),CL6'P.N'
         DC    A(0),AL2(2),CL6'P.M'
         DC    A(0),AL2(2),CL6'P.L'
         DC    A(0),AL2(2),CL6'P.K'
         DC    A(0),AL2(2),CL6'P.J'
         DC    A(0),AL2(2),CL6'P.I'
         DC    A(0),AL2(2),CL6'P.H'
         DC    A(0),AL2(2),CL6'P.G'
         DC    A(0),AL2(2),CL6'P.F'
         DC    A(0),AL2(2),CL6'P.E'
         DC    A(0),AL2(2),CL6'P.D'
         DC    A(0),AL2(2),CL6'P.C'
         DC    A(0),AL2(2),CL6'P.B'
         DC    A(0),AL2(2),CL6'P.A'
         DC    A(0),AL2(0),CL6'N'
DSNSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
VOLSORT  DC    A(0),AL2(4),CL6'33509'
         DC    A(0),AL2(4),CL6'33508'
         DC    A(0),AL2(4),CL6'33507'
         DC    A(0),AL2(4),CL6'33506'
         DC    A(0),AL2(4),CL6'33505'
         DC    A(0),AL2(4),CL6'33504'
         DC    A(0),AL2(4),CL6'33503'
         DC    A(0),AL2(4),CL6'33502'
         DC    A(0),AL2(4),CL6'33501'
         DC    A(0),AL2(4),CL6'33500'
         DC    A(0),AL2(4),CL6'33309'
         DC    A(0),AL2(4),CL6'33308'
         DC    A(0),AL2(4),CL6'33307'
         DC    A(0),AL2(4),CL6'33306'
         DC    A(0),AL2(4),CL6'33305'
         DC    A(0),AL2(4),CL6'33304'
         DC    A(0),AL2(4),CL6'33303'
         DC    A(0),AL2(4),CL6'33302'
         DC    A(0),AL2(4),CL6'33301'
         DC    A(0),AL2(4),CL6'33300'
         DC    A(0),AL2(0),CL6'T'
         DC    A(0),AL2(0),CL6'R'
         DC    A(0),AL2(0),CL6'P'
         DC    A(0),AL2(0),CL6'M'
         DC    A(0),AL2(0),CL6'I'
         DC    A(0),AL2(0),CL6'H'
VOLSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
USESORT  DS    0F
UNUSORT  DS    0F
ALCSORT  DC    A(0),AL2(3),XL4'0000F000',XL2'00'
         DC    A(0),AL2(3),XL4'0000C000',XL2'00'
         DC    A(0),AL2(3),XL4'0000A000',XL2'00'
         DC    A(0),AL2(3),XL4'00008000',XL2'00'
         DC    A(0),AL2(3),XL4'00006000',XL2'00'
         DC    A(0),AL2(3),XL4'00005000',XL2'00'
         DC    A(0),AL2(3),XL4'00004000',XL2'00'
         DC    A(0),AL2(3),XL4'00003000',XL2'00'
         DC    A(0),AL2(3),XL4'00002000',XL2'00'
         DC    A(0),AL2(3),XL4'00001000',XL2'00'
         DC    A(0),AL2(3),XL4'00000C00',XL2'00'
         DC    A(0),AL2(3),XL4'00000800',XL2'00'
         DC    A(0),AL2(3),XL4'00000400',XL2'00'
         DC    A(0),AL2(3),XL4'00000300',XL2'00'
         DC    A(0),AL2(3),XL4'00000200',XL2'00'
         DC    A(0),AL2(3),XL4'00000100',XL2'00'
         DC    A(0),AL2(3),XL4'000000C0',XL2'00'
         DC    A(0),AL2(3),XL4'00000080',XL2'00'
         DC    A(0),AL2(3),XL4'00000040',XL2'00'
         DC    A(0),AL2(3),XL4'00000010',XL2'00'
USESORTE DS    0F
UNUSORTE DS    0F
ALCSORTE DC    A(0),AL2(3),XL6'00'
         SPACE 3
PCTSORT  DC    A(0),AL2(1),XL2'0064',XL4'00'
         DC    A(0),AL2(1),XL2'005A',XL4'00'
         DC    A(0),AL2(1),XL2'0050',XL4'00'
         DC    A(0),AL2(1),XL2'0046',XL4'00'
         DC    A(0),AL2(1),XL2'003C',XL4'00'
         DC    A(0),AL2(1),XL2'0032',XL4'00'
         DC    A(0),AL2(1),XL2'0028',XL4'00'
         DC    A(0),AL2(1),XL2'001E',XL4'00'
         DC    A(0),AL2(1),XL2'0014',XL4'00'
         DC    A(0),AL2(1),XL2'000A',XL4'00'
PCTSORTE DC    A(0),AL2(1),XL6'00'
         SPACE 3
EXTSORT  DC    A(0),AL2(0),CL6'0'
EXTSORTE DC    A(0),AL2(0),CL6'0'
         SPACE 3
DSOSORT  DC    A(0),AL2(1),CL6'VS'
         DC    A(0),AL2(1),CL6'PS'
         DC    A(0),AL2(1),CL6'PO'
         DC    A(0),AL2(1),CL6'DA'
DSOSORTE DC    A(0),AL2(1),CL6' '
         SPACE 3
RFMSORT  DC    A(0),AL2(1),CL6'VS'
         DC    A(0),AL2(2),CL6'VBS'
         DC    A(0),AL2(1),CL6'VB'
         DC    A(0),AL2(0),CL6'V'
         DC    A(0),AL2(0),CL6'U'
         DC    A(0),AL2(1),CL6'FS'
         DC    A(0),AL2(2),CL6'FBS'
         DC    A(0),AL2(1),CL6'FB'
         DC    A(0),AL2(0),CL6'F'
RFMSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
LRCSORT  DS    0F
BLKSORT  DC    A(0),AL2(1),XL2'4650',XL4'00'
         DC    A(0),AL2(1),XL2'3A98',XL4'00'
         DC    A(0),AL2(1),XL2'2EE0',XL4'00'
         DC    A(0),AL2(1),XL2'2328',XL4'00'
         DC    A(0),AL2(1),XL2'1770',XL4'00'
         DC    A(0),AL2(1),XL2'0BB8',XL4'00'
         DC    A(0),AL2(1),XL2'07D0',XL4'00'
         DC    A(0),AL2(1),XL2'0640',XL4'00'
         DC    A(0),AL2(1),XL2'04B0',XL4'00'
         DC    A(0),AL2(1),XL2'0320',XL4'00'
         DC    A(0),AL2(1),XL2'0258',XL4'00'
         DC    A(0),AL2(1),XL2'0190',XL4'00'
         DC    A(0),AL2(1),XL2'00C8',XL4'00'
         DC    A(0),AL2(1),XL2'00A0',XL4'00'
         DC    A(0),AL2(1),XL2'0078',XL4'00'
         DC    A(0),AL2(1),XL2'0050',XL4'00'
         DC    A(0),AL2(1),XL2'0028',XL4'00'
BLKSORTE DS    0F
LRCSORTE DC    A(0),AL2(1),XL6'00'
         SPACE 3
CDTSORT  DS    0F
EDTSORT  DS    0F
RDTSORT  DC    A(0),AL2(2),AL1(99),AL2(0),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(000),XL3'00'
EDTSORTE DS    0F
RDTSORTE DS    0F
CDTSORTE DC    A(0),AL2(2),XL6'00'
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         SPACE 3
         COPY  VTOCPARS
         EJECT
*
*        DYNAMIC WORK AREA
*
         SPACE 3
WORKAREA DSECT
MAINSAVE DS    18A
         SPACE
         VTOCEXCP EQ          DEFINE VTOCEXCP CODES
         SPACE
PARSELST DS    8A             AREA FOR PARSE PARAMETER LIST
         SPACE
R14SAVE  DS    A
R14PARSE DS    A
*
*        VTOC COMMAND COMMON AREA
*
         PRINT GEN
         VTOCOM  NODSECT
         PRINT NOGEN
         SPACE 3
*
*        WORK AREAS FOR SUBROUTINES
*
WORKMSG  DS    XL256
WORKEXCP DS    4XL256
WORKCHEK DS    XL256
WORKFORM DS    2XL256
WORKEXIT DS    8XL256
WORKSORT DS    XL256
WORKPRNT DS    10XL256
         DS    0D
LENWORK  EQU   *-WORKAREA
         SPACE 3
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         IKJPPL
         SPACE 3
         IKJIOPL
         SPACE 3
         IKJPSCB
         SPACE 3
         IKJECT
         SPACE 3
         IKJCPPL
         SPACE 3
         IKJUPT
         SPACE 3
         PRINT NOGEN
         CVT
         END
/*
//*------------------------------------------------------ ASM: VTOC
//*
//ASM2.SYSIN DD *
         TITLE 'VTOC COMMAND CHECK  ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
* TITLE -      VTOC COMMAND CHECK  ROUTINE                            *
*                                                                     *
* FUNCTION -   CHECK THE CONDITIONS SPECIFIED ON THE VTOC COMMAND.    *
*              SEE IF THE DATA SET PASSED SHOULD BE PROCESSED.        *
*              THE LIMIT, ENDING, CONTAINING, CCHH, LIMIT, AND,       *
*              AND OR KEYWORDS ARE PROCESSED BY THIS ROUTINE.         *
*                                                                     *
* OPERATION -  FIRST GET THE LENGTH OF THE DSNAME AND SAVE IT.        *
*              THEN GET THE FORMAT 3 DSCB, IF ONE EXISTS.  TRY        *
*              EACH KEYWORD TO SEE IF IT WILL EXCLUDE THE DATA        *
*              SET FROM FURTHER PROCESSING.                           *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, FORMAT 1, 3, AND 4 DSCB'S              *
*              FOR DSORG, RECFM, ALLOC, USED, PROT, CATLG, OR SECAL   *
*              CALL VTOCFORM TO FORMAT THE PARMS.  USE FORMATTED DSCB *
*                                                                     *
* OUTPUT -     A RETURN CODE OF 0 TO CONTINUE PROCESSING OR 8 TO      *
*              EXCLUDE THIS DATA SET.                                 *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
*        MACROS FOR CHECK ROUTINE
*
         MACRO
&LABEL   VTCHL &KEY           CALL THE KEYWORD CHECK ROUTINE
&LABEL   L     R1,SUB&KEY.OPER    GET THE OPERATOR VALUE
         BAL   R8,GETOPER    TRANSLATE TO A NUMBER
         ST    R15,REFOPER     SAVE IT TOO
         LA    R1,SUB&KEY.VALU   GET THE VALUE PDL
         ST    R1,REFVAL      SAVE THAT ADDRESS THREE
         CLI   FLAGNM&KEY,0  HAS IT BEEN CONVERTED?
         BNE   VTP&SYSNDX    YES, SKIP ALONG
         MVI   FLAGNM&KEY,1  NOTE IT AS CONVERTED
         BAL   R8,PDLNUM     GO CONVERT IT
         ST    R15,NUMBER&KEY      SAVE THE VALUE
         LA    R4,SUB&KEY.KEY  POINT TO THE IKJIDENT FOR THE KEYWORD
         BAL   R8,GETKEY     CONVERT TEXT TO A NUMERIC KEY
         STC   R15,NUMKEY&KEY  SAVE THAT NUMERIC KEY
         LTR   R15,R15       WAS IT SUCCESSFUL?
         BNZ   VTP&SYSNDX    YES, SKIP ALONG
*        ISSUE A MESSAGE - A BAD LIM, AND, OR KEYWORD
         MVC   MSGTEXT2,KEYERR  START THE ERROR MESSAGE
         L     R1,0(R4)      POINT TO THE TEXT
         MVC   MSGTEXT2+49(6),0(R1)  THEN ADD IT TO THE MESSAGE
         VTOCMSG MSGTEXT2    ISSUE THE ERROR MESSAGE
VTP&SYSNDX DS  0H
         SR    R1,R1         CLEAR A REGISTER
         ICM   R1,1,NUMKEY&KEY GET THE KEYWORD VALUE
         BZ    VTE&SYSNDX    IF NOT SET, SKIP THE EVALUATION
         ST    R1,REFKEY      SAVE THE ADDRESS
         LA    R1,NUMBER&KEY  GET THE ADDRESS OF CONVERTED NUMBER
         ST    R1,REFNUM      SAVE IT'S ADDRESS
         BAL   R8,LIMEVAL     GO EVALUATE THE EXPRESSION
VTE&SYSNDX DS  0H
         MEND
         SPACE 3
         MACRO
&LABEL   VTANDOR &NUM         EVALUATE, THEN DO AND OR OR FUNCTION
&LABEL   CLI   ANDOR&NUM.K+1,0  WAS THIS KEYWORD SET?
         BE    LIMCOMP        NO, JUST CHECK THE FINAL RESULT
         VTCHL &NUM           YES, EVALUATE
         CLI   ANDOR&NUM.K+1,1  WAS IT AN AND ?
         BE    VTA&SYSNDX     YES, DO THE AND
         O     R15,LIMVAL     NO, OR IT
         B     VTE&SYSNDX     FINISHED WITH THIS EXPRESSION
VTA&SYSNDX N   R15,LIMVAL     AND THE EXPRESSION VALUE
VTE&SYSNDX ST  R15,LIMVAL     SAVE THE VALUE
         MEND
*
         EJECT
VTOCCHEK ENTER 12,12          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING CHEKWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
*
*        SEE WHAT THE FORMAT ID IS
*
CHEKFMT  L     R7,DSCBADDR    POINT TO THE DSCB
         LA    R7,8(R7)       GET PAST THE HEADER
         USING DSCB1,R7       SET ADDRESSABILITY
         CLI   FORMATK+1,0    DID HE SPECIFY VARIOUS DSCB'S
         BNE   CHEKFMTI       YES, GO DO HIS CHECKS
CHEKFMTI DS    0H             NOT YET PROGRAMMED
*
*        STANDARD IS ONLY TO ALLOW FORMAT ONES TO GO
*
         CLI   DS1FMTID,C'1'  IS THIS A FORMAT 1?
         BNE   CHECKOUT       NO, EXCLUDE IT FROM FURTHER PROCESSING
*
*              FIRST SEE HOW BIG THE DSNAME IS
*
         LA    R1,DS1FMTID    POINT PAST THE DSNAME
         TRT   DS1DSNAM,BLKTRTAB  FIND THE FIRST BLANK
         SR    R1,R7          SUBTRACT TO GET THE LENGTH
         STH   R1,DSNLEN      SAVE THE DSNAME LENGTH
         LR    R3,R1          KEEP THE LENGTH FOR LATER
*
*        GET THE FORMAT 3 DSCB, IF IT EXISTS
*
         XC    FMT3,FMT3      CLEAR IT FIRST
         CLC   DS1PTRDS,=XL5'0000000000'  IS THERE A FORMAT 3?
         BE    FMT3NO         NO, SKIP ALONG
*
*        SET UP THE CAMLST
*
         MVC   CAMSEEK(4),CAMSCON  MOVE IN THE FIRST WORD OF CAMLST
         LA    R1,DS1PTRDS    GET THE CCHHR ADDRESS
         ST    R1,CAMSEEK+4   SAVE IT
         LA    R1,VOLID       POINT TO THE VOLUME SERIAL
         ST    R1,CAMSEEK+8   SAVE IT
         LA    R1,FMT3        POINT TO THE AREA FOR THE DSCB3
         ST    R1,CAMSEEK+12  SAVE IT
         OBTAIN CAMSEEK       GET THE DSCB
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   OBT3ERR        BAD NEWS, ISSUE THE MESSAGE
*
*        PROCESS THE LEVEL KEYWORD
*
FMT3NO   CLI   LEVKEY+1,0     WAS LEVEL SPECIFIED?
         BE    LEVEND         NO, SKIP ON
         LA    R4,LEVEL       YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
         LR    R2,R7          POINT TO THE START OF THE DSNAME
LEVNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE LEVEL
         CR    R3,R5          COMPARE LENGTHS
         BL    LEVINC         THIS LEVEL IS LONGER THAN DSN, NO MATCH
         BCTR  R5,0           MINUS ONE FOR THE EX
         EX    R5,COMPARE     CHECK THE LENGTHS
         BE    LEVEND         IT MATCHES, ALLOW IT
LEVINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT LEVEL PDE POINTER
         BNZ   LEVNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
LEVEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        PROCESS THE ENDING KEYWORD
*
         CLI   ENDKEY+1,0     WAS ENDING SPECIFIED?
         BE    ENDEND         NO, SKIP ON
         LA    R4,ENDING      YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
ENDNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE ENDING
         CR    R3,R5          COMPARE LENGTHS
         BL    ENDINC         THIS ENDING IS LONGER THAN DSN, NO MATCH
         LR    R2,R7          POINT TO THE START OF THE DSNAME
         AR    R2,R3          POINT TO THE END
         SR    R2,R5          BACKUP TO COMPARE THIS LENGTH
         BCTR  R5,0           MINUS ONE FOR THE EX
         EX    R5,COMPARE     CHECK THE LENGTHS
         BE    ENDEND         IT MATCHES, ALLOW IT
ENDINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT ENDING PDE POINTER
         BNZ   ENDNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
ENDEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        PROCESS THE CONTAINING KEYWORD
*
         CLI   CONTAINK+1,0   WAS CONTAINING SPECIFIED?
         BE    CONEND         NO, SKIP ON
         LA    R4,CONTAIN     YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
CONNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE CONTAINING
         CR    R3,R5          COMPARE LENGTHS
         BL    CONINC         THIS CONTAIN IS LONGER THAN DSN, NO MATCH
         LR    R1,R7          POINT TO THE START OF THE DSNAME
         AR    R1,R3          POINT TO THE END
         SR    R1,R5          BACKUP TO COMPARE THIS LENGTH - LAST ONE
         LR    R2,R7          POINT TO THE START OF THE DSNAME
         BCTR  R5,0           MINUS ONE FOR THE EX
CONCOMP  EX    R5,COMPARE     CHECK THE LENGTHS
         BE    CONEND         IT MATCHES, ALLOW IT
         LA    R2,1(R2)       CHECK THE WHOLE DSNAME
         CR    R2,R1          CHECK FOR THE END OF THE REAL DSN
         BNH   CONCOMP        NOT THERE YET
CONINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT CONTAINING PDE POINTER
         BNZ   CONNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
CONEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        NOW THE BIG MESS, CHECK FOR LIMIT, AND'S, AND OR'S
*
         CLI   LIMITK+1,0     WAS LIMIT SPECIFIED
         BE    LIMEND         NO, THEN THERE CAN BE NO AND'S OR OR'S
         NI    VTCFMTCK,255-VTCFMTCC  TURN OFF THE ROUTINE CALL FLAG
         VTCHL L              EVALUATE THE LIMIT 1=TRUE 0=FALSE
         ST    R15,LIMVAL     SAVE THE ANSWER
         VTANDOR 1            CHECK AND1 OR OR1
         VTANDOR 2            CHECK AND2 OR OR2
         VTANDOR 3            CHECK AND3 OR OR3
LIMCOMP  L     R15,LIMVAL     GET THE RESULT OF ALL THIS
         LTR   R15,R15        TEST IT
         BZ    CHECKOUT       IT GETS EXCLUDED
LIMEND   DS    0H
         B     CHECKIN        ALL TESTS PASSED, INCLUDE THIS ONE
         SPACE 5
*
*        EVALUATION ROUTINE FOR   KEYWORD  OPER  VALUE
*
LIMEVAL  L     R5,REFKEY      GET THE KEYWORD VALUE
         MH    R5,H12         MULTIPLY IT BY 12
         A     R5,ATABTITL    THEN RELOCATE IT
         SR    R10,R10         CLEAR THE ROUTINE POINTER
         TM    1(R5),X'80'    IS IT A FORMATTED ITEM?
         BO    LIMFORM        YES, GO DO IT
         SR    R6,R6         CLEAR A REGISTER
         IC    R6,2(R5)      GET THE OFFSET INTO VTFMT
         IC    R10,1(R5)      GET THE ROUTINE NUMBER
         LTR   R10,R10         SEE IF IT'S A GOOD NUMBER
         BP    LIMEVAL1       IT'S ALL RIGHT
LIMABEND ABEND 702,DUMP       CRASH AND BURN
LIMEVAL1 B     *(R10)         AND GO TO IT
         B     LIMDATE        CDATE, EXPDT, REFDT
         B     LIMLUSE        *** DUMMY ENTRY ***
         B     LIMFORM        FORM , USED SPACE
         B     LIMFORM        UNUSED SPACE
         B     LIMFORM        PCT USED
         B     LIMEXT         EXTENTS
         B     LIMBLREC       LRECL, BLKSZ, SEC Q
         B     LIMCCHH       CCHH CHECKING
         SPACE 5
*
*        PERFORM THE FORMATTED ITEM CHECKING
*
LIMFORM  DS    0H
         TM    VTCFMTCK,VTCFMTCC  WAS FORMAT CALLED BEFORE FOR THIS DS
         BO    LIMFCALD       YES, DON'T CALL IT AGAIN
         VTCALL FORM          NO, CALL IT TO GET THE ITEMS
         OI    VTCFMTCK,VTCFMTCC+VTCFMTCD  THEN SET THE SWITCHES
LIMFCALD SR    R2,R2          CLEAR A WORK REG
         A     R6,FORMATAD   RELOCATE THE BLOCK
         B     *+4(R10)         AND GO TO IT
         B     LIMFORMA      FORMATTED ITEM
         B     LIMABEND       CDATE, EXPDT
         B     LIMABEND       LAST USE DATE
         B     LIMALLOC       ALLOC, USED SPACE
         B     LIMUNUSD       UNUSED SPACE
         B     LIMPCT         PCT USED
LIMFORMA DS    0H
         IC    R2,2(R5)       GET THE OFFSET IN VTFMT
         A     R2,FORMATAD    THEN RELOCATE IT
         L     R4,REFVAL      GET THE VALUE PDE
         LH    R3,4(R4)       GET THE LENGTH OF THE STRING
         L     R1,0(R4)       AND ITS ADDRESS
*
*        DO THE ACTUAL COMPARE
*
         BCTR  R3,0           DOWN ONE FOR AN EX
         EX    R3,COMPLIM     COMPARE AS SPECIFIED
COMPDONE DS    0H             GET THE OPERATOR ADDRESS
         BL    COMPLOW        CHECK THE OPERATOR, VALUE LESS THAN ITEM
         BE    COMPEQ         CHECK THE OPERATOR, KEYWORD EQUALS VALUE
*                             KEYWORD IS GREATER THAN THE VALUE
COMPHI   CLI   REFOPER+3,NE       WAS OPERATOR NE
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GT       ALSO FOR GT
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GE       AND FOR GE
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*                             KEYWORD IS EQUAL TO THE VALUE
COMPEQ   CLI   REFOPER+3,EQ       WAS OPERATOR EQ
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LE       ALSO FOR LE
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GE       AND FOR GE
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*                             KEYWORD IS LESS THAN THE VALUE
COMPLOW  CLI   REFOPER+3,NE       WAS OPERATOR NE
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LT       ALSO FOR LT
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LE       AND FOR LE
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*
*        IT FITS OR IT DOESN'T
*
COMPYES  LA    R15,1          SET A TRUE VALUE
         BR    R8             THEN RETURN
COMPNO   SR    R15,R15        SET A FALSE VALUE
         BR    R8             THEN RETURN
*
*        SPECIAL ROUTINES TO CHECK NON-FORMATTED ITEMS
*
LIMDATE  DS    0H
*
*        COMPARE DATES
*
         LA    R14,DS1CREDT  POINT TO CREATION DATE
         CLI   REFKEY+3,CDATE      IS THAT IT?
         BE    LIMDGET       YES, THIS IS IT
         LA    R14,DS1EXPDT  POINT TO EXPIRATION DATE
         CLI   REFKEY+3,EXPDT      IS THAT IT?
         BE    LIMDGET       YES, THIS IS IT
         LA    R14,DS1REFD   NO, USE REFERENCE DATE
LIMDGET  SR    R15,R15       CLEAR A WORK REG
         IC    R15,0(R14)    GET THE YEAR
         MH    R15,H1000     TIMES 1000
         SR    R1,R1         CLEAR ANOTHER WORK REG
         ICM   R1,3,1(R14)    GET THE DAYS
         AR    R15,R1        PUT THE DATE TOGETHER
         L     R1,REFNUM     GET THE ADDRESS OF THE VALUE
         L     R1,0(R1)      GET THE VALUE ITSELF
         CR    R15,R1        COMPARE THEM
         B     COMPDONE      GO CHECK OPERANDS
LIMLUSE  DS    0H
*
*        LAST USE DATE
*
         SR    R14,R14       CLEAR THE DATE
         CLC   ZERO,75(R7)   CHECK FOR NO DATA
         BE    LIMLUCMP      RIGHT, SKIP ON
         MVC   CHEKDBLW+5(3),75(R7)  MOVE IN THE LAST USE DATE
         CVB   R14,CHEKDBLW  CONVERT IT TO BINARY
LIMLUCMP L     R1,REFNUM     GET THE ADDRESS OF THE VALUE
         L     R1,0(R1)      GET THE VALUE
         CR    R14,R1        DO THE COMPARE
         B     COMPDONE      THEN CHASE DOWN THE OPERANDS
LIMEXT   DS    0H
*
*        EXTENTS
*
         L     R1,REFNUM     GET THE COMPARE VALUE ADDRESS
         CLC   DS1NOEPV,3(R1)        COMPARE THEM
         B     COMPDONE      GO CHECK OPERANDS
LIMBLREC DS    0H
*
*        LRECL, BLKSZ, SECQ
*
         L     R1,REFNUM     GET THE ADDRESS OF THE COMPARE VALUE
         L     R15,0(R1)      THEN GET THE VALUE ITSELF
         CLI   REFKEY+3,BLKSZ      BLOCK SIZE?
         BNE   LIMB1         NO, KEEP CHECKING
         LH    R1,DS1BLKL    COMPARE TO THE BLOCK SIZE
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      GO SIFT THROUGH THE OPERANDS
LIMB1    CLI   REFKEY+3,LRECL  LOGICAL RECORD LENGTH
         BNE   LIMB2         NO, KEEP GOING
         LH    R1,DS1LRECL   COMPARE TO THE LRECL
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      GO CHECK THE OPERANDS
LIMB2    MVC   HWORK,DS1SCALO+2 GET THE SECONDARY QUANTITY
         LH    R1,HWORK      DO THE COMPARE
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      THEN CHECK THE OPERANDS
*
*        SPACE CHECKING ROUTINES
*
LIMALLOC DS    0H
*
*        ALLOC AND USED
*
         L     R1,REFNUM     GET THE ADDRESS OF THE CONVERTED NUMBER
         L     R1,0(R1)      GET THE VALUE
         L     R15,0(R6)     GET THE AMOUNT
         CR    R15,R1        COMPARE THEM
         B     COMPDONE      THEN CHECK THE OPERANDS
LIMUNUSD DS    0H
*
*        UNUSED
*
         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC
         USING VTFMT,R6      SET ADDRESSABILITY
         ICM   R14,15,VTFUSED      GET THE AMOUNT USED
         BM    LIMUNUAL      IF MINUS, WE DON'T KNOW
         L     R14,VTFALLOC  GET ALLOC
         S     R14,VTFUSED   MINUS THE AMOUNT USED
LIMUNUAL L     R1,REFNUM     GET THE ENTERED VALUE
         L     R1,0(R1)      NOW ITS VALUE FOR REAL
         CR    R14,R1        COMPARE THE VALUES
         B     COMPDONE      THEN GO CHECK THE OPERANDS
LIMPCT   DS    0H
*
*        PER CENT
*
         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC
         USING VTFMT,R6      SET ADDRESSABILITY
         SR    R14,R14       CLEAR A REGISTER
         ICM   R15,15,VTFUSED      GET THE AMOUNT USED
         BM    LIMP100       IF UNKNOWN USED, SET 100 PER CENT
         CLC   VTFALLOC,ZERO ZERO ALLOCATED SPACE?
         BNE   LIMPCTOK      NO, CONTINUE
         CLC   VTFUSED,ZERO  ZERO USED SPACE?
         BE    LIMPCOMP      YES, PCT IS ZERO
*              ZERO ALLOCATED, NONZERO USED, INCLUDE THIS ONE
         B     COMPYES
LIMP100  LA    R15,100       SET UP 100 PER CENT
         B     LIMPCOMP      GO COMPARE
LIMPCTOK M     R14,F100      MULTIPLY BY 100 PERCENT
         D     R14,VTFALLOC  DIVIDE BY THE ALLOCATION
LIMPCOMP L     R1,REFNUM     GET THE VALUE ADDRESS
         L     R1,0(R1)      THEN THE VALUE
         CR    R15,R1        THEN COMPARE THEM
         B     COMPDONE      THEN GO SIFT THROUGH THE OPERANDS
*
*        CCHH CHECKING IS NOT QUITE STANDARD BECAUSE THERE MAY
*        MAY BE UP TO 16 EXTENTS TO COMPARE.  THE DATA MAY BE
*        CC OR CCHH FORMATS.  THE DATA SET MAY BE EQUAL TO,
*        LESS THAN, AND GREATER THAN ANY PARTICULAR VALUE.
*
LIMCCHH  DS    0H
*
*        FIRST SEE IF THE CCHH WAS CONVERTED
*              CONVERT IT IF NOT, SKIP IF IT'S DONE
*
         L     R5,REFNUM     GET THE ADDRESS OF THE COMPARISON VALUE
         L     R4,0(R5)      GET THE VALUE
         ICM   R6,3,4(R5)    GET THE COMPARE LENGTH
         BP    LIMCSET       IF IT'S SET, THE CONVERSION IS DONE
*                      IT WASN'T SET, CONVERT FROM CHARS TO BINARY
         L     R1,REFVAL     GET THE ADDRESS OF THE IKJIDENT
         L     R2,0(R1)      POINT TO THE TEXT
         LH    R3,4(R1)      GET THE LENGTH OF THE TEXT
*        IT SHOULD BE 4 OR 8 CHARACTERS
         XC    DOUBLE,DOUBLE CLEAR OUT A PLACE TO WORK
         CH    R3,H4         IS IT A CYLINDER ONLY?
         BH    LIMCCON2      NO, TRY FOR A CCHH
         BE    LIMCCON1      YES, JUST CONVERT IT
         VTOCMSG CCHHLEN     LESS THAN FOUR CHARS, ISSUE A MSG
LIMCCON1 LA    R6,1          SET THE COMPARE LENGTH
         B     LIMCMOVE      GO MOVE IT IN
LIMCCON2 LA    R6,3          SET THE COMPARE LENGTH
         CH    R3,H8         WAS IT A CCHH?
         BE    LIMCMOVE      YES, JUST THE RIGHT LENGTH
         VTOCMSG CCHHLEN     WARN THE PERSON
         CH    R3,H8         CHECK AGAIN
         BL    LIMCMOVE      IS IT OVER 8 CHARS?
         LH    R3,H8         YES, SET IT FOR THE MAX - IGNORE RR
LIMCMOVE BCTR  R3,0          MINUS ONE FOR THE EX
         EX    R3,MOVECCHH   MOVE IN THE CHARS
         TR    DOUBLE,DECTABLE TRANSLATE HEX EBCDIC TO HEX BINARY
         PACK  CYLH(5),DOUBLE(9)  SQUISH OUT THE ZONES
         L     R4,CYLH       GET THE CCHH
         ST    R4,0(R5)      SAVE IT FOR LATER
         STH   R6,4(R5)      SAVE THE LENGTH TOO
LIMCSET  DS    0H            THE NUMBER IS CONVERTED
*
*        COMPARE THE EXTENTS TO THE CCHH VALUE.
*        ANY EXTENT MAY BE LT, EQ, AND GT A PARTICULAR
*        VALUE, AND ALL THE EXTENTS MUST BE CHECKED.
*
         MVI   CCHHCOMP,0    CLEAR THE FLAGS
         SR    R2,R2         CLEAR A REG FOR AN EXTENT COUNTER
         ICM   R2,1,DS1NOEPV GET THE NUMBER OF EXTENTS
         BZ    COMPNO        NO EXTENTS, JUST GO SEE
*
*        GET EACH EXTENT AND PROCESS IT
*
         SR    R1,R1         FIRST EXTENT
EXTNEXT  LR    R3,R1         GET THE CURRENT EXTENT
         SLL   R3,2          TIMES 4
         EX    R0,GETEXT(R3) GET THE EXTENT ADDRESS INTO R3
*
*        CHECK THE BOTTOM OF THE EXTENT
*
         NI    CCHHCOMP,255-CCHHX TURN OFF THE STRADDLE FLAG
         EX    R6,CLCEXTLO    DO THE COMPARE
         BH    SETH1         THE FIELD IS HIGHER THAN THE VALUE
         BE    SETEQ1        THE FIELD IS EQUAL TO THE VALUE
         OI    CCHHCOMP,CCHHLOW+CCHHX  LOWER -  POSSIBLE STRADDLE
         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT
SETH1    OI    CCHHCOMP,CCHHHIGH  SET THE FLAG
         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT
SETEQ1   OI    CCHHCOMP,CCHHEQ   SET THE FLAG
*
*        CHECK THE TOP OF THE EXTENT
*
CHECKHI  EX    R6,CLCEXTHI   DO THE COMPARE
         BE    SETEQ2        EQUAL, GO SET IT
         BL    EXTSET        LOW, GO SET IT
*
*        THIS IS THE ONLY SLIGHTLY TRICKY PART, A STRADDLE
*        IF THE BOTTOM OF THE EXTENT IS LOWER THAN THE VALUE AND THE
*        TOP OF THE EXTENT IS HIGHER THAN THE VALUE, THEN THE
*        EQ FLAG SHOULD BE SET TOO.
*
         OI    CCHHCOMP,CCHHHIGH  SET THE HIGH FLAG
         TM    CCHHCOMP,CCHHX     WAS THE BOTTOM LOWER THAN THE VALUE?
         BZ    EXTSET        NO, SKIP ON
SETEQ2   OI    CCHHCOMP,CCHHEQ    SET THE EQ FLAG
*
*        FINISHED WITH THAT EXTENT, CHECK FOR MORE
*
EXTSET   DS    0H
         LA    R1,1(R1)      INCREMENT THE EXTENT COUNTER
         CR    R1,R2         CHECK THE EXTENT COUNTER
         BNL   LIMCOPER      THAT'S ALL FOLKS
         TM    CCHHCOMP,CCHHHIGH+CCHHEQ+CCHHLOW  ARE THEY ALL SET?
         BNO   EXTNEXT       NO, CONTINUE LOOKING
*                            YES, STOP NOW - ALL THE FLAGS ARE SET
LIMCOPER L     R4,REFOPER    GET THE NUMERIC VALUE OF THE KEY
         IC    R4,CCHHTAB(R4)  GET A FLAG MASK
         EX    R4,CCHHOPER   CHECK TO SEE IF THE CONDITION IS SET
         BZ    COMPNO        NOT THERE
         B     COMPYES       YES
*
*        EXECUTED INSTRUCTIONS TO GET THE ADDRESS OF THIS EXTENT
*
GETEXT   LA    R3,DS1EXT1     1ST EXTENT
         LA    R3,DS1EXT2     2ND EXTENT
         LA    R3,DS1EXT3     3RD EXTENT
         LA    R3,DS3EXTNT    4TH EXTENT
         LA    R3,DS3EXTNT+10 5TH EXTENT
         LA    R3,DS3EXTNT+20 6TH EXTENT
         LA    R3,DS3EXTNT+30 7TH EXTENT
         LA    R3,DS3ADEXT    8TH EXTENT
         LA    R3,DS3ADEXT+10 9TH EXTENT
         LA    R3,DS3ADEXT+20 10TH EXTENT
         LA    R3,DS3ADEXT+30 11TH EXTENT
         LA    R3,DS3ADEXT+40 12TH EXTENT
         LA    R3,DS3ADEXT+50 13TH EXTENT
         LA    R3,DS3ADEXT+60 14TH EXTENT
         LA    R3,DS3ADEXT+70 15TH EXTENT
         LA    R3,DS3ADEXT+80 16TH EXTENT
*
*        ISSUE ERROR MESSAGES AND RETURN
*
OBT3ERR  VTOCMSG OBT3ERRM   OBTAIN ERROR MESSAGE
CHECKOUT LA    R15,8          EXCLUDE THIS DATA SET
         B     CHEKRET        RETURN
*
CHECKIN  SR    R15,R15        CLEAR THE REGISTER, PROCESS THIS DATA SET
CHEKRET  LEAVE EQ
*
*
         EJECT
*
*        ROUTINES USED ABOVE
*
         EJECT
*
*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER
*              BINARY FORM, PASSED BACK VIA REGISTER 15
*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW
*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION
*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS
*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS
*                 ANY CHARACTERS OTHER THEN 0-9, +, -
*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED
*
PDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS
         LH    R2,4(R1)       GET THE STRING ADDRESS
         L     R1,0(R1)       GET THE STRING ADDRESS
         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG
         SR    R5,R5          CLEAR THE CHARACTER COUNTER
         SR    R15,R15        CLEAR THE ANSWER
PDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT
         LA    R5,1(R5)       GET TO THE NEXT DIGIT
         CR    R5,R2          IS THIS THE END OF THE STRING?
         BH    PDLFINI        YES, EXIT
         SR    R7,R7          CLEAR A WORK REGISTER
         IC    R7,0(R6)       GET THE CHARACTER
         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'
         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS
         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN
         AR    R15,R7         ADD ON THE NEW DIGIT
         B     PDLLOOP        AND LOOP FOR MORE
*
*        CHECK FOR SPECIAL CHARACTERS
*
PDLSP    CLI   0(R6),C' '     IS IT A BLANK?
         BE    PDLLOOP        THEN IT'S OK
         CLI   0(R6),C'+'     IS IT A PLUS?
         BE    PDLLOOP        THAT'S ALSO OK
         CLI   0(R6),C'-'     IS IT A MINUS?
         BNE   PDLFINI        NO, JUST QUIT
         MVI   PDLMINUS,1     YES, NOTE IT
         B     PDLLOOP        AND LOOK FOR MORE
*
*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED
*
PDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?
         BNE   PDLLEAVE       NO, EXIT
         LNR   R15,R15        YES, MAKE IT NEGATIVE
PDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS
         BR    R8             RETURN
PDLH10   DC    H'10'
PDLH240  DC    H'240'
         EJECT
*
*        ROUTINE TO CONVERT A TEXT DSCB ITEM
*        INTO ITS KEY NUMBER
*        INPUT IS REG 4 - IKJIDENT PTR
*        OUTPUT IS REG 15 - KEY NUMBER
*        ENTRY VIA BAL   R8,GETKEY
*
GETKEY   L     R1,ATABTITL     POINT TO THE TABLE
         LA    R1,12(R1)     POINT TO THE FIRST ENTRY
         LA    R15,1           SET UP THE KEY NUMBER COUNTER
         L     R6,0(R4)      POINT TO THE ENTERED TEXT
         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT
         BNP   GETKNOTF      NOT FOUND IF ZERO
         BCTR  R3,0          MINUS ONE FOR THE EX
GETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
GETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT
         BE    GETKFND       I FOUND IT
         LA    R1,12(R1)     GET TO THE NEXT KEY
         LA    R15,1(R15)    INCREMENT THE KEY COUNTER
         CH    R15,H26       CHECK FOR THE END OF THE TABLE
         BNH   GETKLOOP      NOT YET, KEEP LOOKING
*
*        KEY WAS NOT FOUND, SEND BACK A ZERO
*
GETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN
GETKFND  BR    R8            JUST RETURN
GETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE
H26      DC    H'26'
         EJECT
*
*        ROUTINE TO CONVERT THE OPERATOR TEXT
*        INTO A NUMERIC VALUE
*
GETOPER  LA    R15,1         NUMERIC VALUE COUNTER
GETOLOOP LR    R14,R15       GET THE NUMBER
         SLA   R14,1         MULTIPLY BY 2
         LA    R14,OPERS(R14)      RELOCATE IT
         CLC   0(2,R14),0(R1)      IS THIS THE TEXT?
         BE    GETOFND       YES, RETURN THE NUMBER
         LA    R15,1(R15)    NO, TRY THE NEXT ONE
         CH    R15,H7        CHECK FOR THE END
         BL    GETOLOOP      NOT THERE YET, KEEP TRYING
         VTOCMSG OPERERR,OPERERR2  ISSUE THE MESSAGE
         LA    R15,1         SET THE DEFAULT OPERATOR, EQ
GETOFND  BR    R8            THEN RETURN
         EJECT
*
*        PROGRAM CONSTANTS
*
COMPLIM  CLC   0(0,R2),0(R1)  COMPARE KEYWORD TO VALUE
MOVECCHH MVC   DOUBLE(0),0(R2)
CLCEXTLO CLC   2(0,R3),0(R5)
CLCEXTHI CLC   6(0,R3),0(R5)
CCHHOPER TM    CCHHCOMP,0
CCHHTAB  DC    X'0040A0206080C0'  CCHHCOMP FLAGS
OPERS    DC    C'  EQNELTLEGTGE'
*    FOR  EQ, NE, LT, LE, GT, GE
EDMASK   DC    XL16'40202020202020202020202020202120'
BLANKS   DC    CL16'                '
STARS    DC    CL16'****************'
BLKTRTAB DC    XL64'00',X'04',XL192'00'
CAMSCON  CAMLST SEEK,*,*,*
COMPARE  CLC   0(0,R6),0(R2)  EXECUTED COMPARE
DECTABLE EQU   *-C'A'   CONVERT EBCDIC HEX TO BINARY
         DC    X'0A0B0C0D0E0F'
         DC    (C'0'-C'F'-1)X'FF'  FILLER
         DC    X'00010203040506070809'
*
*
*
H3       DC    H'3'
H4       DC    H'4'
H7       DC    H'7'
H8       DC    H'8'
H10      DC    H'10'
H12      DC    H'12'
ZERO     DC    F'0'
F100     DC    F'100'
H1000    DC    H'1000'
F127     DC    F'127'
*
*
         PRINT NOGEN
*
*        PROGRAM MESSAGES
*
OBT3ERRM MSG   ' VTOCCHEK - ERROR IN OBTAIN FOR FORMAT 3 DSCB '
KEYERR   MSG   ' VTOCCHEK - LIM, AND, OR OR SUBPARM ERROR - XXXXXX '
CCHHLEN  MSG   ' VTOCCHEK - CCHH SHOULD BE 4 OR 8 HEX CHARACTERS '
OPERERR  MSG   ' VTOCCHEK - OPERATOR WAS NOT EQ, NE, LT, LE, GT, OR GE'
OPERERR2 MSG   '          - WILL ASSUME EQ'
*
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
CHEKWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
CHARS    DS    CL16           CONVERSION TO CHARACTERS
CAMSEEK  CAMLST SEEK,*,*,*
CAMLEN   EQU   *-CAMSEEK
         DS    0D
CYLH     DS    F
         DS    X              PAD FOR CCHH
EQ       EQU   1              EQUATES FOR OPERATOR VALUES
NE       EQU   2
LT       EQU   3
LE       EQU   4
GT       EQU   5
GE       EQU   6
HWORK    DS    H
LIMVAL   DS    F
NUMBERL  DS    F
NUMLENL  DS    H
FLAGNML  DS    X
NUMKEYL  DS    X
NUMBER1  DS    F
NUMLEN1  DS    H
FLAGNM1  DS    X
NUMKEY1  DS    X
NUMBER2  DS    F
NUMLEN2  DS    H
FLAGNM2  DS    X
NUMKEY2  DS    X
NUMBER3  DS    F
NUMLEN3  DS    H
FLAGNM3  DS    X
NUMKEY3  DS    X
REFKEY   DS    F
REFOPER  DS    F
REFVAL   DS    A
REFNUM   DS    A
PDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN
PDLMINUS DC    X'00'
CHEKDBLW DS    D
CCHHCOMP DS    X
CCHHHIGH EQU   X'80'
CCHHEQ   EQU   X'40'
CCHHLOW  EQU   X'20'
CCHHX    EQU   X'08'
         DS    0D
LENWORK  EQU   *-CHEKWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         SPACE 3
DSCB1    DSECT
         IECSDSL1 1
         END
/*
//*------------------------------------------------------ ASM: VTOCCHEK
//*
//ASM3.SYSIN DD *
         TITLE 'VTOCEXCP- VTOC READING SUBROUTINE'
***********************************************************************
*        SPACE
* AUTHOR;  R. F. MORSE, MIT INSTRUMENTATION LABORATORY  AUG 5,1968.
* MODIFIED;   E.BANK, FIREMAN'S FUND  MAY 15,1975.
* MODIFIED;   R.MILLER  FIREMAN'S FUND  MAR 20,1977.
* FUNCTION; THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)
*        FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE CALLER
*        ONE RECORD (DSCB) AT A TIME.
*
* OPERATION; THIS ROUTINE IS A SPECIALIZED SEQUENTIAL ACCESS METHOD
*        FOR VTOC'S.  ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS
*        AN ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE
*        TIME.  THE ROUTINE HAS THREE CALL MODES;
*
*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD
*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,
*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA
*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (REGISTER 15)
*              ARE;
*                      0 - NORMAL;
*                      4 - END OF FILE, NO DATA PRESENTED;
*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS
*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL
*                          CONTAIN THE CORRECT CCHHR.  SINCE READING
*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S
*                          FOR THAT TRACK WILL BE MARKED IN ERROR.
*                          READING MAY CONTINUE ON TO THE NEXT TRACK.
*
*        1 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO
*              A  6-BYTE FIELD CONTAINING THE VOLSER TO BE USED FOR THE
*              ALLOCATION.
*              RETURN CODES ( REG 15 )  ARE DIRECT FROM DYNAMIC ALLOC.
*                      0 - NORMAL;
*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);
*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS
*                          DEVICE, OR DEVICE TYPE UNKNOWN.
*
*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN
*              CODE ( REG 15 ) IS FROM DYNAMIC UNALLOCATION.
         SPACE
* ENTRY POINTS:  ENTRY IS ALWAYS TO 'VTOCEXCP'.
*        ARGUMENTS ARE:
*                      1 - A(FULL-WORD BINARY ENTRY TYPE);
*                      2 - A(PTR FOR DSCB);
*                      3 - A(VOLSER).
* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS
*        DEVICE.  USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO
*        READ AN ENTIRE TRACK AT A TIME.
*
* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'IECPCNVT' TO CONVERT
*        A RELATIVE TRACK NUMBER TO AN ABSOLUTE ADDRESS.
         SPACE
* EXITS - NORMAL;  RETURNS TO CALLER VIA R14 WITH RETURN
*        CODE IN REGISTER 15.       (SEE ABOVE FOR RETURN CODE VALUES.)
*
* TABLES AND WORK AREAS;  USES AN AREA PROVIDED BY THE CALLER FOR
*        ITS SAVEAREA AND FOR WORKING STORAGE IMMEDIATELY FOLLOWING
*        THE PRIOR SAVEAREA.  IT USES GETMAIN TO OBTAIN AN AREA FOR
*        THE DSCB'S TO BE READ INTO.  THIS COULD BE AS LARGE AS
*        8K FOR 3350'S.  IT IS FREED BY THE FINAL CALL.
*
* ATTRIBUTES;  REENTRANT, REFRESHABLE.
         EJECT
* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.
         SPACE
VTOCEXCP ENTER 12,8                    USE THE PROVIDED SAVEAREA
         USING VTOCWORK,R13   SET ADDRESSABILITY FOR WORK AREA
         LR    R11,R1                  SAVE PARAMETER REGISTER
         USING VTOCOM,R11              SET ADDRESSABILITY
*
*        POINT TO THE DCB FOR LATER REFERENCES
*
         LA    RDCB,VTOCDCB   POINT TO IT
         USING IHADCB,RDCB    SET ADDRESSABILITY
         SPACE
* SELECT MODE FROM CONTENTS AT ADDRESS IN REGISTER 1.
         SPACE
         SR    RWA,RWA                 CLEAR THE REGISTER
         IC    RWA,VTCEFUNC            GET CALL MODE
         SLL   RWA,2                   MODE TIMES 4
         B     *+4(RWA)                BRANCH ON MODE
         SPACE
         B     GETDSB                  MODE 0, GET A DSCB
         B     OPEN                    MODE 1, OPEN A NEW VTOC
         B     CLOSE                   MODE 2, CLOSE
         B     RETURN0                 MODE 3 NOT DEFINED, NO OP
         SPACE 3
***********
* RETURNS *
***********
         SPACE
RETURN0  SR    R15,R15                 CLEAR THE RETURN CODE
RETURN   LEAVE EQ                      EXIT WITH THE CURRENT RET CODE
         EJECT
*********************
* MODE 0 - GET DSCB *
*********************
         SPACE
* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.
         SPACE
GETDSB   LA    R15,4                   SET THE RETURN CODE, IN CASE
         TM    MODESW,EOFSW            TEST END-OF-FILE BIT
         BO    RETURN                  RETURN CODE 4 IF ON
         SPACE
* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,
* ASSUME THERE IS AT LEAST ONE FULL BUFFER.
         SPACE
         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED
         BO    XCPTEST                 BRANCH IF SO
         SPACE
* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,
* EXIT WITH ITS ADDRESS IN R1.
         SPACE
         L     RWA,DSCBADR             LOAD BUFFER POINTER
         LA    RWA,148(RWA)            ADVANCE TO NEXT DSCB
NDXSTORE ST    RWA,DSCBADR             STORE UPDATED POINTER
         C     RWA,DSCBLIM             TEST IF LAST DSCB IN BUFFER
         BNL   LASTDSCB                BRANCH IF SO
         LR    R1,RWA                  PASS ADDRESS TO USER
GETOUT   ST    R1,DSCBADDR             STORE IT FOR THE CALLER
         TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK
         BZ    RETURN0                 RETURN CODE 0 IF NOT
         LA    R15,8                   SET THE RETURN CODE
         B     RETURN                  RETURN CODE 8 IF ERROR
         SPACE
* IF THIS IS THE LAST DSCB, MOVE IT TO THE INTERNAL BUFFER AND START
* READING THE NEXT TRACK.
         SPACE
LASTDSCB MVC   BUFF(148),0(RWA)        MOVE LAST DSCB
         L     RWB,TTRN                LOAD RELATIVE TRACK NUMBER
         AL    RWB,=X'00010000'        INCREMENT TO NEXT TRACK
         ST    RWB,TTRN
         BAL   RRET,EXCP               START CHANNEL PROGRAM
         LA    R1,BUFF                 LOAD DSCB ADDRESS FOR CALLER
         B     GETOUT                  TO RETURN
         EJECT
* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.
         SPACE
XCPTEST  WAIT  ECB=VTOCECB
         SPACE
         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF
         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE
         BNE   PERMERR                 BRANCH IF ERROR
SETDSCBA L     RWA,DSCBSTRT            SET BUFFER POINTER TO 1ST DSCB
         B     NDXSTORE
         SPACE
* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE
* CCHHR PORTIONS OF THE COUNT AREAS.
         SPACE
PERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR
         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG
         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1
         L     RWA,DSCBSTRT            LOAD ADDRESS OF FIRST DSCB
         LA    RWB,1                   LOAD RECORD NUMBER
         SPACE
DSCBELUP XC    0(148,RWA),0(RWA)       ZERO DSCB BUFFER
         MVC   0(4,RWA),IOBSEEK+3      INSERT CCHH IN COUNT FIELD
         STC   RWB,4(RWA)              INSERT R IN COUNT FIELD
         LA    RWA,148(RWA)            POINT TO NEXT BUFFER
         LA    RWB,1(RWB)              INCREMENT RECORD NUMBER
         C     RWA,DSCBLIM             TEST FOR LAST BUFFER
         BNH   DSCBELUP
         VTOCMSG TRACKERR       ISSUE THE ERROR MESSAGE
         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER
         EJECT
*****************
* MODE 1 - OPEN *
*****************
         SPACE
* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.  PERFORM CLOSE
* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.
         SPACE
OPEN     DS    0H
         BAL   RRET,CLOSESUB           CALL CLOSE SUBROUTINE
         SPACE
*
*        INITIALIZE THE DATA AREAS
*
*        FIRST THE DCB
         MVC   VTOCDCB(DCBLEN),VTOCDCBM  SET UP THE DCB
*
*        SET UP THE JFCB LISTS
*
         LA    R1,JEXLST      POINT TO THE EXIT LIST
         STCM  R1,B'0111',DCBEXLSA  PUT IT INTO THE DCB
         LA    R1,JFCBAREA    POINT TO THE JFCB AREA
         ST    R1,JEXLST      AND PUT THAT INTO THE EXIT LIST
         MVI   JEXLST,X'87'   END OF LIST, JFCB EXIT
         MVI   OPENLIST,X'80' END OF THE OPEN LIST TOO
*        INITIALIZE THE IOB
         MVC   VTOCIOB(IOBCONL),IOBCONST START IT OUT
         LA    R1,VTOCECB     GET THE ECB ADDRESS
         ST    R1,IOBECB      AND STORE IT INTO THE IOB
         ST    RDCB,IOBDCB    STORE THE DCB ADDRESS INTO THE IOB
*        INITIALIZE THE CAMLST
         MVC   DSCBFMT4(4),DSCBCON SET UP THE FIRST WORD
         LA    R1,IOBSEEK+3   SEEK ADDRESS
         ST    R1,DSCBFMT4+4  INTO THE CAMLST
         LA    R1,VOLID       VOLUME SERIAL NUMBER
         ST    R1,DSCBFMT4+8  INTO THE CAMLST
         LA    R1,FMT4        DSCB AREA
         ST    R1,DSCBFMT4+12 INTO THE CAMLST
*
*        ALLOCATE THE VTOC OF THE CHOSEN PACK
*
         LA    R1,ADDR        POINT TO THE UNIT ADDRESS
         ST    R1,UNITADDR    SAVE THE ADDRESS
         LA    R1,3           ALSO GET THE LENGTH
         STH   R1,UNITLEN     AND SAVE IT FOR DYNAMIC ALLOCATION MACRO
         LA    R1,VOLID       POINT TO THE VOLUME SERIAL
         ST    R1,VOLADDR     SAVE THE ADDRESS
         LA    R1,6           ALSO GET THE LENGTH
         STH   R1,VOLLEN      AND SAVE IT FOR DYNAMIC ALLOCATION MACRO
         ALLOC DSN=VTOCNM,VOL=VOLADDR,UNIT=UNITADDR,DISP=SHR,          X
               DDNTO=DCBDDNAM,ERROR=S99FAIL
         OI    MODESW,ALLOCSW          SET ALLOCATE FLAG ON
         SPACE
* OPEN THE VTOC.
         SPACE
*
*        FIRST READ THE JFCB TO SWITCH THE DSNAME TO HEX 04'S
*
         RDJFCB ((RDCB)),MF=(E,OPENLIST)  READ THE JFCB
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   ERRJFCB        BAD NEWS
         LA    R1,JFCBAREA    POINT TO THE JFCB
         USING JFCB,R1        SET UP ADDRESSABILITY
         MVI   JFCBDSNM,X'04' PUT IN THE FIRST ONE
         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM  PROPAGATE IT
         OI    JFCBTSDM,JFCNWRIT  DON'T REWRITE IT
         DROP  R1
         OPEN  ((RDCB),(INPUT)),MF=(E,OPENLIST),TYPE=J  OPEN THE VTOC
         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED
         BZ    OPENERR                 ERROR IF OPEN FAILED
         SPACE
* ISSUE AN OBTAIN FOR THE FIRST DSCB ON THE VTOC ( FORMAT 4 )
D3       STM   R2,R13,EXCPSAVE         SAVE OUR REGS
         LA    R3,EXCPSAVE    POINT TO THE REGISTER SAVE AREA
         ICM   R0,B'1111',=X'00000100' FIRST DSCB
         L     R1,DCBDEBAD             DEB ADDRESS
         LA    R2,IOBSEEK              SAVE ADDRESS OF CCHHR
         L     R15,CVT                 GET ADDRESS OF CVT
         L     R15,CVTPCNVT(R15)       GET ADDRESS OF CONVERT ROUTINE
         BALR  R14,R15                 GO TO CONVERT ROUTINE
         LM    R2,R13,0(R3)            GET MY REGS BACK
         OBTAIN DSCBFMT4               GET FORMAT 4 DSCB
         LTR   R15,R15                 DID WE GET IT
         BNZ   OBTERR                  NO - THEN ERROR, KEEP R15
         CLI   DS4IDFMT,X'F4'          MAKE SURE WE HAVE FORMAT 4
         BNE   NOTFMT4                 NO - THEN ERROR
         IC    R15,DS4DEVDT            GET NUMBER OF DSCBS PER TRACK
         ST    R15,NDSCBS              SAVE THE NUMBER OF DSCBS
         OC    NDSCBS,NDSCBS           MAKE SURE NOT ZERO
         BZ    DSCBNUM0                YES - GO TELL CALLER
*
* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.
         SPACE
         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW
         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK
         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING
         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE
         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE
         GETMAIN  R,LV=(0)             GET TRACK BUFFERS
         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE
         OI    MODESW,CBGOT            INDICATE CORE GOTTEN
         SPACE
* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH
* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR
* EACH DSCB.
         SPACE
         L     RWA,NDSCBS              NUMBER OF DSCB'S
         SLL   RWA,3                   TIMES   8
         LA    RWA,8(RWA,R1)           PLUS 8 AND BASE = 1ST BUFFER ADD
         ST    RWA,DSCBSTRT            SAVE ADDRESS OF FIRST BUFFER
         SPACE
         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM
         MVC   0(8,R1),INITCCW         INSERT FIRST CCW
         LA    RWB,8(R1)               PLACE FOR NEXT CCW
         LA    RWC,1                   BUFFER COUNTER
         SPACE
CCWLOOP  MVC   0(8,RWB),READCCW        INSERT READ CCW FOR ONE DSCB
         ST    RWA,0(RWB)              SET ITS BUFFER ADDRESS
         MVI   0(RWB),READCKD          RESTORE COMMAND CODE
         C     RWC,NDSCBS              TEST BUFFER COUNTER
         BNL   LASTCCW                 BRANCH IF LAST BUFFER
         LA    RWB,8(RWB)              INCREMENT CCW ADDRESS
         LA    RWA,148(RWA)            INCREMENT BUFFER ADDRESS
         LA    RWC,1(RWC)              INCREMENT BUFFER COUNTER
         B     CCWLOOP                 DO NEXT BUFFER
         SPACE
LASTCCW  NI    4(RWB),X'FF'-CC         TURN OFF COMMAND CHAIN BIT
         ST    RWA,DSCBLIM             SAVE ADDRESS OF LAST DSCB BUFFER
         SPACE
* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.
         SPACE
         SR    R0,R0
         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0
         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF
         BAL   RRET,EXCP               START CHANNEL PROGRAM
         B     RETURN0                 INDICATE SUCCESSFUL OPEN
         EJECT
******************
* MODE 2 - CLOSE *
******************
         SPACE
CLOSE    BAL   RRET,CLOSESUB           CALL CLOSED CLOSE SUBROUTINE
         B     RETURN0
         SPACE 2
* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER
* ACTION.
         SPACE
CLOSESUB DS    0H
         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING
         BZ    NOEXCP                  BRANCH IF NOT
         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE
         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF
NOEXCP   DS    0H
         SPACE
* CLOSE THE DCB.
         SPACE
         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN
         BZ    NOCLOSE                 BRANCH IF NOT
         CLOSE ((RDCB)),MF=(E,OPENLIST)   CLOSE THE VTOC
NOCLOSE  DS    0H
         SPACE
* FREE UP THE DDNAME AND VOLUME
         SPACE
         TM    MODESW,ALLOCSW          DID WE ALLOCATE A DEVICE
         BNO   NOALLOC                 NO  - THEN NOTHING TO FREEUP
         LA    R1,DCBDDNAM   POINT TO THE DDNAME
         ST    R1,DDNPDL     SAVE IT FOR FREE
         LA    R1,8          GET THE DDNAME LENGTH
         STH   R1,DDNPDL+4   SAVE IT FOR FREE
         FREE  UNALC,DDN=DDNPDL,ERROR=S99FAIL  FREE THE DDNAME
         NI    MODESW,X'FF'-ALLOCSW    TURN OFF ALLOCATE SW
         SPACE
NOALLOC  DS    0H
         SPACE
* RELEASE CORE OBTAINED FOR DSCB BUFFERS.
         SPACE
         TM    MODESW,CBGOT            TEST IF CORE GOTTEN
         BZ    NOFREE                  BRANCH IF NOT
         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION
         FREEMAIN  R,LV=(0),A=(1)      FREE CORE
         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF
NOFREE   DS    0H
         SPACE
         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH
         BR    RRET
         EJECT
****************
* EXCP ROUTINE *
****************
         SPACE
* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN
* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.
         SPACE
EXCP     DS    0H
         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS
         LA    R3,EXCPSAVE             SAVE REGS FOR RESTORING AFTER CL
         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER
         L     R1,DCBDEBAD             LOAD DEB ADDRESS
         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR
         L     R15,CVT                 LOAD CVT ADDRESS
         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE
         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR
*                                      THAT CLOBBERED BASE REG
         LM    R2,R13,0(R3)            RESTORE REGISTERS
         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)
         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE
         CLC   DS4HPCHR,IOBSEEK+3      CHECK FOR THE LAST FMT1
         BL    SETEOF                  IF SO, PRETEND END-OF-FILE
         SPACE
* ZERO ECB AND START CHANNEL PROGRAM.
         SPACE
         SR    R0,R0
         ST    R0,VTOCECB              CLEAR ECB
         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH
         EXCP  VTOCIOB                 START CHANNEL PROGRAM
         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG
         BR    RRET
         SPACE
* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.
         SPACE
SETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT
         B     CLOSESUB                EXIT VIA CLOSE SUBROUTINE
         EJECT
********************************
* DAIRFAIL ROUTINE             *
********************************
S99FAIL  LR    R15,RRCODE     SAVE THE RETURN CODE
         S99FAIL MF=(E,S99FLIST,S99FLEN)  ISSUE THE APPROPRIATE MSG
         LR    R15,RRCODE     RELOAD THE RETURN CODE
         B     RETURN         AND THEN EXIT
         SPACE 3
*
*        VARIOUS OTHER ERROR ROUTINES
*
OPENERR  VTOCMSG OPENERRM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
OBTERR   VTOCMSG OBTERRM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
NOTFMT4  VTOCMSG NOTFMT4M  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
DSCBNUM0 VTOCMSG DSCBNUMM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
*
ERRJFCB  VTOCMSG ERRJFCBM   ERROR IN READING JFCB
*
ERRET    LA    R15,8          SET AN ERROR RETURN CODE
         B     RETURN         THEN EXIT
*
         EJECT
********************************
* CONSTANTS, VARIABLES, ETC... *
********************************
         SPACE
*        ERROR MESSAGES
*
OPENERRM MSG   ' VTOCEXCP - ERROR IN OPENING VTOC '
OBTERRM  MSG   ' VTOCEXCP - ERROR IN OBTAIN '
NOTFMT4M MSG   ' VTOCEXCP - FORMAT 4 DSCB WAS NOT FIRST'
DSCBNUMM MSG   ' VTOCEXCP - THE FORMAT 4 DSCB HAS DSCB S/TRK = 0 '
TRACKERR MSG   ' VTOCEXCP - A READ ERROR OCCURRED ON THE VTOC '
ERRJFCBM MSG   ' VTOCEXCP - A RDJFCB ERROR OCCURRED '
         SPACE
INITCCW  CCW   READR0,0,CC+SLI+SKIP,8
READCCW  CCW   READCKD,0,CC,148
         SPACE
DSCBCON  CAMLST SEEK,0,0,0   FILLED IN WITH IOBSEEK+3, VOLID, FMT4
         EJECT
* DATA CONTROL BLOCK
         PRINT   GEN
VTOCDCBM DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1
DCBLEN   EQU   *-VTOCDCBM
         SPACE
* IOB FOR CHANNEL PROGRAM
         SPACE
IOBCONST DS    0D
         DC    X'42000000'     COMMAND CHAIN, NOT RELATED
         DC    A(0)            ECB ADDRESS
         DC    2F'0'
         DC    A(0)            CHANNEL PROGRAM BEGINNING
         DC    A(0)            DCB ADDRESS
         DC    X'03000000'
         DC    F'0'
         DC    D'0'            INITIAL SEEK ADDRESS
IOBCONL  EQU   *-IOBCONST
* VTOC NAME FOR ALLOCATION
VTOCNM   DC    A(VTOCNAME)
         DC    Y(12)
VTOCNAME DC    CL12'FORMAT4.DSCB'   DATA SET NAME FOR VTOC
*
*
         LTORG
         EJECT
* SECTION DEFINITION AND REGISTER ASSIGNMENTS;
         SPACE 2
RWA      EQU   2
RWB      EQU   3
RWC      EQU   4
RDCB     EQU   8              DCB POINTER
RRCODE   EQU   10              RETURN CODE REGISTER
RRET     EQU   9               LOCAL SUBROUTINE EXIT REGISTER
         SPACE 3
* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:
         SPACE
READR0   EQU   X'16'           READ RECORD 0
READCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA
         SPACE
CC       EQU   X'40'           COMMAND CHAIN FLAG
SLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG
SKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG
         SPACE 3
* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:
         SPACE
CVT      EQU   16              LOCATION OF CVT BASE ADDRESS
CVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS
         EJECT
*
*        AREA USED BY VTOCREAD, PASSED VIA R13
*
VTOCWORK DSECT
         DS    18F             SAVE AREA
         SPACE
EXCPSAVE DS    18F             INTERNAL SAVE AREA
CBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE
CBADDR   EQU   CBSIZE+4
NDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK
DSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER
DSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER
DSCBADR  DS    F               ADDRESS OF CURRENT DSCB
TTRN     DS    F               RELATIVE TRACK NUMBER
VOLADDR  DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS
VOLLEN   DS    H                       AND LENGTH OF VOLID
UNITADDR DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS
UNITLEN  DS    H                       AND LENGTH OF UNIT ADDRESS
DDNPDL   DS    2F            SPACE FOR DDNAME PDL
         SPACE
* MODE SWITCH AND BIT DEFINITIONS
         SPACE
MODESW   DC    X'00'
CBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER
XCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED
RDERR    EQU   X'20'           PERMANENT I/O ERROR
EOFSW    EQU   X'10'           END-OF-FILE SENSED
ALLOCSW  EQU   X'08'           ALLOCATE VOLUME FLAG
         SPACE
VTOCDCB  DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1
         SPACE
OPENBIT  EQU   X'10'
OPENLIST DS    2F
         SPACE
* IOB FOR CHANNEL PROGRAM
         SPACE
VTOCIOB  DS    0D
IOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED
IOBECB   DC    A(VTOCECB)
         DC    2F'0'
IOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING
IOBDCB   DC    A(VTOCDCB)
         DC    X'03000000'
         DC    F'0'
IOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS
         SPACE
* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:
         SPACE
VTOCECB  DC    F'0'            EVENT CONTROL BLOCK
         SPACE 3
* INTERNAL BUFFER FOR LAST DSCB
BUFF     DS    XL148
         SPACE 2
DSCBFMT4 CAMLST SEEK,IOBSEEK+3,VOLID,FMT4
         SPACE
*   WORK AREA FOR DYNAMIC ALLOCATION
         DYNSPACE
S99FLIST DS    XL(S99FLEN)
         SPACE
*
*        JFCB EXIT LIST AND AREA
*
JEXLST   DS    F
JFCBAREA DS    XL176
         DS    0D
VTOCWLEN EQU   *-VTOCWORK
         SPACE 2
         PRINT GEN
         VTOCOM
         PRINT NOGEN
         SPACE 2
         IEFZB4D0
         SPACE 2
         IEFZB4D2
         SPACE 2
         DCBD  DEVD=DA,DSORG=PS
         SPACE 2
JFCB     DSECT
         IEFJFCBN
         END
/*
//*------------------------------------------------------ ASM: VTOCEXCP
//*
//ASM4.SYSIN DD *
         TITLE 'VTOC COMMAND FORMAT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
* TITLE -      VTOC COMMAND FORMAT ROUTINE                            *
*                                                                     *
* FUNCTION -   FORMAT THE DATA INTO THE VTFMT  DSECT FROM THE         *
*              FORMAT 1 ( AND 3 IF NEEDED ) DSCB.  THIS ROUTINE       *
*              ALSO GETS THE AREA TO CONTAIN THE FORMATTED            *
*              DSCB INFORMATION.                                      *
*                                                                     *
* OPERATION -  FIRST GET AN AREA FROM THE CURRENT BLOCK, OR GET       *
*              A BLOCK ( 32K ) OF STORAGE TO USE FOR THE FORMATTED    *
*              DSCB'S.  MOVE THE DATA OVER FROM THE FORMAT 1 DSCB.    *
*              THE SPACE CALCULATIONS MAY NEED THE FORMAT 3 DSCB.     *
*              CATALOG INFORMATION IS OBTIANED VIA LOCATE.  SOME      *
*              OF THE DSCB INFORMATION IS CONVERTED HERE.             *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, LOCATE         *
*                                                                     *
* OUTPUT -     THE FORMATTED DSCB INFORMATION WITH ITS ADDRESS IN     *
*              FORMATAD.                                              *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
*
         EJECT
         MACRO
&LAB     DS1TST  &FIELD,&VALUE,&CODE
&LAB     TM    DS1&FIELD,X'&VALUE'  TEST IT
         BNO   D&SYSNDX       IF NOT THERE, SKIP ALONG
         MVC   VTF&FIELD,=CL3'&CODE'
D&SYSNDX DS    0H
         MEND
*
*
         EJECT
VTOCFORM ENTER 12,16          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING FORMWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        CHECK FOR THE FIRST TIME THROUGH
*        IF SO, PERFORM SOME INITIALIZATION
*
         CLI   FIRSTFRM,0     IS THIS THE FIRST TIME?
         BNE   GETAREA        NO, KEEP ON TRUCKIN'
*
*        ROUTINE INITIALIZATION
*
         MVI   FIRSTFRM,255   NOTE THE INITIALIZATION AS DONE
         MVC   CAMLOC(CAMLEN),CAMCONST  SET UP THE CAMLST
*
*        FIND OR GET AN AREA FOR THE FORMATTED DSCB
*              FIRST SEE HOW BIG IT IS
*
GETAREA  L     R7,DSCBADDR    POINT TO THE DSCB
         LA    R7,8(R7)       GET PAST THE HEADER
         USING DSCB1,R7       SET ADDRESSABILITY
         LH    R1,DSNLEN     GET THE DSNAME LENGTH
         LA    R4,VTFMTL(R1)  GET THE FORMATTED DSCB LENGTH
*
*        SEE IF THE CURRENT BLOCK CAN HANDLE IT
*
FORMFIT  L     R3,VTCCURLN    GET THE CURRENT AVAILABLE
         SR    R3,R4          SEE IF IT WILL FIT
         BM    GOGETMN        NO, GET ANOTHER BLOCK
*
*        NO SWEAT, GET THE SPACE FROM THIS BLOCK
*
         ST    R3,VTCCURLN    STORE THE NEW ( REDUCED ) CURRENT LENGTH
         L     R3,VTCCURAD    POINT TO THE CURRENT ADDRESS
         LA    R5,0(R3,R4)    POINT TO THE END OF THE BLOCK
         ST    R5,VTCCURAD    AND PLACE THE NEW AVAILABLE ADDRESS
*
*        NOW FILL IN THE DATA IN THE FORMATTED DSCB
*
         USING VTFMT,R3       SET FORMATTED DSCB ADDRESSABILITY
         ST    R3,FORMATAD    SAVE THIS BLOCK'S ADDRESS
         XC    VTFNEXT,VTFNEXT  CLEAR THE SORT POINTER
         MVC   VTFVOLUM,VOLID SAVE THE VOLUME SERIAL NUMBER
         LH    R1,DSNLEN     GET THE LENGTH OF THE DSNAME
         STH   R1,VTFDSNL     SAVE THE DSNAME LENGTH
         BCTR  R1,0           SUBTRACT ONE FOR THE EX
         EX    R1,MOVEDSN     MOVE IN THE DSNAME
         MVC   VTFNOEPV,DS1NOEPV  NUMBER OF EXTENTS
         MVC   VTFLRECL,DS1LRECL  LOGICAL RECORD LENGTH
         MVC   VTFBLKSZ,DS1BLKL   BLOCK SIZE
*
*     MOVE IN THE CREATION DATE, EXPIRATION DATE, AND LAST ACCESS DATE
*
         MVC   VTFCREDT,DS1CREDT  MOVE OVER CREATION DATE
         MVC   VTFEXPDT,DS1EXPDT  MOVE OVER EXPIRATION DATE
         MVC   VTFLSTAC,DS1REFD   MOVE OVER LAST ACCESS DATE
*
*        FORMAT THE RECORD FORMAT INTO CHARACTERS
*
*
         MVC   VTFRECFM,BLANKS  BLANK THE FIELD TO START
         MVC   VTFACTON,BLANKS  ANOTHER BLANK FIELD
         MVI   VTFDSTYP,C' ' AND STILL ANOTHER
         LA    R2,VTFRECFM    POINT TO THE FIELD
         TM    DS1RECFM,X'C0' UNKNOWN RECFM?
         BZ    RECFM2         YES, TROUBLE
         TM    DS1RECFM,X'40' IS IT FIXED?
         BNZ   RECFM3         NO, KEEP TRYING
         MVI   0(R2),C'F'     YES, SET UP THE FIRST CHAR
         LA    R2,1(R2)       AND BUMP THE POINTER
         B     RECFM2         CHECK OTHER ATTRIBUTES
RECFM3   TM    DS1RECFM,X'80' SEE IF IT'S V OR U
         BZ    RECFM4         VARIABLE RECFM
         MVI   0(R2),C'U'     RECFM = U
         B     RECFM4A        ADD TO THE POINTER AND KEEP LOOKING
RECFM4   MVI   0(R2),C'V'     VARIABLE
RECFM4A  LA    R2,1(R2)       GET PAST THIS CHAR
RECFM2   DS    0H
RECFM5   TM    DS1RECFM,X'10' IS IT BLOCKED?
         BZ    RECFM6         NO, SKIP ON
         MVI   0(R2),C'B'     YES, SET THE SYMBOL
         LA    R2,1(R2)       GET PAST THE CHAR
RECFM6   TM    DS1RECFM,X'08' IS IT SPANNED OR STANDARD?
         BZ    RECFM6A        NO
         MVI   0(R2),C'S'     YES, SET IT
         LA    R2,1(R2)       GET PAST THIS CHARACTER
RECFM6A  TM    DS1RECFM,X'20' CHECK TRACK OVERFLOW
         BZ    RECFM7         NO DICE
         MVI   0(R2),C'T'     YES, SET IT
         LA    R2,1(R2)       PUSH THE POINTER ON
RECFM7   TM    DS1RECFM,X'04' IS IT ASA CONTROL
         BZ    RECFM8         NO, SKIP ON
         MVI   0(R2),C'A'     YES, SET IT
         LA    R2,1(R2)       GET PAST THIS CHAR
RECFM8   TM    DS1RECFM,X'02' HOW ABOUT MACHINE CARRIAGE CONTROL
         BZ    RECFM9         NO, SKIP ON
         MVI   0(R2),C'M'     YES, SET IT
RECFM9   DS    0H
*
*        FORMAT THE DSORG
*
         MVC   VTFDSORG,=CL3'   '  CLEAR THE FIELD
         DS1TST DSORG,80,IS   TRY ISAM
         DS1TST DSORG,40,PS   TRY SEQUENTIAL
         DS1TST DSORG,20,DA   TRY DIRECT ACCESS
         DS1TST DSORG,02,PO   TRY PARTITIONED
         CLC   DS1DSORG(2),=X'0008'  IS IT VSAM?
         BNE   DSORG05       NO, KEEP LOOKING
         MVC   VTFDSORG,=CL3'VS ' YES, FLAG IT
DSORG05  TM    DS1DSORG,X'01'      IS IT UNMOVEABLE?
         BNO   DSORG06       NO, KEEP ON TRUCKIN'
         MVI   VTFDSORG+2,C'U'     YES, NOTE IT
DSORG06  DS    0H
*
*        FORMAT THE SECONDARY ALLOCATION
*
         SR    R1,R1          CLEAR A WORK REGISTER
         IC    R1,DS1SCALO    GET THE ALLOCATION FLAG
         SRL   R1,6           REMOVE THE BOTTOM 6 BITS ( 75 CENTS )
         IC    R2,SECAL(R1)   GET THE CHARACTER CODE
         STC   R2,VTFSECAL    AND SAVE IT FOR LATER
         MVC   VTFSECAM,DS1SCALO+2  SAVE THE SECONDARY AMOUNT TOO
         MVI   VTFROUND,C'N'  SET CODE FOR NO ROUND
         TM    DS1SCALO,X'01' SEE IF ROUND WAS SET
         BNO   PROTFORM       NO, THE CODE IS SET RIGHT
         MVI   VTFROUND,C'R'  YES, RESET THE CODE
*
*        FORMAT THE PASSWORD PROTECTION
*
PROTFORM TM    DS1DSIND,X'14' CHECK THE PASSWORD BITS
         BO    PROTWRIT       WRITE PROTECT IS X'14'
         BM    PROTREAD       READ PROTECT IS X'10'
         MVI   VTFPROT,C'N'   NO PASSWORD PROTECTION
         B     PROTEND        END OF PROTECTION FORMATTING
PROTWRIT MVI   VTFPROT,C'W'   SET CODE FOR WRITE PROTECT
         B     PROTEND        THEN CHECK OTHER ITEMS
PROTREAD MVI   VTFPROT,C'R'   SET CODE FOR READ/WRITE PROTECT
PROTEND  DS    0H             END OF PROTECTION FORMATTING
*
*        FORMAT THE CATLG
*
         MVI   VTFCATLG,C' ' INITIALIZE IT TO BLANKS
         CLI   CATK+1,0       SHOULD WE DO THE LOCATE?
         BE    CATEND         NO, SKIP PAST IT
*
*        SET UP THE CAMLST
*
         LA    R1,DS1DSNAM    POINT TO THE DSNAME
         ST    R1,CAMLOC+4    SAVE IT IN THE CAMLST
         LA    R1,LOCWORK     LOCATE WORKAREA
         ST    R1,CAMLOC+12   SAVE IT IN THE CAMLST
         LOCATE CAMLOC        CHECK THE CATALOG
         LTR   R15,R15        TEST THE CATALOG RETURN CODE
         BZ    CATOK          ZERO, THERE IS AN ENTRY
         MVI   VTFCATLG,C'N'  SET CODE FOR NOT CATALOGED
         CH    R15,H8         SEE IF THAT'S THE CASE
         BE    CATEND         YES, LET IT STAND
         MVI   VTFCATLG,C'E'  CATALOG ERROR, PROBLEMS
*
*        CATALOG ENTRY IS THERE, SEE THAT THE VOLUME IS THIS ONE
*
CATOK    MVI   VTFCATLG,C'C'  SET UP AS A GOOD ENTRY
         CLC   VOLID,LOCWORK+6  COMPARE THE VOLUME SERIAL NUMBERS
         BE    CATEND         GOOD, WE'RE DONE
         MVI   VTFCATLG,C'W'  WRONG VOLUME, NOT CATALOGED
CATEND   DS    0H
*
*        FORMAT THE ALLOCATION AND USED QUANTITIES
*
         SPACE
*        CHECK THROUGH THE EXTENTS
         SPACE
         SR    R2,R2          CLEAR A WORK REGISTER
         ICM   R2,B'0001',DS1NOEPV  GET THE NUMBER OF EXTENTS
         BZ    SPACEND        NO EXTENTS MEANS NO SPACE
         SR    R4,R4          ZERO THE SPACE COUNTER FOR THE DATA SET
*
*        GET EACH EXTENT AND PROCESS IT
*
         SR    R6,R6          FIRST EXTENT
EXTNEXT  LR    R5,R6          GET THE CURRENT EXTENT NUMBER
         SLL   R5,2           MULTIPLY IT BY FOUR
         EX    R0,GETEXT(R5)  GET THE CORRECT ADDRESS
*
*        PROCESS THIS EXTENT
*
         USING XTDSECT,R5     SET ADDRESSABILITY
         CLI   XTFLAGS,XTNOEXT  IS THERE AN EXTENT
         BE    NOEXT          NO, THE EXTENT ISN'T THERE
         CLI   XTFLAGS,XTCYLBD  IS IT ON CYLINDER BOUNDARIES
         BNE   FORMALOC       NO, DO IT FOR CYLS AND TRACKS
*
*        CYLINDER BOUNDS - BE SURE THE ALLOCATION IS CORRECT
*
         ICM   R1,B'0011',XTLOWHH GET THE LOWER TRACK
         BZ    LOWOK          IT'S ZERO
         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR
         MVI   VTFACTON+6,C'L'  ON THE LOW CCHH
LOWOK    LH    R1,XTHIHH      GET THE HIGH TRACK
         LA    R1,1(R1)       ADD ONE FOR ZERO ADDRESSING
         CH    R1,DS4DEVSZ+2  IS THIS THE NUMBER OF TRACKS/CYL
         BE    FORMALOC       YES, GO CALCULATE
         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR
         MVI   VTFACTON+7,C'H'  ON THE HIGH CCHH
*
*        GET THE SPACE FOR NON-CYLINDER ALLOCATIONS
*
FORMALOC LH    R1,XTHICC      GET THE HIGH CYLINDER
         SH    R1,XTLOWCC     MINUS THE LOW CYLINDER
         MH    R1,DS4DEVSZ+2  TIMES THE NUMBER OF TRACKS PER CYLINDER
         LH    R8,XTHIHH      GET THE HIGH TRACK
         SH    R8,XTLOWHH     MINUS THE LOW TRACK
         AR    R8,R1          TRACKS IN THIS EXTENT ( MINUS 1 )
         LA    R4,1(R4,R8)    ADD THE TRACKS TOGETHER FOR THIS DATA SET
*
*        GET THE NEXT EXTENT
*
NOEXT    LA    R6,1(R6)       INCREMENT THE EXTENT COUNTER
         CR    R6,R2          CHECK FOR THE END
         BL    EXTNEXT        NOT YET, KEEP GOING
*
*        ALL THE EXTENTS ARE SUMMED REGISTER 4 HAS THE SUM
*
         BAL   R8,SPACUNIT    CHANGE IT TO THE APPROPRIATE UNITS
         ST    R4,VTFALLOC    STORE IT FOR LATER
SPACEND  DS    0H
*
*        GET THE TRACKS USED
*
         SR    R4,R4          CLEAR THE TRACK ( WOO WOO )
         CLC   DS1LSTAR,ZEROES IS THE TRACK USED COUNTER SET?
         BNE   USEDOK         YES, ACCEPT IT
*        NO, SEE IF THE ZERO IS VALID
         TM    DS1DSORG,X'40' IS IT SEQUENTIAL?
         BO    USEDOK0        YES,THE ZERO IS VALID
         CLC   DSORG(4),ZEROES  MAYBE IT WASN'T EVER OPENED
         BE    USEDOK0        THEN NO SPACE USED IS OK
         TM    DS1DSORG,X'0C' CHECK FOR AN INVALID DSORG
         BO    USEDOK0        NO SPACE USED IS STILL OK
         MVC   VTFUSED,FMIN1  SET A FLAG UNUSED SPACE UNKNOWN
         B     USEDEND        USED SPACE IS SET
*
*        THE TRACKS USED COUNTER SEEMS OK
*
USEDOK   LH    R4,DS1LSTAR    GET THE LAST TRACK USED
         LA    R4,1(R4)       ADD ONE ( ZERO ADDRESSING )
         BAL   R8,SPACUNIT    CONVERT TO APPROPRIATE UNITS
USEDOK0  ST    R4,VTFUSED     SAVE THE AMOUNT OF SPACE USED
USEDEND  DS    0H
         L     R14,VTFALLOC   ALLOCATED TRACKS
         S     R14,VTFUSED    MINUS USED TRACKS
         ST    R14,VTFUNUSD   EQUALS UNUSED TRACKS
         SR    R14,R14
         SR    R15,R15
         CLC   VTFALLOC(4),=F'0'
         BE    USEDEND1
         L     R15,VTFUSED    USED TRACKS
         M     R14,=F'100'    MULT BY 100 TO GET PCT
         D     R14,VTFALLOC   DIVIDE BY ALLOC TO GET PCT USED
USEDEND1 STH   R15,VTFPCT     SAVE PCT USED
*
*        RETURN
*
FORMRET  LEAVE EQ,RC=0
*
*
         EJECT
*
*        ROUTINES USED ABOVE
*
*
*        CONVERT FROM TRACKS TO THE APPROPRIATE UNITS
*              KBYTES, MBYTES, TRKS, OR CYLS
*
SPACUNIT LH    R1,SPACEK      GET THE UNIT TYPE
         SLL   R1,2           MULTIPLY BY 4
         B     *+4(R1)        THEN BRANCH TO THE CORRECT ROUTINE
         B     SPACTRK        R1=0  KILOBYTES
         B     SPACTRK        R1=1  KILOBYTES
         B     SPACTRK        R1=2  MEGABYTES
         B     SPACTRK        R1=3  TRACKS
         B     SPACTRK        R1=4  CYLINDERS
*        TRACKS
SPACTRK  BR    R8             WAS SET WHEN WE STARTED
*        CYLINDERS
SPACCYL  SR    R0,R0          CLEAR A REGISTER
         LR    R1,R4          GET THE NUMBER OF TRACKS
         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER
         SRL   R4,2           DIVIDE BY 2 FOR ROUNDING
         AR    R1,R4          ADD IT IN
         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER
         DR    R0,R4          DIVIDE TO GET ROUNDED CYLINDERS
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*        KILOBYTES
SPACKB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK
         SR    R0,R0          CLEAR THE TOP
         LR    R1,R4          GET THE NUMBER TO DIVIDE
         A     R1,F500        ADD UP TO ROUND
         D     R0,F1000       DIVIDE TO GET KILOBYTES
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*        MEGABYTES
SPACMB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK
         SR    R0,R0          CLEAR THE TOP
         LR    R1,R4          GET THE NUMBER TO DIVIDE
         A     R1,F500000     ADD UP TO ROUND
         D     R0,F1000000    DIVIDE TO GET MEGABYTES
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*
*        GET A NEW BLOCK OF MAIN STORAGE
*
GOGETMN  GETMAIN R,LV=VTCGETMS  GET SOME
         ST    R1,VTCCURAD    SET UP THE AVAILABLE ADDRESS
         LA    R2,VTCGETMS/1024   GET THE SIZE OF THE BLOCK IN K
         SLL   R2,10          GET IT INTO BYTES ( TIMES 1024 )
         ST    R2,VTCCURLN    SO THE FORMATTED DSCB'S CAN USE IT
*
*        SAVE THE BLOCK ADDRESS IN THE VTCGETMN TABLE
*
         LA    R2,VTCGETMN    POINT TO THE TABLE
         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE
GOGETTAB ICM   R3,B'1111',0(R2) GET THIS ENTRY
         BNZ   GOGETINC       IF NOT ZERO, KEEP LOOKING
         ST    R1,0(R2)       SAVE THE NEW ENTRY
         B     FORMFIT        THEN GO ALLOCATE A FORMATTED DSCB
*
*        THIS ENTRY WAS TAKEN, GET THE NEXT ONE
*
GOGETINC LA    R2,4(R2)       POINT TO THE NEXT ENTRY
         BCT   R5,GOGETTAB    COUNT AND LOOP
*
*        TABLE OVERFLOW  - ISSUE ERROR MSG
*              SET A FLAG TO STOP INPUT
*
         VTOCMSG TABOVFLW,TABOVSEC  ISSUE A MESSAGE
         MVI   TABFULL,255    SET A STOP FLAG
         B     FORMRET        RETURN FROM FORMATTING
         EJECT
*
*
*
*        PROGRAM CONSTANTS
*
         SPACE
*        INSTRUCTIONS EXECUTED TO GET THE NEXT EXTENT
GETEXT   LA    R5,DS1EXT1        1ST EXTENT
         LA    R5,DS1EXT2        2ND EXTENT
         LA    R5,DS1EXT3        3RD EXTENT
         LA    R5,DS3EXTNT+00    4TH EXTENT
         LA    R5,DS3EXTNT+10    5TH EXTENT
         LA    R5,DS3EXTNT+20    6TH EXTENT
         LA    R5,DS3EXTNT+30    7TH EXTENT
         LA    R5,DS3ADEXT+00    8TH EXTENT
         LA    R5,DS3ADEXT+10    9TH EXTENT
         LA    R5,DS3ADEXT+20   10TH EXTENT
         LA    R5,DS3ADEXT+30   11TH EXTENT
         LA    R5,DS3ADEXT+40   12TH EXTENT
         LA    R5,DS3ADEXT+50   13TH EXTENT
         LA    R5,DS3ADEXT+60   14TH EXTENT
         LA    R5,DS3ADEXT+70   15TH EXTENT
         LA    R5,DS3ADEXT+80   16TH EXTENT
MOVEDSN  MVC   VTFDSN(0),DS1DSNAM   EXECUTED COMPARE
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
F500     DC    F'500'
F1000    DC    F'1000'
F500000  DC    F'500000'
F1000000 DC    F'1000000'
BLANKS   DC    CL8'                '
CAMCONST CAMLST NAME,*,,*
H8       DC    H'8'
SECAL    DC    C'ABTC'        SECONDARY ALLOCATION CODES
*              ABSOLUTE TRK, BLOCKS, TRACKS, CYLINDERS
*
*
*
         PRINT NOGEN
*
*        PROGRAM MESSAGES
*
TABOVFLW MSG   ' THE VTOC TABLES (1.6 MEG) ARE NOT LARGE ENOUGH TO HANDX
               LE THIS REQUEST'
TABOVSEC MSG   ' PARTIAL PROCESSING WILL CONTINUE '
*
*
*
*
*
*
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
FORMWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
FIRSTFRM DS    X              INITIALIZATION FOR THIS ROUTINE
CHARS    DS    CL16           CONVERSION TO CHARACTERS
CAMLOC   CAMLST NAME,*,,*
CAMLEN   EQU   *-CAMLOC
         DS    0D
LOCWORK  DS    265C
         SPACE
         DS    0D
LENWORK  EQU   *-FORMWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         PRINT GEN
         VTFMT
         PRINT NOGEN
         SPACE 3
         PDEDSNAM
         SPACE 3
         SPACE 3
DSCB1    DSECT
         IECSDSL1 1
         SPACE 3
*        FORMAT 1 AND 3 EXTENT DESCRIPTION
XTDSECT  DSECT
XTFLAGS  DS    X
XTNOEXT  EQU   X'00'          NO EXTENT
XTDATAB  EQU   X'01'          DAT BLOCKS
XTOVFLW  EQU   X'02'          OVERFLOW AREA
XTINDEX  EQU   X'04'          INDEX AREA
XTUSRLAB EQU   X'40'          USER LABEL EXTENT
XTSHRCYL EQU   X'80'          SHARING CYLINDERS
XTCYLBD  EQU   X'81'          CYLINDER BOUNDARIES
XTSEQ    DS    X              EXTENT SEQUENCE NUMBER
XTLOWCC  DS    H              LOWER CYLINDER
XTLOWHH  DS    H              LOWER TRACK
XTHICC   DS    H              UPPER CYLINDER
XTHIHH   DS    H              UPPER TRACK
         END
/*
//*------------------------------------------------------ ASM: VTOCFORM
//*
//ASM5.SYSIN DD *
*
*   VTOC ERROR MESSAGE ROUTINE, R1 POINTS TO VTOC COMMON AT ENTRY
*
VTOCMSG  ENTER 12,0           DO THE STANDARD HOUSEKEEPING
         LR    R11,R1         GET THE PARM REGISTER
         USING VTOCOM,R11     SET ADDRESSABILITY
         SPACE
         LM    R0,R1,MSGADDRS GET THE MESSAGE(S) TO SEND
         LTR   R0,R0          SECOND LEVEL MSG?
         BZ    ERRORM1        NO
         SPACE
         MVC   MSGTEXT1,0(R1) INSURE MSG IN WORK AREA
         LA    R1,MSGTEXT1
         SPACE
         LH    R14,0(R1)      LENGTH OF FIRST LEVEL MSG
         LA    R15,0(R14,R1)  ADDR OF END OF MSG
         LA    R14,1(R14)     JUMP MSG LENGTH
         STH   R14,0(R1)
         MVI   0(R15),C'+'    INDICATE SECOND LEVEL MSG EXISTS
         SPACE 2
         SR    R14,R14        CLEAR CHAIN FIELD
         LA    R15,1          ONE SEGMENT IN 2ND MSG
         STM   R14,R0,PUTOLD2 CREATE SECOND-LEVEL
*                             OUTPUT LINE DESCRIPTOR ('OLD')
         LA    R0,PUTOLD2
         SPACE 3
ERRORM1  LR    R14,R0         NEXT 'OLD' ADDR OR ZERO
         LA    R15,1          ONE SEGMENT
         LR    R0,R1          MSG ADDR
         STM   R14,R0,PUTOLD1 FIRST LEVEL 'OLD'
         SPACE
         LA    R1,PARMLIST
         USING IOPL,R1
         SPACE
         MVC   IOPLECT,ADDRECT
         MVC   IOPLUPT,ADDRUPT
         SPACE
         LA    R0,ATTNECB
         ST    R0,IOPLECB
         MVI   ATTNECB,0
         SPACE 3
         XC    PARMLIST+16(4),PARMLIST+16
         PUTLINE PARM=PARMLIST+16,MF=(E,(1)),                          X
               OUTPUT=(PUTOLD1,TERM,MULTLVL,INFOR)
         SPACE 3
         LEAVE EQ
         SPACE 3
         IKJIOPL
         SPACE 3
         VTOCOM
         END
/*
//*------------------------------------------------------ ASM: VTOCMSGX
//*
//ASM6.SYSIN DD *
         TITLE 'VTOC COMMAND PRINT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
* TITLE -      VTOC COMMAND PRINT ROUTINE                             *
*                                                                     *
* FUNCTION -   PRINT THE DATA PASSED TO IT.  IT WILL USE THE DDNAME   *
*              SYSOUT IF IT IS ALLOCATED, AND WILL USE THE VTOCMSG    *
*              ROUTINE IF NOT.  IT CAN ALSO PUT OUT THE DATA TO       *
*              AN OUTPUT DATA SET.  TOTALS ARE COMPUTED HERE.         *
*                                                                     *
* OPERATION -  FOR UNSORTED DATA, GET THE CURRENT ENTRY, ADD TO THE   *
*              TOTALS, AND OUTPUT IT.  IF THE DATA IS SORTED, THE     *
*              ACTION IS MORE COMPLEX, BECAUSE ALL THE DATA SETS      *
*              ARE TO BE OUTPUT.  THE TOTALS AND BREAKS MAY BE        *
*              NEEDED AT ANY POINT.                                   *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *
*                                                                     *
* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *
*              THEIR ATTRIBUTES, WITH TOTALS AND BREAKS AS NEEDED.    *
*              ALSO TO THE OUTPUT DATA SET, IF NEEDED.  IF SYSOUT     *
*              IS NOT ALLOCATED, VTOCMSG IS USED FOR OUTPUT.          *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
*
*        MACRO FOR DEFINING FAKE PDE FOR A DEFAULT LIST
*
         EJECT
VTOCPRNT ENTER 12,20          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING PRNTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        CHECK FOR THE PRINT CLEAN - CLOSE AND FREEMAIN
*
         CLI   VTCEPRNT,0     IS IT TIME
         BNE   PRNTCLEN       YES, GO DO IT
*
*        CHECK FOR THE FIRST TIME THROUGH
*        IF SO, SET UP THE DCB'S AND OPEN THEM
*
         CLI   FIRSTIM,0      IS THIS THE FIRST TIME?
         BNE   CHKSORT        NO, KEEP ON TRUCKIN'
         B     PRTINIT    INITIALIZE FOR PRINTING
*
*        CHECK TO SEE IF THE DATA IS SORTED
*
CHKSORT  CLI   SORTK+1,2      IS THIS NOSORT?
         BNE   SORTED         NO, THE ENTRIES ARE SORTED
*
*        NOSORT WAS SPECIFIED.  ONLY THE CURRENT ENTRY IS AVAILABLE
*
         L     R3,FORMATAD    POINT TO THE ENTRY
         USING VTFMT,R3       FORMATTED DSCB ADDRESSABILITY
         LTR   R3,R3          IS IT THERE?
         BZ    CHEKTOT        NO, SEE IF A TOTAL HAS BEEN OUTPUT
         XC    FORMATAD,FORMATAD  CLEAR THE ADDRESS FOR LATER
*
*        ADD TO THE TOTALS
*
         BAL   R8,ADDTOT      GO DO IT
*
*        SEE IF THE OUTPUT DATA SET IS WANTED
*
         TM    OUTDCB+48,X'10'  IS THE DCB OPEN?
         BNO   NOOUTPT        NO, SKIP ALONG
         BAL   R8,OUTPUT      YES, GO DO IT
*
*        SEE IF THERE'S PRINTING TO DO
*
NOOUTPT  CLI   PRINTK+1,2     WAS NOPRINT SPECIFIED?
         BE    VTRET          YES, WE'RE DONE FOR NOW
         BAL   R8,PRINT       NO, PRINT OUT THE ENTRY
*
*        RETURN FROM WHENCE WE CAME
*
VTRET    LEAVE EQ,RC=0        EXEUNT
*
*        NOSORT, CHECK FOR OUTPUTTING THE TOTALS
*
CHEKTOT  TM    ENDTOTAL,ENTOTOUT  WAS THE TOTAL OUTPUT BEFORE?
         BO    VTRET          YES, JUST RETURN
         BAL   R8,PRNTOT      NO, OUTPUT THE TOTAL
         OI    ENDTOTAL,ENTOTOUT  REMEMBER THE TOTAL IS OUT
         B     VTRET          THEN RETURN
         EJECT
*
*        THE DATA IS SORTED, SO THE LISTS MUST BE EMPTIED.
*        CHECK EACH ITEM FOR A TOTAL AND FOR A BREAK
*        OUTPUT TO PRINT AND/OR THE OUTPUT DATA SET
*
*
*        FIRST GET THE TOTAL AND BREAK COUNTS FOR COMPARES
*
SORTED   LA    R1,TOTALN      POINT TO THE TOTAL PDL
         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER
         LTR   R15,R15        IS IT ZERO?
         BNZ   SETTNUM        NO, IT'S GOOD
         OI    ENDTOTAL,ENDTONLY  YES, TOTALS AT THE END ONLY
SETTNUM  BCTR  R15,0          CUT IT DOWN ONE
         STH   R15,NUMTOTAL   SET THE TOTAL COUNT
         LA    R1,BREAK       POINT TO THE BREAK PDL
         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER
         LTR   R15,R15        IS IT ZERO?
         BNZ   SETBNUM        NO, IT'S GOOD
         OI    ENDTOTAL,NOBREAK   YES, BREAK  AT THE END ONLY
SETBNUM  BCTR  R15,0          CUT IT DOWN ONE
         STH   R15,NUMBREAK   SET THE BREAK COUNT
*
*        START GOING THROUGH THE LISTS, PROCESS THE ENTRIES
*
         LA    R4,VTCSORTH    POINT TO THE LISTS
         LA    R5,VTCSORTE    POINT TO THE END OF THE LISTS
         ST    R5,ADDREND     SAVE THE ADDRESS
NEWLIST  L     R3,0(R4)       GET THE FIRST ENTRY FROM THIS LIST
         LTR   R3,R3          ANYTHING ON THIS LIST?
         BZ    NEXTLIST       NO, GET ANOTHER LIST
*
*        THIS IS AN ENTRY, DO THE TOTALS, PRINT, AND OUTPUT
*        CHECK FOR TOTALS AND BREAKS FIRST
*
GOTENTRY CLI   PRINTK+1,2     WAS NOPRINT SET?
         BE    CHKOUTPT       YES, SKIP INTERIM TOTALS
         MVI   TOTLAST,0      SET UP FLAG FOR TOTAL AS LAST ACTION
*        NOTE - EXTENSION - OUTPUT INTERIM TOTALS WITH THE KEY
         TM    ENDTOTAL,ENDTONLY  END TOTAL ONLY?
         BO    CHKBREAK       YES, SEE ABOUT BREAKS
         LH    R2,NUMTOTAL    GET THE LENGTH TO COMPARE
         L     R1,LASTKEY     GET THE LAST ENTRY
         EX    R2,COMPKEY     SEE IF THIS IS THE SAME
         BE    CHKBREAK       YES, KEEP COUNTING
*
*        THIS ONE IS DIFFERENT, PRINT THE TOTALS FIRST
*
         BAL   R8,PRNTOT      PRINT THE TOTALS
*
*        CHECK FOR A BREAK
*
CHKBREAK TM    ENDTOTAL,NOBREAK   NO BREAKS THIS TIME?
         BO    SKPBREAK       YES, SKIP PAST BREAKS
         LH    R2,NUMBREAK    GET THE LENGTH TO COMPARE
         L     R1,LASTKEY     GET THE LAST ENTRY
         EX    R2,COMPKEY     SEE IF THIS IS THE SAME
         BE    SKPBREAK       YES, KEEP COUNTING
*
*        THIS ONE IS DIFFERENT, GET A NEW PAGE
*
         MVC   LINECT,LINEMAX BE SURE THE NEXT ITEM GETS A NEW PAGE
         MVI   TOTLAST,0      DON'T SKIP A LINE AFTER TOTAL
         LA    R1,VTFDSN     POINT TO THE DSNAME
         ST    R1,LASTKEY    SAVE THE ADDRESS FOR BREAK COMPARES
*
*        PRINT THE ITEM
*
SKPBREAK CLI   TOTLAST,0      WAS A TOTAL NOT FOLLOWED BY A BREAK?
         BE    SKPBREA2       NO, CONTINUE NORMALLY
         MVC   MSGBL,MSGBLC   YES, SET UP A BLANK MESSAGE
         LA    R1,MSGBL       POINT TO IT
         BAL   R8,PRNTLINE    THEN PUTPUT IT
SKPBREA2 BAL   R8,PRINT       FINAL FORMAT AND PRINT
*
*        CHECK FOR DATA SET OUTPUT
*
CHKOUTPT TM    OUTDCB+48,X'10'     IS IT OPEN AND READY
         BNO   GOTOT          NO, GO DO THE TOTALS
         BAL   R8,OUTPUT      YES, PUT OUT THE DATA SET ENTRY
*
*        ADD UP THE TOTALS
*
GOTOT    BAL   R8,ADDTOT      SUM THEM
*
*        GET THE NEXT ENTRY
*
         ICM   R3,B'1111',VTFNEXT  FOLLOW THE CHAIN
         BNZ   GOTENTRY       SOMETHING'S THERE, USE IT
*
*        END OF THIS LIST, TRY THE NEXT LIST
*
NEXTLIST LA    R4,12(0,R4)    MOVE OVER ONE
         C     R4,ADDREND     WAS THAT THE LAST LIST?
         BL    NEWLIST        NO, KEEP TRYING
*
*        END OF THE LISTS, OUTPUT THE FINAL TOTAL AND RETURN
*
         BAL   R8,PRNTOT      LIST THE TOTAL
*
*        CLEAR OUT THE PRINT LISTS
*
         XC    VTCSORTH+000(256),VTCSORTH  CLEAR 64 ENTRIES
         XC    VTCSORTH+256(256),VTCSORTH+256 CLEAR 64 ENTRIES
         XC    VTCSORTH+512(256),VTCSORTH+512 CLEAR 64 ENTRIES
         XC    VTCSORTH+768(256),VTCSORTH+768 CLEAR 64 ENTRIES
         B     VTRET          THEN GET OUT OF HERE
         EJECT
*
*        PRINT CLEANUP ROUTINE - CLOSE DCB'S FIRST
*
PRNTCLEN TM    SYSOUT+48,X'10'  IS SYSOUT OPEN?
         BNO   PRNTCLO        NO, CHECK THE OUTDCB
         CLOSE (SYSOUT),MF=(E,OPENLIST)  DO THE CLOSE
PRNTCLO  TM    OUTDCB+48,X'10'  IS OUTDCB OPEN?
         BNO   PRNTFREE       NO, SKIP DOWN TO THE FREEMAINS
         CLOSE (OUTDCB),MF=(E,OPENLIST)  DO THE CLOSE
*
*        FREE UP THE STORAGE
*
PRNTFREE LA    R2,VTCGETMN    POINT TO THE TABLE
         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE
PRNTFRL  ICM   R3,B'1111',0(R2)  GET THE STORAGE ADDRESS
         BZ    VTRET          IF ZERO, WE'RE DONE
         FREEMAIN R,LV=VTCGETMS,A=(R3)  FREE IT
         XC    0(4,R2),0(R2)  CLEAR THE ADDRESS
         LA    R2,4(R2)       GET THE NEXT BLOCK ADDRESS
         BCT   R5,PRNTFRL     AND LOOP UNTIL DONE
         B     VTRET          THEN RETURN
*
         EJECT
*
*        ROUTINES USED ABOVE
*              ADDTOT - ADD TO THE CURRENT TOTALS
*              PRNTOT - PRINT OUT THE TOTALS AND CLEAR THEM
*              PRINT  - PRINT OUT AN ENTRY
*              OUTPUT - OUTPUT THE DATA SET ENTRY
*              PDLNUM - GET A NUMBER FROM A PDL ENTRY
*              PRNTLINE - INTERNAL ROUTINE TO COUNT LINES, OUTPUT HEAD
*
ADDTOT   L     R1,TOTDS       NUMBER OF DATA SETS
         LA    R1,1(R1)       ADD ONE
         ST    R1,TOTDS       STORE IT BACK
         L     R1,TOTALLOC    TOTAL ALLOCATION
         A     R1,VTFALLOC    ADD IN THIS DATA SET
         ST    R1,TOTALLOC    STORE IT BACK
         L     R1,TOTUSED     TOTAL USED SPACE
         A     R1,VTFUSED     ADD IN THIS DATA SET
         ST    R1,TOTUSED     STORE IT BACK
         BR    R8             RETURN
*
         EJECT
*
*        PRINT THE TOTALS
*              FIRST FORMAT THEM, THEN PUT THE LINE OUT TO SYSOUT
*              OR USE VTOCMSG TO LIST IT
*
PRNTOT   ST    R8,PRNTTOT8   SAVE THE RETURN ADDRESS
         MVC   MSGWORK(MSGTLEN),MSGTOTC  INIT THE MSG
         CONV  MSGWORK+4+11,TOTDS,5  CONVERT NO OF DATA SETS
         CONV  MSGWORK+4+28,TOTALLOC,8  CONVERT ALLOCATION
         CONV  MSGWORK+4+51,TOTUSED,8   CONVERT USED SPACE
         MVC   MSGWORK+4+37(6),SPACTYPE MOVE IN THE UNITS
         MVC   MSGWORK+4+60(6),SPACTYPE MOVE IN THE UNITS
*
*        NOW OUTPUT THE MESSAGE
*
         MVI   MSGWORK+4,C'0' ADD A CARRIAGE CONTROL
         LA    R1,MSGWORK     POINT TO THE TOTAL LINE
         BAL   R8,PRNTLINE    PUT OUT THE TOTAL LINE
         MVI   TOTLAST,1      NOTE THAT A TOTAL WAS THE LAST ITEM
         L     R8,PRNTTOT8    GET THE RETURN ADDRESS
         BR    R8             THEN RETURN
         EJECT
*
*        PRINT OUT THE FORMATTED DSCB
*              FIRST FORMAT IT
*
PRINT    ST    R8,PRINTR8     SAVE REGISTER 8 FOR RETURNING
         MVI   WORKLINE+4,C' ' BLANK OUT THE LINE
         MVC   WORKLINE+5(250),WORKLINE+4 SO INDIVIUAL FIELDS DON'T
         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST
         LA    R1,WORKLINE+4  POINT TO THE WORK  LINE
PRTLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER
         IC    R6,0(R2)       FROM THE TOP BYTE
         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES
         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS
         SR    R7,R7          CLEAR A REGISTER
         IC    R7,0(R6)       GET THE EXECUTE LENGTH
         LA    R5,1(R1)       SAVE A PLACE TO MOVE FIELD INTO
         LA    R1,1(R1,R7)    MOVE THE POINTER OVER
         LA    R0,WORKLINE+4  POINT TO THE BEGINNING AGAIN
         SR    R1,R0          AND FIND THE CURRENT LENGTH
         CH    R1,LINELEN     IS IT TOO LONG?
         BNL   PRTEND         YES, WE'RE DONE
         AR    R1,R0          NO, KEEP GOING
*
*        MOVE IN OR CONVERT THIS ITEM
*
         SR    R14,R14       CLEAR A REG FOR LENGTH OF RTN NO
         IC    R14,1(R6)     GET THE LENGTH OR ROUTINE
         N     R14,F127      CLEAR THE TOP BIT
         SR    R15,R15       CLEAR A REG FOR VTFMT
         IC    R15,2(R6)       DISPLACEMENT
         AR    R15,R3        RELOCATE IT
*
*        DECIDE WHERE TO PUT IT
*
         TM    1(R6),X'80'   IS IT IN CHARS
         BNO   PRTRTN        NO, USE THE SPECIAL ROUTINE
         SR    R7,R14        GET THE DIFFERENCE IN LENGTHS
         SRL   R7,1          GET HALF THE DIFFERENCE
         AR    R5,R7         PUT THE DATA HERE
         EX    R14,PRTMOVE   MOVE IN THE CHARACTERS
PRTINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER
         CLI   0(R2),0       ARE WE DONE?
         BNE   PRTLOOP        GO GET MORE ITEMS
PRTEND   LA    R1,WORKLINE   POINT TO THIS LINE
         BAL   R8,PRNTLINE   THEN GO PRINT IT
         L     R8,PRINTR8     GET THE RETURN ADDRESS
         BR    R8             RETURN
PRTMOVE  MVC   0(0,R5),0(R15)  EXECUTED MOVE
*
*        VARIOUS ROUTINES TO FORMAT BEFORE MOVING IN THE DATA
*
PRTRTN   LTR   R14,R14       BE SURE THE OFFSET IS OK
         BP    PRTRTN1        IT SEEMS ALL RIGHT
         ABEND 701,DUMP       CRASH AND BURN
PRTRTN1  B     *(R14)        GO DO YOUR THING
         B     PRDATES        4  CDATE, EXPDT
         B     PRLSTUS        8  LSTUS
         B     PRALLOC       12  ALLOC, USED
         B     PRUNUSED      16  ALLOC - USED
         B     PRPCT         20  100 * USED / ALLOC
         B     PREXT         24  EXT
         B     PRBLREC       28  BLKSZ LRECL
         B     PRDSN         32  DSNAME
*
*
*        CDATE AND EXPDT
*
PRDATES  SR    R14,R14       CLEAR REG FOR YEAR
         IC    R14,0(R15)    GET THE YEAR
         USING DUMMD,R5      ALLOW CONV TO USE SYMBOL
         CONV  DUMMA,(R14),2 CONVERT YEAR
         ICM   R14,B'0011',1(R15)  GET THE DAY
         CONV  DUMMA+2,(R14),3,EDMASK0,COMP0  CONVERT THE DAY
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        LAST USE DATE
*
PRLSTUS  MVC   CHARS,EDMASK   SET UP THE EDIT MASK
         ED    CHARS(6),0(R15)  CONVERT TO CHARACTERS
         MVC   0(5,R5),CHARS+1  THEN MOVE THEM IN
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        ALLOCATION AND USED
*
PRALLOC  ICM   R14,B'1111',0(R15)  GET THE AMOUNT
         BM    PRUNKN6       IF NEGATIVE, IT'S NOT KNOWN
         CONV  DUMMA,(R14),6 CONVERT THE NUMBER
         B     PRTINC        GO GET MORE PRINT ITEMS
PRUNKN6  MVC   0(6,R5),BLANKS  UNKNOWN AMOUNT, LEAVE IT BLANK
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        UNUSED SPACE
*
PRUNUSED ICM   R14,B'1111',VTFUSED  GET THE   USED SPACE
         BM    PRUNKN6       IF NOT KNOWN, SKIP ALONG
         L     R14,VTFALLOC  GET THE ALLOCATED SPACE
         S     R14,VTFUSED   MINUS THE USED SPACE GIVES UNUSED
         BZ    PRTINC        IF NO UNUSED SPACE, LEAVE BLANK
         CONV  DUMMA,(R14),6 CONVERT FOR PRINTING
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        PCT - PERCENTAGE USED
*
PRPCT    SR    R6,R6         CLEAR THE TOP PART OF THE NUMBER
         ICM   R7,B'1111',VTFUSED   GET THE AMOUNT OF USED SPACE
         BM    PRUNKN3       IF NOT KNOWN, LEAVE BLANK
         CLC   VTFALLOC,ZERO IS THE ALLOCATION ZERO?
         BNE   PRPCTM        NO, DO THE STANDARD STUFF
         CLC   VTFUSED,ZERO  IS THE USED SPACE ZERO?
         BE    PRUNKN3       YES, JUST USE BLANKS
PRPCTERR MVC   0(3,R5),=C'ERR'  NO, IT'S AN ERROR
         B     PRTINC        THEN GO TRY FOR MORE
PRPCTM   M     R6,F100       MULTIPLY BY 100 FOR PERCENT
         D     R6,VTFALLOC   DIVIDE BY ALLOC TO GET THE PERCENT
         LTR   R7,R7         IS IT LESS THAN ZERO?
         BM    PRPCTERR      YES, FLAG THE ERROR
         C     R7,F100       ALSO CHECK FOR OVER 100 PERCENT
         BH    PRPCTERR      THAT'S ALSO AN ERROR
         CONV  DUMMA,(R7),3  CONVERT FOR PRINTING
         B     PRTINC        GO GET MORE PRINT ITEMS
PRUNKN3  MVC   0(3,R5),BLANKS BLANK THE UNKNOWN
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        EXTENTS
*
PREXT    SR    R14,R14       CLEAR REG FOR YEAR
         IC    R14,0(R15)    GET THE YEAR
         CONV  DUMMA,(R14),2 CONVERT THE EXTENTS
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        LRECL AND BLKSZ
*
PRBLREC  LH    R14,0(R15)    GET THE DATA ( HALFWORD )
         CONV  DUMMA,(R14),5  CONVERT THE DATA
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        DATA SET NAME
*
PRDSN    LH    R14,VTFDSNL   GET THE DSNAME LENGTH
         CH    R14,DSNLENGT  CHACK FOR MAX LENGTH
         BL    PRDMOVE       THIS DSN IS SHORT ENOUGH
         LH    R14,DSNLENGT  CUT IT DOWN
PRDMOVE  BCTR  R14,0         COUNT DOWN ONE FOR THE EX
         EX    R14,PRTMOVE   MOVE IN THE DSNAME
         AH    R1,DSNLENOF   CORRECT THE LINE POINTER
         B     PRTINC        GO GET MORE PRINT ITEMS
         EJECT
*
*        OUTPUT THE FORMATTED DSCB AS IT IS
*
OUTPUT   CLEAR OUTWORK       CLEAR THE OUTPUT REC
         LH    R2,VTFDSNL     GET THE LENGTH OF THE DSNAME
         LA    R2,VTFMTL-1(R2)  GET THE FULL LENGTH MINUS ONE
         EX    R2,OUTMOVE    MOVE IN THE ACTUAL RECORD
         PUT   OUTDCB,OUTWORK    OUTPUT THE RECORD
         BR    R8             RETURN
OUTMOVE  MVC   OUTWORK(0),0(R3)  EXECUTED MOVE
         EJECT
*
*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER
*              BINARY FORM, PASSED BACK VIA REGISTER 15
*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW
*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION
*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS
*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS
*                 ANY CHARACTERS OTHER THEN 0-9, +, -
*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED
*
PDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS
         LH    R2,4(R1)       GET THE STRING ADDRESS
         L     R1,0(R1)       GET THE STRING ADDRESS
         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG
         SR    R5,R5          CLEAR THE CHARACTER COUNTER
         SR    R15,R15        CLEAR THE ANSWER
PDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT
         LA    R5,1(R5)       GET TO THE NEXT DIGIT
         CR    R5,R2          IS THIS THE END OF THE STRING?
         BH    PDLFINI        YES, EXIT
         SR    R7,R7          CLEAR A WORK REGISTER
         IC    R7,0(R6)       GET THE CHARACTER
         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'
         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS
         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN
         AR    R15,R7         ADD ON THE NEW DIGIT
         B     PDLLOOP        AND LOOP FOR MORE
*
*        CHECK FOR SPECIAL CHARACTERS
*
PDLSP    CLI   0(R6),C' '     IS IT A BLANK?
         BE    PDLLOOP        THEN IT'S OK
         CLI   0(R6),C'+'     IS IT A PLUS?
         BE    PDLLOOP        THAT'S ALSO OK
         CLI   0(R6),C'-'     IS IT A MINUS?
         BNE   PDLFINI        NO, JUST QUIT
         MVI   PDLMINUS,1     YES, NOTE IT
         B     PDLLOOP        AND LOOK FOR MORE
*
*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED
*
PDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?
         BNE   PDLLEAVE       NO, EXIT
         LNR   R15,R15        YES, MAKE IT NEGATIVE
PDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS
         BR    R8             RETURN
PDLH10   DC    H'10'
PDLH240  DC    H'240'
         EJECT
*
*        PRNTLINE - GET EACH LINE FOR SYSOUT, THEN COUNT THE LINES
*              OUTPUT HEADERS AND TITLE LINES AS NECESSARY
*
PRNTLINE STM   R1,R8,PRTLSAVE SAVE THE REGISTERS
         TM    SYSOUT+48,X'10' IS SYSOUT OPEN FOR BUSINESS?
         BNO   PRNTTERM       NO, IT'S NOT OPEN, USE VTOCMSG
         CLI   HEADK+1,2     NOHEADING REQUEST?
         BE    PRNTLIN       YES, JUST OUTPUT THE DATA LINE
*
*        DO THE LINE COUNTING
*
         LH    R2,LINECT      GET THE LINE COUNT
         CLI   4(R1),C'1'     IS IT REQUESTING A NEW PAGE?
         BE    PRNTPAGE       YES, DO IT
         CLI   0(R1),C'-'     SKIP 3 LINES
         BE    PRNTSKP3       YES, TRY IT
         CLI   0(R1),C'0'     SKIP 2 LINES?
         BE    PRNTSKP2       YES, DO IT
         B     PRNTSKP1       JUST SKIP ONE
PRNTSKP3 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
PRNTSKP2 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
PRNTSKP1 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
         STH   R2,LINECT      SAVE THE LINE COUNT
         CH    R2,LINEMAX     DOES THIS OVERFLOW  HE PAGE?
         BL    PRNTLIN        NO, JUST PUT OUT THIS LINE
*
*        PRINT OUT THE PAGE HEADER AND ITEM TITLES
*
PRNTPAGE LH    R6,PAGECT      GET THE PAGE COUNT
         LA    R6,1(R6)       ADD ONE TO IT
         STH   R6,PAGECT      THEN STORE IT BACK
         L     R7,PAGEADDR    GET THE PLACE TO PUT THE PAGE
         USING DUMMD,R7       DUMMY DSECT
         CONV  DUMMA,(R6),5   GET THE CHARACTERS
         DROP  R7
         ST    R1,PRNTLSAV    SAVE THE INPUT REG1
         PUT   SYSOUT,PRNTHEAD  OUTPUT THE HEADER
         PUT   SYSOUT,PRNTTITL  OUTPUT THE ITEM TITLES
         L     R1,PRNTLSAV    GET THE ORIGINAL LINE
         MVI   4(R1),C'0'     ALWAYS SKIP THE FIRST LINE AFTER NEW PAGE
         LA    R7,5           SET THE LINE COUNT
         STH   R7,LINECT      SAVE IT FOR LATER
PRNTLIN  CLEAR OUTWORK       CLEAR A PRINT RECORD
         LH    R6,0(R1)      GET THE RECORD LENGTH
         SH    R6,H5         MINUS 4 FOR PREFIX, 1 FOR EX
         LA    R3,4(R1)      POINT TO THE TEXT
         EX    R6,OUTMOVE    THEN MOVE IN THE LINE
         PUT   SYSOUT,OUTWORK      AND FINALLY PRINT IT
         B     PRNTLRET       THEN RETURN
*
*        SIMPLER CHECKING FOR VTOCMSG OUTPUT
*
PRNTTERM LH    R2,LINECT      GET THE LINE COUNT
         LA    R2,1(R2)       IGNORE CARRIAGE CONTROL
         STH   R2,LINECT      SAVE IT BACK
         LR    R6,R1          SAVE THE ORIGINAL REG 1
         MVI   4(R1),C' '    BLANK THE CARRIAGE CONTROL
         CLI   HEADK+1,2     NOHEADING REQUEST?
         BE    PRNTTLIN       YES, JUST OUTPUT THE DATA LINE
         CH    R2,LINEMAX     NEED A NEW TITLE?
         BL    PRNTTLIN       NO, KEEP GOING
         VTOCMSG PRNTTITH     YES, PUT IT OUT
         MVC   LINECT,H2      RESET THE LINE COUNT
PRNTTLIN VTOCMSG 0(R6)        OUTPUT THE PASSED LINE
PRNTLRET LM    R1,R8,PRTLSAVE RESTORE THE REGISTERS
         BR    R8             THEN RETURN
         EJECT
PRTINIT  MVI   FIRSTIM,10    FLAG THE INITIALIZATION AS DONE
         LA    R1,TABTITL    POINT TO THE BUG TABLE
         ST    R1,ATABTITL   LET CHECK KNOW WHERE IT IS
*
*        SET UP THE CHARACTERS FOR TYPE OF SPACE ALLOC.
*
         LH    R2,SPACEK      GET THE SPACE TYPE KEYWORD
         SLA   R2,3           MULTIPLY BY 8
         LA    R2,TABSPACE(R2)  RELOCATE IT
         MVC   SPACTYPE,0(R2) SAVE THE CHARACTERS
         CLI   PRINTK+1,2     IS THIS NOPRINT?
         BE    NOOPEN         YES, SKIP THE OPEN
         MVC   SYSOUT(SYSOUTL),SYSOUTC  INITIALIZE THE DCB
         MVI   OPENLIST,X'80' TERMINATE THE LIST
         LA    R1,JFCB       POINT TO THE JFCB
         ST    R1,DCBEXIT    AND PUT THE ADDR IN THE DCB EXIT
         MVI   DCBEXIT,X'87' NOTE IT AS A JFCB EXIT
         LA    R1,DCBEXIT    POINT TO THE EXIT LIST
         LA    R2,SYSOUT     AND TO THE DCB FOR ADDRESSABILITY
         USING IHADCB,R2     TELL THE ASSEMBLER ABOUT IT
         STCM  R1,B'0111',DCBEXLSA  STUFF IT INTO THE DCB
         TM    CHARSPL+6,X'80'  CHARS PER LINE ENTERED?
         BZ    RDJFCB        NO, CONTINUE ALONG
         LA    R1,CHARSPL    YES, POINT TO THE PDL
         BAL   R8,PDLNUM     CONVERT TO A NUMBER
         STH   R15,DCBLRECL  SAVE THE NEW LRECL
         STH   R15,LINELEN   ALSO THE LINE LENGTH
         TM    BLKSZSET+6,X'80'  BLOCKSIZE ENTERED?
         BZ    BLKEQREC      NO, BLOCKSIZE EQUALS LRECL
         LA    R1,BLKSZSET      POINT TO THE PDL
         BAL   R8,PDLNUM     GET THE NUMBER
BLKEQREC STH   R15,DCBPRECL  STUFF IT AWAY
         DROP  R2            FINISHED WITH THE DCB
RDJFCB   RDJFCB ((R2)),MF=(E,OPENLIST)  SEE IF IT'S THERE
         LTR   R15,R15       WAS IT THERE?
         BNZ   NOOPEN        NO, SKIP ALONG
         OPEN  ((R2),OUTPUT),MF=(E,OPENLIST)  OPEN THE PRINT DCB
*
*        INITIALIZE PRINT VARIABLES
*
*        SET LINES/PAGE AND LINESIZE
*
NOOPEN   MVC   LINEMAX,DEFLMAX  SET THE DEFAULT NUMBER OF LINES/PAGE
         TM    LINESPP+6,X'80'     LINES PER PAGE ENTERED?
         BZ    DEFLINPP     NO, SKIP ON
         LA    R1,LINESPP    YES, POINT TO THE PDL
         BAL   R8,PDLNUM     CONVERT TO A NUMBER
         STH   R15,LINEMAX   AND SAVE IT
DEFLINPP MVC   LINECT,LINEMAX SET UP TO PAGE ON THE FIRST WRITE
         TM    CHARSPL+6,X'80'     CHARS PER LINE ENTERED?
         BO    LENSET        YES, USE IT
         MVC   LINELEN,DEFLEN SET UP A DEFAULT LENGTH
         TM    SYSOUT+48,X'10' DO WE USE SYSOUT?
         BO    LENSET         YES, USE WHAT WE'VE GOT
*        GET THE TERMINAL LINE SIZE TO SEE IF IT MAKES SENSE
         GTSIZE
         LTR   R1,R1          SEE IF IT'S GOOD
         BZ    LENSET         NO, JUST A ZERO, KEEP THE DEFAULTS
         BCTR  R1,0           CUT IT DOWN ONE TO AVOID A MESS
         STH   R1,LINELEN     SAVE THIS LENGTH
         LTR   R0,R0          FOR DISPLAYS, IT'S SCREEN SIZE
         BZ    LENSET         KEEP WHAT WE'VE GOT
         TM    LINESPP+6,X'80'  WAS LINES PER PAGE ENTERED?
         BO    LENSET           YES, DON'T OVERRIDE IT
         STH   R0,LINEMAX     AND SAVE THE NEW PAGE LOCATION
LENSET   DS    0H
*
*        SET UP THE PAGE COUNTER
*
PAGEAD   LH    R1,LINELEN     GET THE LENGTH OF THE LINE
         SH    R1,H10         MINUS TEN CHARACTERS
         LA    R1,PRNTHEAD(R1) THEN RELOCATE IT
         CLEAR PRNTHEAD       CLEAR THE LINE FIRST
         MVC   0(4,R1),CPAGE  MOVE IN THE CHARACTERS PAGE
         LA    R1,5(R1)       MOVE OVER 5 MORE
         ST    R1,PAGEADDR    THIS IS THE PLACE
*
*        BUILD THE PRINT HEADER LINE
*
         TM    HEADING+6,X'80' IS A USER HEADING PRESENT
         BO    USERHEAD       YES, USE IT
         MVC   PRNTHEAD(L'DEFHEAD),DEFHEAD  NO, GET A DEFAULT
*
*        ADD THE COMMAND BUFFER TO THE HEADING
*
         LH    R1,LINELEN    GET THE LINE LENGTHE
         SH    R1,H32        MINUS SPACES FOR PAGE, START OF HDR
         BNP   OUTOPEN       IF IT'S SHORT, SKIP ON
         L     R14,ADDRCBUF  POINT TO THE COMMAND BUFFER
         CH    R1,0(R14)     COMPARE LENGTHS
         BL    CBUFBIG       THE COMMAND BUFFER TOO BIG
         LH    R1,0(R14)     GET THE COMMAND BUFFER SIZE
CBUFBIG  SH    R1,H5         MINUS 1 FOR EX, 4 FOR CBUF PREFIX
         EX    R1,MOVEHED    MOVE THE CBUF TO THE DEFAULT HEADER
         B     OUTOPEN        GO SET UP THE PAGE COUNTER
USERHEAD LH    R1,HEADING+4   GET THE LENGTH
         BCTR  R1,0           MINUS ONE FOR THE EX
         L     R2,HEADING     POINT TO THE USER HEAD
         EX    R1,MOVEHEAD    THEN MOVE IT IN
OUTOPEN  DS    0H
*
*        SET UP THE WORK LINE
*
         LH    R1,LINELEN    GET THE LINE LENGTH
         LA    R1,4(R1)      ADD FOUR FOR THE PREFIX
         STH   R1,WORKLINE   OUTPUT TEXT
         STH   R1,PRNTTITH    ITEM TITLES
*        GET THE PRINT SPECIFICATION
*
         LA    R1,DEFPRNT
         ST    R1,VTPRNTLS   SAVE THE PRINT ITEM LIST ADDRESS
         TM    SUBPRTKY+6,X'80'  WERE ANY ITEMS SET UP
         BE    PRTITSET      NO, THE DEFAULT LIST IS OK
*
*        GET THE ADD, REPLACE, DELETE, AND NEW ITEMS
*        AND BUILD THE NEW LIST
*
*        FIRST CONVERT THE ENTERED TEXT INTO NUMERIC KEYS
*
         LA    R4,SUBPRTIT   POINT TO THE ITEMS
         LA    R5,VTPRNTEN   POINT TO THE OUTPUT KEYS
         LA    R0,VTPRNTEX   POINT TO THE END OF THE LIST
ENTKEY   BAL   R8,GETKEY     GET A KEY
         STC   R15,0(R5)     SAVE IT
         LA    R5,1(R5)      GET TO THE NEXT ONE
         CR    R0,R5         CHECK FOR THE END
         BNH   ENTKEND       IF THAT'S ALL
         ICM   R4,7,9(R4)    GET THE CHAIN POINTER
         BNZ   ENTKEY        AND KEEP GOING IF THERE'S MORE
ENTKEND  DS    0H            THE KEYS ARE ENTERED INTO THE LIST
*
*        MERGE THE ENTERED ITEMS AND THE DEFAULT LIST INTO A NEW LIST
*
         LA    R6,VTPRNTL    POINT TO THE NEW LIST
         ST    R6,VTPRNTLS   SAVE IT'S ADDRESS
         LA    R4,VTPRNTEN   POINT TO THE ENTERED ITEMS
         LA    R2,DEFPRNT    POINT TO THE DEFAULT LIST
         LR    R3,R2         POINT TO THE BEGINNING - NO DEFAULT IF NEW
         L     R1,SUBPRTKY   POINT TO THE KEYWORD
         CLI   0(R1),C'N'    IS THIS A NEW LIST?
         BE    PRTINEW       YES, SKIP PAST DEFAULT COPY
         LA    R3,DEFPRNTE   POINT TO THE END OF THE DEFAULT LIST
*
*        ADD, REPLACE, DELETE - COPY THE DEFAULT LIST
*
PRTICOPY CR    R2,R3         IS THIS THE END OF THE DEFAULT LIST?
         BNL   PRTITSET      YES, END OF PROCESSING FOR PRINT ITEMS
*
*        CHECK FOR ENTERED ITEMS THAT ARE ALSO
*              IN THE DEFAULT LIST.
*
PRTICDLP CLC   0(1,R2),0(R4) IS THIS THE SAME ITEM
         BE    PRTIFND       YES, SEE WHAT TO DO
         LA    R4,1(R4)      NO, GET TO THE NEXT ITEM
         CLI   0(R4),0       WAS THIS THE LAST ENTERED ITEM?
         BNE   PRTICDLP      NO, KEEP LOOKING
         LA    R4,VTPRNTEN   POINT BACK TO THE TOP OF THE LIST
*
*        ADD THIS ITEM TO THE NEW LIST
*
PRTICSKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
PRTICDEL LA    R2,1(R2)      GO DOWN THE DEFAULT LIST
         B     PRTICOPY      THEN KEEP ON CHECKING
*
*        AN ITEM WAS ENTERED AND WAS IN THE DEFAULT LIST
*        FOR DELETE, JUST DELETE ITEMS
*        FOR ADD AND REPLACE, DELETE ALL BUT THE FIRST ITEM
*              TO AVOID DUPLICATES
*              IF IT IS THE FIRST ITEM, INSERT THE ENTERED LIST
*
PRTIFND  LA    R0,VTPRNTEN   POINT TO THE FIRST ITEM
         CR    R0,R4         COMPARE WITH THE ITEM FOUND
         BH    PRTICDEL      NOT THE FIRST ITEM, DELETE IT
         CLI   0(R1),C'D'    IS THIS DELETE TIME?
         BE    PRTICDEL      THEN JUST DELETE IT
         CLI   0(R1),C'R'    IS THIS A REPLACE?
         BE    PRTIREPA      YES, IGNORE THIS DEFAULT ITEM
*
*        ADD THE DEFAULT ITEM FIRST
*
PRTIASKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
*
*        MOVE THE ITEMS IN FROM THE ADD OR REPLACE LIST
*
PRTIREPA LA    R2,1(R2)      GET PAST THE DEFAULT LIST ITEM
PRTIREP  LA    R4,1(R4)      GET PAST THE FIRST ENTRY
PRTINEXT CLI   0(R4),0       IS THIS THE LAST ITEM?
         BE    PRTICOPY      YES, SEE ABOUT MORE DEFAULTS
*
*        ADD AN ENTERED ITEM TO THE LIST
*
PRTINSKP MVC   0(1,R6),0(R4) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
         B     PRTIREP       GO GET MORE ENTERED ITEMS
*
*        NEW LIST, JUST USE IT AS ENTERED
*
PRTINEW  LA    R1,VTPRNTEN   POINT TO THE ENTERED LIST
         ST    R1,VTPRNTLS   THEN SAVE ITS ADDRESS FOR LATER
PRTITSET DS    0H
*
*        BUILD THE TITLE LINE FOR THE DSNAME FIELDS
*
         CLEAR PRNTTITL        BLANK OUT THE TITLE LINE
         MVC   PRNTTITL+1(139),PRNTTITL  SO THE WHOLE THING IS GOOD
         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST
         LA    R1,PRNTTITL    POINT TO THE TITLE LINE
TITLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER
         IC    R6,0(R2)       FROM THE TOP BYTE
         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES
         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS
         SR    R7,R7          CLEAR A REGISTER
         IC    R7,0(R6)       GET THE EXECUTE LENGTH
         EX    R7,MOVETIT     MOVE IN THE TITLE
         LA    R1,1(R1,R7)    MOVE THE POINTER OVER
         CLI   0(R2),DSNAME  IS THIS THE DSNAME KEY
         BE    TITDSN        YES, SPECIAL PROCESSING
         LA    R0,PRNTTITL    POINT TO THE BEGINNING AGAIN
         SR    R1,R0          AND FIND THE CURRENT LENGTH
         CH    R1,LINELEN     IS IT TOO LONG?
         BNL   TITOVER        YES, PULL BACK
         AR    R1,R0          NO, KEEP GOING
TITINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER
         CLI   0(R2),0       ARE WE DONE?
         BNE   TITLOOP        GO GET MORE TITLES
         B     TITEND         ALL DONE
TITDSN   LR    R6,R1         SAVE THE ADDRESS POINTER
         LA    R1,DSNPLN     POINT TO THE PDL FOR DSN LENGTH
         BAL   R8,PDLNUM     GO TRANSLATE IT
         LTR   R15,R15       WAS IT THERE?
         BP    TITDSN2       YES, USE IT
         LA    R15,44        NO, SET THE DEFAULT
TITDSN2  STH   R15,DSNLENGT  SAVE THE LENGTH
         SH    R15,H9        SUBTRACT THE 9 CHARS MOVED ALREADY
*              MINUS ONE FOR EX, PLUS ONE FOR SPACE
         MVI   0(R6),C' '    GET AN INITIAL BLANK
         EX    R15,DSNBLMOV  MOVE IN THE BLANKS
         LA    R1,1(R15,R6)  RESET THE POINTER ( INCLUDE A SPACE )
         LA    R15,1(R15)    ADD ON THE SPACE CHARACTER
         STH   R15,DSNLENOF  SAVE THE OFFSET
         B     TITINC        ALLOW DSNAME TO OVERFLOW THE LINE
*
*        TITLE RAN OFF THE END, CUT IT OFF
*
TITOVER  SR    R1,R7          SUBTRACT PAST THIS FIELD
         AR    R1,R0          RELOCATE IT
         BCTR  R1,0           THEN GET THE LAST CHARACTER
         MVC   0(9,R1),BLANKS THEN BLANK IT OUT
TITEND   TM    SYSOUT+48,X'10' IS THE DCB OPEN
         BNO   CKOUTPT       NO, TERMINAL OUTPUT, NO CC
         MVI   PRNTTITL,C'0'  ALWAYS SKIP A LINE FOR IT
CKOUTPT  CLI   OUTPUTK+1,1    OUTPUT THIS RUN?
         BNE   VTRET          YES, SKIP THE OPEN, JUST RETURN
         MVC   OUTDCB(OUTDCBL),OUTDCBC  INITIALIZE THE DCB
         MVI   OPENLIST,X'80' TERMINATE THE LIST
         OPEN  (OUTDCB,OUTPUT),MF=(E,OPENLIST)  OPEN THE DATA SET DCB
         B     VTRET          RETURN, INITIALIZATION IS DONE
         EJECT
*
*        ROUTINE TO CONVERT A TEXT DSCB ITEM
*        INTO ITS KEY NUMBER
*        INPUT IS REG 4 - IKJIDENT PTR
*        OUTPUT IS REG 15 - KEY NUMBER
*        ENTRY VIA BAL   R8,GETKEY
*
GETKEY   L     R1,ATABTITL     POINT TO THE TABLE
         LA    R1,12(R1)     POINT TO THE FIRST ENTRY
         LA    R15,1           SET UP THE KEY NUMBER COUNTER
         L     R6,0(R4)      POINT TO THE ENTERED TEXT
         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT
         BNP   GETKNOTF      NOT FOUND IF ZERO
         BCTR  R3,0          MINUS ONE FOR THE EX
GETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
GETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT
         BE    GETKFND       I FOUND IT
         LA    R1,12(R1)     GET TO THE NEXT KEY
         LA    R15,1(R15)    INCREMENT THE KEY COUNTER
         CH    R15,H26       CHECK FOR THE END OF THE TABLE
         BNH   GETKLOOP      NOT YET, KEEP LOOKING
*
*        KEY WAS NOT FOUND, SEND BACK A ZERO
*
GETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN
GETKFND  BR    R8            JUST RETURN
GETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE
H26      DC    H'26'
         EJECT
*
*        PROGRAM CONSTANTS
*
ZERO     DC    F'0'
F100     DC    F'100'
F127     DC    F'127'
DEFLMAX  DC    H'60'          DEFAULT LINES PER PAGE
DEFLEN   DC    H'132'         DEFAULT CHARS PER LINE
H2       DC    H'2'
H5       DC    H'5'
H9       DC    H'9'
H10      DC    H'10'
H12      DC    H'12'
H18      DC    H'18'
H32      DC    H'32'
MOVETIT  MVC   0(0,R1),3(R6)  MOVE IN THE TITLE
COMPKEY  CLC   0(0,R1),VTFDSN  EXECUTED COMPARE
MOVEHEAD MVC   PRNTHEAD(0),0(R2)
MOVEHED  MVC   PRNTHEAD+21(0),4(R14)  MOVE CMD BUF TO DEFAULT HEADER
DSNBLMOV MVC   1(0,R6),0(R6)  BLANK OUT THE DSN SPACE IN THE TITLE
CPAGE    DC    C'PAGE'
EDMASK   DC    XL16'40202020202020202020202020202120'
EDMASK0  DC    XL16'F0202020202020202020202020202120'
SKIP     DC    C'0'
COMP0    DC    CL16'0000000000000000'
BLANKS   DC    CL16'                '
STARS    DC    CL16'****************'
TABSPACE DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
*
         PRINT NOGEN
SYSOUTC  DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X
               RECFM=FBA,LRECL=150,BLKSIZE=1500
OUTDCBC  DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X
               RECFM=FB,LRECL=100,BLKSIZE=6000
*
*        PROGRAM MESSAGES
*
         SPACE 2
         SPACE
MSGTOTC  MSG   '  TOTALS -  NNNN DATA SETS, MMMMMMMM UUUUUU ALLOC, LLLLX
               LLLL UUUUUU USED '
MSGTLEN  EQU   *-MSGTOTC
MSGBLC   MSG   '                '
*
DEFHEAD  DC    CL20'1 VTOC COMMAND  V-77'
*
*        DEFAULT PRINT LIST
*
DEFPRNT  DC    AL1(ALLOC)
         DC    AL1(UNUSED)
         DC    AL1(PCT)
         DC    AL1(EXT)
         DC    AL1(DSORG)
         DC    AL1(RECFM)
         DC    AL1(LRECL)
         DC    AL1(BLKSZ)
         DC    AL1(CDATE)
         DC    AL1(LSTUS)
         DC    AL1(VOLUME)
         DC    AL1(DSNAME)
         DC    AL1(EXPDT)
         DC    AL1(SECQ)
         DC    AL1(SECT)
         DC    AL1(ROUND)
         DC    AL1(PASS)
         DC    AL1(ACTION)
         DC    AL1(TYPE)
         DC    AL1(0)        END OF THE LIST
DEFPRNTE EQU   *
DEFPRNTL EQU   *-DEFPRNT
*
*        TABLE OF PRINT ITEM LENGTHS AND TITLES
*
*        ENTRIES IN THE TABLE FOR EACH FORMATTED ITEM -
*        FIRST BYTE IS FIELD LENGTH FOR OUTPUT ( MINUS ONE FOR EX )
*        SECOND BYTE - X'80' BIT INDICATES A CHARACTER FIELD
*                            THEN BITS 0-7 GIVE VTFMT LENGTH
*                      OTHERWISE IT'S A KEY TO WHICH ROUTINE TO USE
*        THIRD BYTE - OFFSET IN FORMATTED DSCB, VTFMT
*        4-12 TH BYTES, THE TITLE FOR THE FIELD
*
*
TABTITL  DC    XL12'00'  DUMMY ENTRY FOR 0 ADDRESSING
         DC    AL1(8),AL1(128+7),AL1(VTFACTON-VTFMT),CL9' ACTION  '  1
         DC    AL1(6),AL1(128+5),AL1(VTFVOLUM-VTFMT),CL9' VOLUME  '  2
         DC    AL1(5),AL1(000+4),AL1(VTFCREDT-VTFMT),CL9' CDATE   '  3
         DC    AL1(5),AL1(000+4),AL1(VTFLSTAC-VTFMT),CL9' REFDT   '  4
         DC    AL1(5),AL1(000+4),AL1(VTFEXPDT-VTFMT),CL9' EXPDT   '  5
         DC    AL1(6),AL1(00+12),AL1(VTFALLOC-VTFMT),CL9'  ALLOC  '  6
         DC    AL1(6),AL1(00+16),AL1(VTFALLOC-VTFMT),CL9' UNUSED  '  7
         DC    AL1(3),AL1(00+20),AL1(VTFALLOC-VTFMT),CL9' PCT     '  8
         DC    AL1(2),AL1(00+24),AL1(VTFNOEPV-VTFMT),CL9' EX      '  9
         DC    AL1(3),AL1(128+2),AL1(VTFDSORG-VTFMT),CL9' DSO     ' 10
         DC    AL1(3),AL1(128+3),AL1(VTFRECFM-VTFMT),CL9' RFM     ' 11
         DC    AL1(5),AL1(00+28),AL1(VTFBLKSZ-VTFMT),CL9' BLKSZ   ' 12
         DC    AL1(5),AL1(00+28),AL1(VTFLRECL-VTFMT),CL9' LRECL   ' 13
         DC    AL1(4),AL1(128+0),AL01(VTFPROT-VTFMT),CL9' PASS    ' 14
         DC    AL1(3),AL1(128+0),AL1(VTFCATLG-VTFMT),CL9' CAT     ' 15
         DC    AL1(4),AL1(128+0),AL1(VTFSECAL-VTFMT),CL9' SECT    ' 16
         DC    AL1(5),AL1(00+28),AL1(VTFSECAM-VTFMT),CL9'  SECQ   ' 17
         DC    AL1(4),AL1(00+36),AL1(VTFVOLUM-VTFMT),CL9' UNIT    ' 18
         DC    AL1(5),AL1(128+0),AL1(VTFROUND-VTFMT),CL9' ROUND   ' 19
         DC    AL1(4),AL1(128+0),AL1(VTFDSTYP-VTFMT),CL9' TYPE    ' 20
         DC    AL1(6),AL1(00+12),AL01(VTFUSED-VTFMT),CL9'   USED  ' 21
         DC    AL1(8),AL1(00+32),AL1(VTFVOLUM-VTFMT),CL9'   CCHH  ' 22
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY3  ' 23
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY4  ' 24
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY5  ' 25
         DC    AL1(8),AL1(00+32),AL001(VTFDSN-VTFMT),CL9' DSNAME  ' 26
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
PRNTWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
TOTDS    DS    F              TOTAL COUNTER
TOTALLOC DS    F              TOTAL ALLOCATION
TOTUSED  DS    F              TOTAL USED
FTOTDS   DS    F              FINAL TOTAL DATA SETS
FTOTALLC DS    F              FINAL TOTAL ALLOC
FTOTUSED DS    F              FINAL TOTAL USED
PRNTLSAV DS    A
PRINTR8  DS    A
PRNTTOT8 DS    A
ADDREND  DS    A
PAGEADDR DS    A
OPENLIST DS    2A             PARM LIST FOR OPEN
PDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN
PRTLSAVE DS    8A             REGISTER SAVE AREA FOR PRNTLINE RTN
LASTKEY  DS    A              ADDRESS OF LAST KEY FOR SUBTOTALS, BREAKS
NUMBREAK DS    H              CHARACTERS TO COMPARE FOR BREAK
NUMTOTAL DS    H              CHARACTERS TO COMPARE FOR SUBTOTALS
         PRINT NOGEN
SYSOUT   DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X
               RECFM=FBA,LRECL=150,BLKSIZE=1500
SYSOUTL  EQU   *-SYSOUT
OUTDCB   DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X
               RECFM=FB,LRECL=100,BLKSIZE=6000
OUTDCBL  EQU   *-OUTDCB
ENDTOTAL DS    X              PROGRAM SWITCHES
ENTOTOUT EQU   X'80'          THE FINAL TOTALS HAVE BEEN OUTPUT
ENDTONLY EQU   X'10'          NO SUBTOTALS, END TOTALS ONLY
NOBREAK  EQU   X'08'          NO BREAKS
FIRSTIM  DS    X              INITIALIZATION FOR THIS ROUTINE
PDLMINUS DC    X'00'
TOTLAST  DS    X
SPACTYPE DS    CL6          CHARACTERS FOR SPACE UNITS
DSNLENGT DS    H
DSNLENOF DS    H
CHARS    DS    CL16           CONVERSION TO CHARACTERS
MSGWORK  DS    CL256          AREA FOR BUILDING MESSAGES
WORKLINE DS    CL256          AREA FOR DATA SET
PRNTHDRH DS    F
PRNTHEAD DS    CL256          AREA FOR HEADER
PRNTTITH DS    F
PRNTTITL DS    CL256          AREA FOR ITEM TITLES
MSGBL    DS    CL20           AREA FOR BLANK LINE
OUTWORK  DS    CL256          WORKING AREA FOR OUTPUT
DCBEXIT  DS    F
JFCB     DS    XL176
         SPACE
VTPRNTLS DS    A             PRINT ITEM LIST ADDRESS
VTPRNTL  DS    40C           PRINT ITEM LIST ( IF MODIFIED )
VTPRNTEN DS    40C
VTPRNTEX DS    C
         SPACE
         DS    0D
LENWORK  EQU   *-PRNTWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
DUMMD    DSECT
DUMMA    DS    C              DUMMY ENTRY TO USE FOR CONV
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
         END
/*
//*------------------------------------------------------ ASM: VTOCPRNT
//*
//ASM7.SYSIN DD *
         TITLE 'VTOC COMMAND  SORT  ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
* TITLE -      VTOC COMMAND  SORT  ROUTINE                            *
*                                                                     *
* FUNCTION -   PUT THIS FORMATTED DSCB INTO THE SORTED LIST.          *
*                                                                     *
* OPERATION -  IF THIS IS A NOSORT RUN, JUST CALL THE PRINT ROUTINE.  *
*              TO BUILD THE SORTED LIST, FIRST DO A SIMPLE HASH       *
*              ON THE FIRST CHARACTER.  BUILD UP TO 256 SEPARATE      *
*              LISTS TO SAVE SORT TIME.  THEN SEARCH THROUGH THESE    *
*              LISTS SEQUENTIALLY.                                    *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *
*                                                                     *
* OUTPUT -     THE FORMATTED DSCB IS PLACED INTO THE SORTED LIST.     *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
VTOCSORT ENTER 12,24          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING SORTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        IS THIS A NOSORT RUN ?
*        IF SO, JUST CALL PRINT
*
         CLI   SORTK+1,2      IS THIS NOSORT?
         BNE   GOSORT         NO, KEEP ON TRUCKIN'
         VTCALL PRNT          YES, CALL PRINT AND GET OUT
         B     SORTRET        GET OUT OF HERE
*
*        PUT THIS ENTRY WHERE IT BELONGS
*
GOSORT   L     R3,FORMATAD    POINT TO THE FORMATTED DSCB
         USING VTFMT,R3       SET ADDRESSABILITY
         LA    R6,SORTTAB     POINT TO THE SORT FIELDS TABLE
         SR    R4,R4
         IC    R4,1(0,R6)     LOAD HIGH KEY OFFSET
         LA    R4,VTFMT(R4)   POINT TO HIGH KEY
         LA    R2,VTCSORTH-12 SORT HEADER AREA
GOSORT1  LA    R2,12(0,R2)    NEXT ENTRY
         LH    R5,4(0,R2)     LOAD COMAPRE LENGTH
         CLI   0(R6),C'D'     DESCENDING SORT
         BE    GOSORT3        YES
         B     GOSORT4        NO
GOSORT2  ICM   R5,B'1111',0(R2) GET THE HEAD OF THE LIST
         BNZ   NOTFIRST       IF NON-ZERO, SEARCH THE LIST
*
*        FIRST ENTRY ON THE LIST, IT'S EASY
*
         ST    R3,0(R2)       START UP THE LIST
         B     SORTRET        THEN RETURN
GOSORT3  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST
         BL    GOSORT1
         B     GOSORT2
GOSORT4  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST
         BH    GOSORT1
         B     GOSORT2
*
*        FIND A SLOT FOR THIS ENTRY
*              FIRST GET THE SHORTER DSN LENGTH
*
NOTFIRST SR    R1,R1
         IC    R1,1(0,R6)     OFFSET OF SORT FIELD
         LA    R7,0(R1,R5)    LOAD PREV ENTRY FIELD ADDR
         LA    R8,0(R1,R3)    LOAD NEW ENTRY FIELD ADDR
         C     R1,=A(VTFDSN-VTFMT)  DSN
         BNE   NOTFRST1
         LH    R1,VTFDSNL-VTFMT(0,R3)
         CH    R1,VTFDSNL-VTFMT(0,R5)
         BNH   NOTFRST0
         LH    R1,VTFDSNL-VTFMT(0,R5)
NOTFRST0 BCTR  R1,0
         B     NOTFRST2
NOTFRST1 LH    R1,2(0,R6)     LOAD SORT FIELD EXEC LENGTH
NOTFRST2 CLI   0(R6),C'D'     DESCENDING SORT
         BE    NOTFRST4       YES
NOTFRST3 EX    R1,COMPVTF     COMPARE THE FIELDS
         BL    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN
         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD
         B     INSERT
NOTFRST4 EX    R1,COMPVTF     COMPARE THE FIELDS
         BH    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN
         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD
*
*        THE NEW ENTRY GOES HERE
*
INSERT   ST    R3,0(R2)       SAVE THE NEW POINTER
         ST    R5,VTFNEXT     JUST BEFORE THIS LIST ENTRY
         B     SORTRET        THEN EXIT
*
*
CHECKNXT LA    R6,4(0,R6)     NEXT SORT FIELD
         CLC   0(4,R6),=F'0'  ANY MORE FIELDS
         BE    INSERT         NO, PUT IT HERE
         B     NOTFIRST       YES, CHECK IT
*
*        GET THE NEXT ENTRY ON THIS LIST
*
NEXTENT  LA    R2,VTFNEXT-VTFMT(R5)  POINT BACK TO THIS ENTRY
         LA    R6,SORTTAB     RELOAD SORT FIELD TABLE ADDR
         ICM   R5,B'1111',VTFNEXT-VTFMT(R5)  GET THE NEXT ENTRY
         BNZ   NOTFIRST       THERE IS ONE, CHECK IT
         ST    R3,0(R2)       LAST ENTRY ON THE LIST, PUT IT THERE
*
*        RETURN
*
SORTRET  LEAVE EQ,RC=0
*
*
*
*        PROGRAM CONSTANTS
*
COMPVTF  CLC   0(0,R7),0(R8)     EXECUTED COMPARE
GOSORTCL CLC   0(0,R4),6(R2)     EXECUTED COMPARE
*
*
         PRINT NOGEN
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
SORTWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
         SPACE
         DS    0D
LENWORK  EQU   *-SORTWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         END
/*
//*------------------------------------------------------ ASM: VTOCSORT
//*
//LKED.SYSIN DD *
  ENTRY VTOCCMD
  NAME VTOC(R)
/*
//*------------------------------------------------------ LKED
//